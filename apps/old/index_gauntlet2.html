<!DOCTYPE html>
<html lang="en">
<head>
<title>Gautlet 3D</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=11" />
<meta charset="utf-8">
<link href="css/gauntlet.css"  media="screen, print" rel="stylesheet" type="text/css" />
</head>

<body>
<div id="viewport"></div>

<div id="hubs">
	<div id="debug"></div>
	<div id="gui"></div>
	<div id="info"></div>
	<div id="copy">
	<a href="http://3dflashlo.wordpress.com/" target="_blank">Loth 2014</a>
	. <a href="https://code.google.com/p/sea3d/" target="_blank">Sea3d</a>
	. <a href="http://github.com/mrdoob/three.js" target="_blank">Three.js</a>
	. <a href="https://github.com/jakesgordon/javascript-gauntlet/" target="_blank">Gauntlet 2d</a>
	</div>
	<div id="loading"><img src="res/images/loader.gif" alt="Loading SEA3D File." style="visibility: hidden;"></div>
</div>

<div id="gauntlet">
	<img id="booting" src='res/images/loader.gif'>
	<img id="splash"  src='res/images/splash0.png'>
	<canvas id="canvas">
		<div class="unsupported">Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element</div>
	</canvas>
	<div id="help" style="display:none;"></div>
	<div id="scoreboard">
		<img id="logo" src="res/images/logo.png">
		<h3 class="level"> &nbsp; </h3>
		<hr>
		<div class="high">High Score: <span class='value'>000000</span></div>
		<div id='warrior' class='player'>
			<div class='name'>Warrior</div>
			<div class='score'><div class='label'>Score</div><div class='value'>000000</div></div>
			<div class='health'><div class='label'>Health</div><div class='value'>000</div></div>
			<div class='treasure'>
				<img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png">
				<img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png">
			</div>
			<div class='press'>PRESS <b>1</b> TO START</div>
			<div class='multi'>multiplayer coming soon</div>
		</div>
		<div id='valkyrie' class='player'>
			<div class='name'>Valkyrie</div>
			<div class='score'><div class='label'>Score</div><div class='value'>000000</div></div>
			<div class='health'><div class='label'>Health</div><div class='value'>000</div></div>
			<div class='treasure'>
				<img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png">
				<img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png">
			</div>
			<div class='press'>PRESS <b>2</b> TO START</div>
			<div class='multi'>multiplayer coming soon</div>
		</div>
		<div id='wizard' class='player'>
			<div class='name'>Wizard</div>
			<div class='score'><div class='label'>Score</div><div class='value'>000000</div></div>
			<div class='health'><div class='label'>Health</div><div class='value'>000</div></div>
			<div class='treasure'>
				<img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png">
				<img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png">
			</div>
			<div class='press'>PRESS <b>3</b> TO START</div>
			<div class='multi'>multiplayer coming soon</div>
		</div>
		<div id='elf' class='player'>
			<div class='name'>Elf</div>
			<div class='score'><div class='label'>Score</div><div class='value'>000000</div></div>
			<div class='health'><div class='label'>Health</div><div class='value'>000</div></div>
			<div class='treasure'>
				<img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png"><img class='key' src="res/images/key.png">
				<img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png"><img class='potion' src="res/images/potion.png">
			</div>
			<div class='press'>PRESS <b>4</b> TO START</div>
			<div class='multi'>multiplayer coming soon</div>
		</div>
		<div id='sound' class='on' title='toggle music and fx'>
			<img id="soundIn" src='res/images/son.png'>
		</div>
	</div>
</div>

<!-- _     _   _
    | |___| |_| |__ 
    | / _ \  _|    |
    |_\___/\__|_||_| 2014
--> 

<script src="js/three.min.66.js"></script>
<script src="js/BufferGeometryUtils.66.js"></script>

<script src="js/loadersNew/sea3d/SEA3D.js"></script>
<script src="js/loadersNew/sea3d/SEA3DLoader.js"></script>
<script src="js/loadersNew/sea3d/SEA3DDeflate.js"></script>
<script src="js/loadersNew/sea3d/SEA3DLZMA.js"></script> 

<script src="js/gauntlet/vendor.js"></script>
<script src="js/gauntlet/game.js"></script>
<script src="js/gauntlet/gauntlet.js"></script>

<script src='js/libs/dat.gui.min.js'></script>
<script src='js/threex.rendererstats.js'></script>
<!--<script src="js/microcache.js"></script>-->

<script>
    var info = document.getElementById('info');

	var vsize = { x:window.innerWidth, y:window.innerHeight, z:window.innerWidth/window.innerHeight };
	var mouse = { x:0, y:0, move:true };
	var camera, center, controls, target, scene, renderer, composer, renderPass, delta, pointLight, pointLight2, spotLight, renderLoop;
	var clock = new THREE.Clock();
	var fps=0, time, time_prev=0, fpsint = 0;

	var Colors= [0x000000, 0x333333, 0x808080];
	//--------- Bakground, Ambient, Specular

	var materials = [];

	var generator = [];
	var treasure = [];
	var monster = [];
	var weapon = [];
	var exit = [];
	var door = [];
	var fx = [];

	var players = [];
	var grounds = [];
	var levels = [];

	var loader;

	var tEntities = [];

	var level, player, intro;
	var meshs=[];

	var list ="";

	var projector, raycaster;
	var mouse = new THREE.Vector2(), INTERSECTED;
	var radius = 100, theta = 0;
	var isIntro;
	var isIntroStart;
	var currentLevel;
	var maxLevel = 17;

	var viewConfig = {
		show2d : false,
		showInfo : false,
		fullStats : false
	}

	var camConfig = {
		horizontal : 45,
		vertical : 90,
		distance : 200
	}

	var container = document.getElementById( 'viewport' );
	container.style.cssText ="position:absolute; padding:0; height:100%; width:100%; top:0; left:0; overflow: hidden;";

	function initGame() {
	}

	function init3D() {
		//console.log(ua)
		//initGame();
		if(!renderer){
			setTimeout(initScene3D, 100);
			document.getElementById("canvas").style.visibility = "hidden";
			document.getElementById("scoreboard").style.visibility = "hidden";
			tell("<b>Choose player</b> <br><b>ARROW</b> keys to move<br><b>HOLD SPACE</b> to fire<br><b>ENTER</b> to use potion");
		}
	}

	function initScene3D() {

		renderer = new THREE.WebGLRenderer({precision: "lowp", antialias: false });//, alpha: false });
		renderer.setSize( vsize.x, vsize.y );
		renderer.autoClear = false;
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.shadowMapEnabled = true;
		
		//renderer.sortObjects = true;

		//renderer._microCache = new MicroCache();

		//renderer.shadowMapCascade = true;
		//renderer.shadowMapType = THREE.PCFSoftShadowMap;
		//renderer.shadowMapSoft = true;
		//renderer.shadowMapCullFace = THREE.CullFaceBack;

		container.appendChild( renderer.domElement );
		

		// SCENE
		scene = new THREE.Scene();
		//scene.fog = new THREE.Fog(  Colors[0], 100, 400 );
		scene.fog = new THREE.FogExp2( Colors[0], 0.00025 );

		projector = new THREE.Projector();
		raycaster = new THREE.Raycaster();

		// CAMERA
		camera = new THREE.PerspectiveCamera( 70, vsize.z, 1, 2000 );
		center = new THREE.Vector3(0,0,0);
		camera.position.z = 100;
		camera.position.y = 200;

		target = new THREE.Object3D();
		scene.add(target);
		
		var ambient = new THREE.AmbientLight( Colors[1] );
		scene.add( ambient );

		//spotLight = new THREE.DirectionalLight(0x000, 1.5);
		spotLight = new THREE.SpotLight( 0xffffff );
		spotLight.intensity = 1;
		spotLight.position.set(100,200,50);
		spotLight.target = target;
		spotLight.castShadow = true;

		spotLight.shadowCameraNear = 100;
		spotLight.shadowCameraFar = 300;
		spotLight.shadowCameraFov = 75;

		spotLight.shadowMapBias = 0.01;
		spotLight.shadowMapDarkness = 0.7;
		spotLight.shadowMapWidth = 1024;
		spotLight.shadowMapHeight = 1024;

		/*spotLight.shadowCascade = true;
		spotLight.shadowCascadeCount = 3;
		spotLight.shadowCascadeNearZ = [ -1.000, 0.995, 0.998 ];
		spotLight.shadowCascadeFarZ  = [  0.995, 0.998, 1.000 ];
		spotLight.shadowCascadeWidth = [ 1024, 1024, 1024 ];
		spotLight.shadowCascadeHeight = [ 1024, 1024, 1024 ];*/
		//spotLight.shadowCameraVisible = true; 

		//spotLight.onlyShadow= true;
		target.add(spotLight);
		//scene.add(spotLight);


	    /*pointLight = new THREE.PointLight( 0xffffff, 1, 200 );
		pointLight.position.set( 0, 30, 0 );
		target.add( pointLight );*/

		/*pointLight2 = new THREE.PointLight( 0xffffff, 3, 150 );
		pointLight2.position.set( 0, 0, 0 );
		target3.add( pointLight2 );*/


		initMaterial();
		initSea3DMesh();

		addGUI();
		//addGUIView();
		addGUICamera();

		window.addEventListener( 'resize', onResize, false );

		animate();
	}

	//===========================================================================
	// RENDER LOOP
	//===========================================================================

	var nloop = 0;

	function animate() {
		if(isIntro)requestAnimationFrame( animate );

		delta = clock.getDelta();

		nloop++
	    if(nloop===2){
	        nloop = 0;
	        THREE.AnimationHandler.update( delta*2 );
	    }
		
		camera.position.copy( Orbit( target.position, camConfig.horizontal, camConfig.vertical, camConfig.distance ) );
		camera.lookAt( target.position );

		// find intersections if intro
		if(isIntro){
			var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
			projector.unprojectVector( vector, camera );
			raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
			var intersects = raycaster.intersectObjects( intro.children );

			if ( intersects.length > 0 ) {
				if ( INTERSECTED != intersects[ 0 ].object ) {
					if ( INTERSECTED ){ 
						INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						intro3DIdle();
					}
					INTERSECTED = intersects[ 0 ].object;
					INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
					INTERSECTED.material.emissive.setHex( 0x909090 );
					//list = ("select "+INTERSECTED.name);
					if(heroesAnim.length>0){
						if ( INTERSECTED.name === "G0" ) heroesAnim[0].play("walk");
						if ( INTERSECTED.name === "G1" ) heroesAnim[1].play("walk");
						if ( INTERSECTED.name === "G2" ) heroesAnim[2].play("walk");
						if ( INTERSECTED.name === "G3" ) heroesAnim[3].play("walk");
				    }
				}
			} else {
				if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
				INTERSECTED = null;
				intro3DIdle();
			}
		}

		renderer.render( scene, camera );

		displayInfo();

		if(viewConfig.fullStats){
			//stats.update();
			rendererStats.update(renderer);
		}
		//tell(list);
	}

	function displayInfo(){
	    time = Date.now();
	    if (time - 1000 > time_prev) {
	        time_prev = time; fpsint = fps; fps = 0;
	    } fps++;

	    var Tinfo =[
	        "Three Render: " + fpsint +" fps<br>",
	        "memory: " + renderer.info.memory.programs 
	    ].join("\n");
	    info.innerHTML = Tinfo;
	}

	var stats, rendererStats;

	function fullStats(){
		if(viewConfig.fullStats){
			/*stats = new Stats();
			stats.domElement.style.position	= 'absolute'
			stats.domElement.style.right	= '10px'
			stats.domElement.style.bottom	= '161px'
			document.body.appendChild( stats.domElement );*/


			rendererStats = new THREEx.RendererStats();
			rendererStats.domElement.style.position	= 'absolute'
			rendererStats.domElement.style.right	= '10px'
			rendererStats.domElement.style.bottom	= '10px'
			document.body.appendChild( rendererStats.domElement );
		} else {
			if (rendererStats.domElement )document.body.removeChild(rendererStats.domElement);
			//if (stats.domElement )document.body.removeChild(stats.domElement);
		}

		//isFullStats = true;

	}

	//===========================================================================
	// LISTENERS
	//===========================================================================

	function onResize( event ) {
		vsize.x = window.innerWidth;
		vsize.y = window.innerHeight;
		vsize.z = vsize.x / vsize.y;

		camera.aspect = vsize.z;
		camera.updateProjectionMatrix();
		renderer.setSize( vsize.x, vsize.y );
	}

	function onDocumentMouseMove( event ) {
		event.preventDefault();
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	}

	function onDocumentMouseDown( event ) {
		if(isIntro && INTERSECTED !== null ){
			if ( INTERSECTED.name === "G0" ) window.game.playPlayer(0, currentLevel);
			if ( INTERSECTED.name === "G1" ) window.game.playPlayer(1, currentLevel);
			if ( INTERSECTED.name === "G2" ) window.game.playPlayer(2, currentLevel);
			if ( INTERSECTED.name === "G3" ) window.game.playPlayer(3, currentLevel);

			if ( INTERSECTED.name === "PLUS" ) {
				if(currentLevel == maxLevel) currentLevel = 0;
				currentLevel++; 
				createLabel("Level "+ currentLevel);
			}
			if ( INTERSECTED.name === "MOIN" ) {
				currentLevel--; 
				if(currentLevel ==0) currentLevel = maxLevel;
				createLabel("Level "+ currentLevel);
			}
		}
	}

	//===========================================================================
	//
	// MATERIALS
	//
	//===========================================================================

	function initMaterial(){
	    materials[0] = makeMaterial({ map:"avatar1.jpg", skinning:true }); // player 0 / 1;
		materials[1] = makeMaterial({ map:"avatar2.jpg", skinning:true }); // player 2 / 3;

		materials[2] = makeMaterial({ map:"wall.png", bump:true, bumpScale:10, shininess:10 }); // wall bump
		//materials[3] = makeMaterial({ map:"floor.jpg", bump:true, bumpScale:1, shininess:16 }); // floor bump
		materials[3] = makeMaterial({ map:"avatar3.jpg", skinning:true }); // monster 8 
		materials[4] = makeMaterial({ map:"avatar4.jpg", skinning:true }); // monster 4 / 5
		materials[5] = makeMaterial({ map:"avatar5.jpg", skinning:true }); // monster 6 / 7
		materials[6] = makeMaterial({ map:"avatar6.jpg", skinning:true }); // monster 8 

		materials[7] = makeMaterial({ map:"stairs.jpg", bump:true, bumpScale:3, shininess:10 }); // exit and door bump
		materials[8] = makeMaterial({ map:"item.jpg", bump:true, bumpScale:3, shininess:60 }); // treasure

		//materials[9] = makeMaterial({ map:"exp.png", transparent:true }); // fx

		materials[9] = new THREE.SpriteMaterial( { map: THREE.ImageUtils.loadTexture( 'res/textures/game/exp.png') } );// makeMaterial({ map:"exp.png", transparent:true }); // fx

		materials[10] = makeMaterial({ color:0x0000ff }); // weapon
		materials[11] = makeMaterial({ color:0x00ffff }); // generator

		materials[12] = makeMaterial({ color:0x606060, shininess: 10 }); // Guns

		//intro
		materials[20] = makeMaterial({ color:0xF90503 });
		materials[21] = makeMaterial({ color:0x08B4F0 });
		materials[22] = makeMaterial({ color:0xF5FC00 });
		materials[23] = makeMaterial({ color:0x00FF03 });

		materials[24] = makeMaterial({ color:0xFFFFFF });
		materials[25] = makeMaterial({ color:0x909090 });
		materials[26] = makeMaterial({ color:0x909090 });
	}

	function makeMaterial (data){
		var map, map2;
		var material = new THREE.MeshPhongMaterial( { ambient: Colors[1], specular: Colors[2], shininess: data.shininess || 50 } );

		if(data.map) {
			map = THREE.ImageUtils.loadTexture( 'res/textures/game/'+ data.map );
			//map = renderer._microCache.getSet( data.map , THREE.ImageUtils.loadTexture( 'res/textures/game/'+ data.map ));
		    map.repeat.set( 1, -1 );
		    map.wrapS = map.wrapT = THREE.RepeatWrapping;
		    map.anisotropy = renderer.getMaxAnisotropy();
		    material.map = map;
		}

		if(data.bump && data.map){
			 material.bumpMap = map;
			 material.bumpScale = data.bumpScale || 1;
		}

		/*if(data.normal) {
			map2 = THREE.ImageUtils.loadTexture( 'res/textures/game/'+ data.normal );
		    map2.repeat.set( 1, -1 );
		    map2.wrapS = map2.wrapT = THREE.RepeatWrapping;
		    map2.anisotropy = renderer.getMaxAnisotropy();
		    material.normalMap = map2;
		    material.normalScale.x = material.normalScale.y = data.normalScale || 2;
		}*/

		if(data.skinning) material.skinning = data.skinning;
		if(data.color) material.color.setHex( data.color );
		if(data.transparent) material.transparent = data.transparent;

		//material.perPixel = true;

		return material;
	}

	//===========================================================================
	// IMPORT SEA3D ASSETS
	//===========================================================================

	var monstersName = ["monster_zombi", "monster_demon", "monster_dog", "monster_wizard", "monster_death", "monster_nurce", "monster_chicken"];
	var monstersGeo, monstersMat;

	var wallRef = [];
	var dustRef = [];
	var itemRef = [];

	function initSea3DMesh() {

		//var 
		var SeaLoader = new THREE.SEA3D( true );
		var size = 1;
		var i;
		//list = "";

		SeaLoader.onComplete = function( e ) {
			// 0 -> 15 walls
			// 16 -> 23 treasure
			// 24 - 25 doors
			// 26 exit
			// 27 -> 30 Hero 
			// 31 -> 35 Monster 
			// 36 - floor
			for (i=0; i < SeaLoader.meshes.length; i++){
				meshs[i] = SeaLoader.meshes[i];
			}

			// level geometry
			for( i = 0; i < 16; i++) {
				if(i<10) wallRef[i] = getSeaGeometry("wall00"+i);
			    else wallRef[i] = getSeaGeometry("wall0"+i);
		    }
		    wallRef[16] = getSeaGeometry("floor");

		    for( i = 1; i < 8; i++) {
				dustRef[i] = getSeaGeometry("dust00"+i);
		    }
		   

		    // items geometry
		    for( i = 0; i < 8; i++) {
				itemRef[i] = getSeaGeometry("Item00"+i, true);
		    }
		    itemRef[8] = getSeaGeometry("door001", true);
		    itemRef[9] = getSeaGeometry("exit", true);

		    // moster geometry
		    monstersGeo = [];
		    for( i = 0; i < monstersName.length; i++) {
		    	monstersGeo.push(getMeshByName(monstersName[i]).geometry);
		    }
		    monstersMat = [ materials[3],  materials[4],  materials[6],  materials[4],  materials[5], materials[3], materials[6]];

			definePlayer();

			intro3D();

			document.getElementById("scoreboard").style.visibility = "visible";
		};
		SeaLoader.load( 'res/models/g3.sea' );
	}

	//===========================================================================
	// SEA3D TOOLS
	//===========================================================================

	var getSeaGeometry = function (name, buffer, scale, axe, child, deep){
		var c = child || 0;
		var d = deep || 0;
		var a = axe || "z";
		var b = buffer || false;
		var s = scale || 1;
		var g;
		if(c === 0 && d === 0) g = getMeshByName(name).geometry;
		else if(c >= 1 && d === 0) g = getMeshByName(name).children[c-1].geometry;
		else if(c >= 1 && d === 1) g = getMeshByName(name).children[0].children[c-1].geometry;
		else if(c >= 1 && d === 2) g = getMeshByName(name).children[0].children[0].children[c-1].geometry;
		scaleSea3DGeometry(g, s, a);

		if(b) g = THREE.BufferGeometryUtils.fromGeometry(g);
		//return m;
		return g;
	}

	var getMeshByName = function (name){
		for (var i=0; i !== meshs.length; i++){
			if(meshs[i].name === name){
				return meshs[i];
			} 
		} 
	}

	var scaleSea3DGeometry = function (geometry, scale, Axe) {
		var s = 1;
		var axe = Axe || 'z';

		for( var i = 0; i < geometry.vertices.length; i++) {
			var vertex	= geometry.vertices[i];
			if(axe==='x')vertex.x *= -s;
			else vertex.x *= s;
			if(axe==='y')vertex.y *= -s;
			else vertex.y *= s;
			if(axe==='z')vertex.z *= -s;
			else vertex.z *= s;
		}
		geometry.computeFaceNormals();
		geometry.computeCentroids();
		geometry.computeVertexNormals();
		geometry.verticesNeedUpdate = true;
	}

	THREE.Animator = function(mesh, name){
		this.mesh = mesh;
		this.name = name;
		this.current = null;
		this.animation = [];
	}

	THREE.Animator.prototype = {
		constructor: THREE.Animator,
		add:function(name, loop){
			var a = new THREE.Animation( this.mesh, this.name+"/"+name, name);
			a.loop = loop || false;
			a.name = name;
			this.animation.push(a);
			if(name === "idle") this.current = a;
		},
		play:function(name){
			if(name!==this.current.name || this.current === null){
				this.current.stop();
				for(var i=0, l=this.animation.length; i<l; i++ ){
					if(this.animation[i].name === name){
						this.animation[i].play();
						this.current = this.animation[i];
					} 
				}
			}
		},
		stop:function(){
			this.current.stop();
		},
		clean:function(){
			this.current.stop();
			/*for(var i=0, l=this.animation.length; i<l; i++ ){
				this.animation[i].reset();
			}*/

			this.animation.length = 0;
			this.current = null;
			this.mesh = null;
			this.name = "";
		}
	}

	//===========================================================================
	// HEROES CREATION
	//===========================================================================

	var heroes = ["hero_1_warrior", "hero_2_valkyrie", "hero_3_wizard", "hero_4_elf"];
	var heroesGeo, heroesMat, weaponsGeo, heroesAnim;

	function definePlayer(){

		heroesGeo = [getMeshByName(heroes[0]).geometry, getMeshByName(heroes[1]).geometry, getMeshByName(heroes[2]).geometry, getMeshByName(heroes[3]).geometry ];
		weaponsGeo = [getMeshByName("weapon0").geometry, getMeshByName("weapon1").geometry, getMeshByName("weapon2").geometry, getMeshByName("weapon3").geometry ];
		heroesMat = [materials[0], materials[0], materials[1], materials[1] ];
		heroesAnim = [];

		var mat, w, bone;
		for (var i = 0; i<4; i++){
			players[i] = new THREE.SkinnedMesh( heroesGeo[i], heroesMat[i], false );
			players[i].scale.set(1,1,-1);

			// weapon
			w = new THREE.Mesh( weaponsGeo[i], materials[10], false );
            bone = players[i].bones[12];
            w.name = bone.name;
            w.matrix = bone.skinMatrix;
            w.matrixAutoUpdate = false;
            players[i].add( w );

            players[i].castShadow = players[i].receiveShadow = true;

			// animations
			heroesAnim[i] = new THREE.Animator(players[i], heroes[i]);
			heroesAnim[i].add("idle", true);
			heroesAnim[i].add("walk", true);
			heroesAnim[i].add("death", false);
			heroesAnim[i].add("jump", false);
			heroesAnim[i].add("none", false);
		}
	}

	//===========================================================================
	// INTRO
	//===========================================================================
	
	function intro3D(){
		
		intro = new THREE.Object3D();
		scene.add(intro);
		target.position.set(0,22.5,0);

		for (var i = 0; i<4; i++){

			heroesAnim[i].play("jump");

			intro.add(players[i]);
			
			players[i].position.set((i*60)-90, 22.5, 0);
			players[i].rotation.y = 0;

			grounds[i] = new THREE.Mesh(new THREE.CubeGeometry( 56, 2, 56 ), materials[20+i]);
			intro.add(grounds[i]);
			grounds[i].position.y = -3;
			grounds[i].position.x = (i*60)-90;
			grounds[i].castShadow = false;
			grounds[i].receiveShadow = true;
			grounds[i].name = "G"+ i;
		}

		levels[0] = new THREE.Mesh(new THREE.PlaneGeometry( 20, 20 ), materials[25]);
		levels[0].position.set(62+10, -10-8, 28+10);
		intro.add(levels[0]);
		levels[0].name = "PLUS";

		levels[1] = new THREE.Mesh(new THREE.PlaneGeometry( 20, 20 ), materials[26]);
		levels[1].position.set(-62-10, -10-8, 28+10);
		intro.add(levels[1]);
		levels[1].name = "MOIN";

		levels[2] = new THREE.Mesh(new THREE.PlaneGeometry( 116, 20 ), materials[24]);
		levels[2].position.set(0, -10-8, 28+10);
		intro.add(levels[2]);

		levels[0].rotation.x = - 45 * ToRad;
		levels[1].rotation.x = - 45 * ToRad;
		levels[2].rotation.x = - 45 * ToRad;

		// get the current game level
		currentLevel = window.game.getLevel();
		createLabel("Level "+ currentLevel);
		createLabel(">",60,"#ff8080",25);
		createLabel("<",60,"#ff8080",26);
		
		isIntroStart = true;
		isIntro=true;

		animate();

		//startRender();
		setTimeout(introAnimEnd, 1000);
	}

	function introAnimEnd(){
		isIntroStart = false;
		for (var i = 0; i<4; i++){
			grounds[i].position.y = -1;
		}
		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	}

	function intro3DIdle(){
		if(players.length>0 && !isIntroStart){
			for (var i = 0; i<4; i++){
				if(heroesAnim[i].current !== "idle") heroesAnim[i].play("idle");
			}
	    }
	}

	function clear3Dintro(){
		document.removeEventListener( 'mousemove', onDocumentMouseMove );
		document.removeEventListener( 'mousedown', onDocumentMouseDown );
		var obj, i;
		for ( i = intro.children.length - 1; i >= 0 ; i -- ) {
			obj = intro.children[ i ];
			intro.remove(obj);
			//if(obj.animations) obj.stop();
			//obj.geometry.dispose();
		}

		scene.remove(intro);
		levels.length = 0;
		grounds.length = 0;
		//players.length = 0;
		isIntro = false;
		intro = null;

		//stopRender();
	}

	function createLabel(text, size, color, n) {
		if(!color) color = "#AAAAAA";
		if(!size) size = 36;
		if(!n) n = 24;

		var canvas = document.createElement("canvas");
		var context = canvas.getContext("2d");

		if(n==24)canvas.width = 116*3;
		else canvas.width = 20*3;
		canvas.height = 20*3;
		ctx = canvas.getContext("2d");
		ctx.font = 'italic '+size+'pt Calibri';
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";

		var gradient=ctx.createLinearGradient(0,0,0,canvas.height);
		gradient.addColorStop("0","white");
		gradient.addColorStop("1.0","yellow");

		ctx.strokeStyle = gradient;
		ctx.lineWidth=3;
		ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
		ctx.fillStyle = color;
		ctx.fillText(text, canvas.width / 2, canvas.height / 2);

		var texture = new THREE.Texture(canvas);
		texture.needsUpdate = true;

		materials[n].map = texture;
		materials[n].transparent = true;
	}

	//===========================================================================
	//
	// ENTITIES TRANSPHERE oo
	//
	//===========================================================================

	function entities3DInfo(entities, frame) {
		if(!viewConfig.showInfo) return;
		var t = "Entity lenght:" + entities.length + "<br>";
		var n, max, entity;
		var numMonster = 0;
		var numWeapon = 0;
		var numTreasure = 0;
		var numFx = 0;
		var numGenerator = 0;
		var numDoor = 0;
		var numExit =0;

		for(n = 0, max = entities.length ; n < max ; n++) {
			entity = entities[n];
			if(entity.monster){numMonster++;}
			if(entity.weapon){numWeapon++;}
			if(entity.treasure){numTreasure++;}
			if(entity.fx){numFx++;}
			if(entity.generator){if(entity.type.sx>31)numGenerator++;}
			if(entity.door){numDoor++;}
			if(entity.exit){numExit++;}
		}

		/*list = t  + "Monster:"+numMonster+"<br>"+ "Weapon:"+numWeapon+"<br>"+ "Treasure:"+numTreasure+"<br>"+ "Fx:"+numFx+"<br>"+ "Generator:"+numGenerator+"<br>"+ "Door:"+numDoor+"<br>"+ "Exit:"+numExit+"<br>"+"Frame"+ frame;*/
		tell(list);
	}

	function entitiesTo3D( entities ) {
		var n, max, entity;
		n = entities.length;
		//for(n = 0, max = entities.length ; n < max ; n++) {
		while(n--){
			entity = entities[n];

			if(entity.monster)  monster3D(entity);//monster3D(n, entity);
			if(entity.generator){ if(entity.type.sx>31) generator3D(n, entity); }

			if(entity.treasure) Treasure3D(n, entity); 
			if(entity.door) door3D(n, entity );
			if(entity.exit) exit3D(n, entity ); 

			if(entity.weapon) weapon3D(n, entity ); 
			if(entity.fx) fx3D(n, entity );
		}

		animate();
	}

	/*function entities3D( entity ,n ) {

		if(entity.monster) monster3D(entity);//monster3D(n, entity);
		if(entity.generator){ if(entity.type.sx>31){ generator3D(n, entity); }}
		// fixe and remove
		if(entity.treasure) Treasure3D(n, entity);
		if(entity.door) door3D(n, entity );
		// fixe
		if(entity.exit) exit3D(n, entity);
		// move and pool
		if(entity.weapon) weapon3D(n, entity );
		if(entity.fx) fx3D(n, entity );

	}*/

	//===========================================================================
	// THE MAP ++
	//===========================================================================

	var levelGeometry;
	

	function init3DLevel(){
		if(intro)clear3Dintro();
		if(level)clear3DLevel();

		level = new THREE.Object3D();
		levelGeometry = new THREE.Geometry();
		scene.add(level);

		//startRender();
	}

	function clear3DLevel(end){
		
		var obj, i;
		for ( i = level.children.length - 1; i >= 0 ; i -- ) {
			obj = level.children[ i ];
			level.remove(obj);
			//if(obj.animations) obj.stop();
			//obj.geometry.dispose();
		}

		/*for ( i = monstersAnim.length - 1; i >= 0 ; i -- ) {
			monstersAnim[i].clear();
		}*/

		levelGeometry.dispose();

		generator.length = 0;
		treasure.length = 0;
		monster.length = 0;
		weapon.length = 0;
		exit.length = 0;
		door.length = 0;
		fx.length = 0;

		tEntities.length = 0;

		scene.remove(level);
		level = null;

		//stopRender();

		if(end)intro3D();
		
	}

	//===========================================================================
	// GLOBAL 3D POSITION
	//===========================================================================

	function setPosition(m, x, y, z, r) {
		m.position.set( x, y, z );
		if(r !== undefined) m.rotation.y = r * ToRad;
		//m.position.copy( latLongToVector3(x, z, 1000, y) );
	}

	function latLongToVector3(lat, lon, radius, heigth) {
		var p = new THREE.Vector3();
	    var phi = (lat)*ToRad;
	    var theta = (lon)*ToRad;
	    p.x = (radius+heigth) * Math.cos(phi) * Math.cos(theta);
	    p.y = (radius+heigth) * Math.sin(phi) * Math.cos(theta);
	    p.z = (radius+heigth) * Math.sin(theta);
	    /*
	    p.x = -(radius+heigth) * Math.cos(phi) * Math.cos(theta);
	    p.y = (radius+heigth) * Math.sin(phi);
	    p.z = (radius+heigth) * Math.cos(phi) * Math.sin(theta);*/
	    return p;
	}


	//===========================================================================
	// 3D MAP
	//===========================================================================

	function add3DWall(x, y, sx, sy) {
		var block = new THREE.Mesh( wallRef[sx] );

		//block.position.set( x*32, 0, y*32 );
		setPosition(block, x*32, 0, y*32 );
		THREE.GeometryUtils.merge(levelGeometry, block);
	}

	function add3DFloor(x, y, sx, sy) {
		var block = new THREE.Mesh( wallRef[16] );
		//block.rotation.x = 180*ToRad;
		//block.position.set( x*32, 0, y*32 );
		setPosition(block, x*32, 0, y*32,180 );
		THREE.GeometryUtils.merge(levelGeometry, block);
		//console.log(sx, sy)
		if(sy!==0) {
			
			var block0 = new THREE.Mesh(  dustRef[sy] );
			setPosition(block0, x*32, 0, y*32 );
			THREE.GeometryUtils.merge(levelGeometry, block0);

		}//return; //no need shadow cell
		
	}

	function add3DLevel(){
		var block = new THREE.Mesh(THREE.BufferGeometryUtils.fromGeometry(levelGeometry), materials[2]);
		block.castShadow = true;
		block.receiveShadow = true;
		level.add(block);
	}

	//===========================================================================
	// 3D PLAYER
	//===========================================================================

	var currentPlayer;

	function init3DPlayer(type) {
		currentPlayer = type.sy;
		player = players[currentPlayer];
		heroesAnim[currentPlayer].play('idle');
		scene.add(player);
	}

	function remove3DPlayer() {
		scene.remove(player);
		heroesAnim[currentPlayer].stop();
	}

	function move3DPlayer( ee ) {
	    if(player){

			//player.rotation.y = ((-ee.dir*45)+180) * ToRad;

			setPosition(player, ee.x, 22.5, ee.y, ((-ee.dir*45)+180)  );
			setPosition(target, ee.x, 22.5, ee.y );
			//player.position.set(ee.x, 22.5, ee.y);
			//target.position.set(ee.x, 22.5, ee.y);

			if(ee.moving.dir!=null && heroesAnim[currentPlayer].current.name == "idle") heroesAnim[currentPlayer].play('walk');
			else if( ee.moving.dir == null && heroesAnim[currentPlayer].current.name == "walk") heroesAnim[currentPlayer].play('idle');
			else if( ee.health === 0 && heroesAnim[currentPlayer].current.name !== "death") heroesAnim[currentPlayer].play('death');

			//player info for animation
			//tell("Fire:"+pp.firing+"<br>"+"Move:"+pp.moving.dir+"<br>"+"Hurt:"+pp.hurting+"<br>"+"Dead:"+pp.dead+"<br>"+ player.currentAnimation.name);
		}
	}

	//===========================================================================
	// 3D EXIT ++
	//===========================================================================

	function exit3D(n, ee) {
		if(!exit[n]){
			var block = new THREE.Mesh( itemRef[9], materials[7]);
			//block.position.set(ee.x, 0, ee.y);
			setPosition(block, ee.x, 0, ee.y );
			block.castShadow = block.receiveShadow = true;
			level.add(block);
			exit[n] = block;
		}
	}

	//===========================================================================
	// 3D ITEMS ++
	//===========================================================================

	function Treasure3D(n, ee) {
		if(!treasure[n]){
			var block = new THREE.Mesh( itemRef[ee.type.sx], materials[8] );
			//block.position.set(ee.x, 0, ee.y);
			setPosition(block, ee.x, 0, ee.y );
			block.castShadow = block.receiveShadow = true;
			level.add(block);
			treasure[n] = block;
			//list += "Treasure "+ n +" add<br>";
		} else {
			if (!ee.active && treasure[n].castShadow){ 
				treasure[n].castShadow = treasure[n].receiveShadow = false;
				level.remove(treasure[n]);
				//list += "Treasure "+ n +" removed<br>";
            }
		}
	}

	//===========================================================================
	// 3D DOOR ++
	//===========================================================================

	function door3D(n, ee) {
		if(!door[n]){
			var block = new THREE.Mesh( itemRef[8], materials[7]);
			var rot = 0;
			//if(ee.type.sx === 10) { block = new THREE.Mesh( itemRef[8], materials[7]); }
			//else { block = new THREE.Mesh( itemRef[9], materials[7]); }
			if(ee.type.sx === 11) rot = 90;

			//block.position.set(ee.x, 0, ee.y);
			setPosition(block, ee.x, 0, ee.y, rot );
			block.castShadow = block.receiveShadow = true;
			level.add(block);
			door[n] = block;
			//list += "Door "+ n +" add<br>";
		} else {
			if (!ee.active && door[n].castShadow){
				door[n].castShadow = door[n].receiveShadow = false;
			    level.remove(door[n]);
			    //list += "Door "+ n +" removed<br>";
			}
		}
	}

	//===========================================================================
	// 3D GENERATOR
	//===========================================================================

	var genGeo = new THREE.CubeGeometry( 32, 60, 32 );

	function generator3D(n, ee) {
		if(!generator[n]){
			generator[n] = new THREE.Mesh( genGeo, materials[11] );//materials[ee.type.sy+19]);
			//generator[n].position.set(ee.x, 30, ee.y);
			setPosition( generator[n], ee.x, 30, ee.y );
			level.add( generator[n] );
			generator[n].castShadow = true;
			generator[n].receiveShadow = true;
		} else {
			if (!ee.active && generator[n].castShadow){ 
				generator[n].castShadow = false;
				generator[n].receiveShadow = false;
				level.remove(generator[n]);
			}
		}
	}

	/*function remove3DGenerator(n) {
		if(generator[n]){
			level.remove(generator[n]);
			generator[n].geometry.dispose();
		}
	}*/

	
	//===========================================================================
	// 3D MONSTER
	//===========================================================================

	//var monstersAnim = [];
	//var tmpMonstersType=[];
	//var tmpMonsters=[];
	//var tmpMonstersAnim=[];
	var tmpTimer=[];


	function monster3D(ee) {
		var n = ee.id;
		//var h;
		if(monster[n] === undefined){ monster[n] = { mesh:null, anim:null, type:null }; 
			/*var h=ee.type.sy-4;
			//tmpMonstersType[n] = h;
			var block = new THREE.SkinnedMesh( monstersGeo[h], monstersMat[h], false);
			block.scale.set(1,1,-1);
			block.castShadow = block.receiveShadow = true;

			var anim = new THREE.Animator( block, monstersName[h] );
			anim.add("idle", true);
			anim.add("walk", true);
			anim.add("death", false);
			anim.add("none", false);

			//level.add( block );
			monster[n] = { mesh:block, anim:anim, type:h };//= block;
			level.add( monster[n].mesh );*/

		} else {
			var m = monster[n];
			if( ee.active ){
				if(m.mesh==null && m.anim==null){
					m.type = ee.type.sy-4;
					m.mesh = new THREE.SkinnedMesh( monstersGeo[m.type], monstersMat[m.type], false);
					m.mesh.castShadow = m.mesh.receiveShadow = true;
					m.mesh.scale.set(1,1,-1);

					m.anim = new THREE.Animator( m.mesh, monstersName[m.type] );
					m.anim.add("idle", true);
					m.anim.add("walk", true);
					m.anim.add("death", false);

					level.add( m.mesh );
					//m.anim.add("none", false);
				} else {
			
				    if(ee.type.sy == 6 ) setPosition( m.mesh, ee.x, 5, ee.y, ((-ee.dir*45)+180) ); // dog
				    else if(ee.type.sy == 10) setPosition( m.mesh, ee.x, 6, ee.y, ((-ee.dir*45)+180) ); // chicken
				    else setPosition( m.mesh, ee.x, 25, ee.y, ((-ee.dir*45)+180));

			        if(ee.thinking == 0 ) m.anim.play('walk');
				    else if( ee.thinking > 0) m.anim.play('idle');

			    }
			} else {
				if ( ee.health == 0 && m.mesh !==null && m.anim !==null ){ 
					m.anim.play('death'); 
					tmpTimer[n] = setTimeout( function() {
						//m.anim.clean();
						level.remove( m.mesh );
						//
						m.anim = null;
						m.mesh = null;
						m.type = null;
						clearTimeout(tmpTimer[n]);

					}, 1000);
				}
			}
		}
	}

	/*

	function monster3D(ee) {
		var n = ee.id;
		//var h;
		if(monster[n] === undefined){// monster[n] = { mesh:null, anim:null, type:null }; }
			var h=ee.type.sy-4;
			//tmpMonstersType[n] = h;
			var block = new THREE.SkinnedMesh( monstersGeo[h], monstersMat[h], false);
			block.scale.set(1,1,-1);
			block.castShadow = block.receiveShadow = true;

			var anim = new THREE.Animator( block, monstersName[h] );
			anim.add("idle", true);
			anim.add("walk", true);
			anim.add("death", false);
			anim.add("none", false);

			//level.add( block );
			monster[n] = { mesh:block, anim:anim, type:h };//= block;
			level.add( monster[n].mesh );

		} else {
			if( ee.active ){
				//if(monstersAnim[n].current.name !== "none"){
				    //monster[n].rotation.y = ((-ee.dir*45)+180) * ToRad;
				   // if(ee.type.sy == 6) monster[n].position.set(ee.x, 5, ee.y); // dog
				   // else monster[n].position.set(ee.x, 25, ee.y);

				    if(ee.type.sy == 6) setPosition( monster[n].mesh, ee.x, 5, ee.y, ((-ee.dir*45)+180) ); // dog
				    else setPosition( monster[n].mesh, ee.x, 25, ee.y, ((-ee.dir*45)+180));
			   // }
			    if(ee.thinking == 0 ) monster[n].anim.play('walk');
				else if( ee.thinking > 0) monster[n].anim.play('idle');

				//if(ee.thinking == 0 ) monstersAnim[n].play('walk');
				//else if( ee.thinking > 0) monstersAnim[n].play('idle');


				//if(ee.thinking == 0 && monstersAnim[n].current.name == "idle") monstersAnim[n].play('walk');
				//else if( ee.thinking > 0 && monstersAnim[n].current.name == "walk") monstersAnim[n].play('idle');
			   // if (ee.health < 2) cloneMonster3D(n, ee);//monstersAnim[n].play('death');
				//else if (ee.health < 1 && monstersAnim[n].current.name !== "death") monstersAnim[n].play('death');
			} else {
				if (ee.health === 0 ){ 
					//monstersAnim[n].play('death'); 
					monster[n].anim.play('death'); 
					tmpTimer[n] = setTimeout( function() {
						//if(monster[n]){
						//monster[n].castShadow = monster[n].receiveShadow = false;
						level.remove( monster[n].mesh );
						clearTimeout(tmpTimer[n]);
						//monstersAnim[n].clear();
						//monster[n] = undefined;//null;
					//}
						//monster[n] = null;
					}, 1000);
				}
			}
		}
	}*/

	//===========================================================================
	// 3D FX
	//===========================================================================

	var fxGeo = new THREE.PlaneGeometry( 30, 30 );

	function fx3D(n, ee) {
		var n = ee.id;
		if( fx[n] === undefined && ee.x !== null && ee.y!== null){
		    //fx[n] = new THREE.Mesh( fxGeo, materials[9]);
		    fx[n] = new THREE.Sprite( materials[9] );
		    fx[n].scale.set( 30, 30, 1 );
		    //fx[n].rotation.x = - Math.PI / 2 ;
			level.add(fx[n]);
		} else {
			//if( ee.active ){
				console.log(ee.x, ee.y, ee.id)
			if( ee.x !== null && ee.y!== null ){
				setPosition( fx[n], ee.x,  19+(n*0.01), ee.y );
		        //fx[n].lookAt(camera.position);
			} else {
				level.remove(fx[n]);
				//fx[n].geometry.dispose();
				fx[n] = undefined;
			}
			//if(ee.type.sx === 13) fx[n].material =  materials[27];
		    //else if(ee.type.sx === 19) fx[n].material =  materials[29];
		    //fx[n].position.set(ee.x, 19+(n*0.01), ee.y);
		    
		}
	}

	//===========================================================================
	// 3D WEAPON
	//===========================================================================

	var WaponGeo = new THREE.CubeGeometry( 10, 5, 5 );

	function weapon3D(n, ee) {
		if(!weapon[n]){
			weapon[n] = new THREE.Mesh(WaponGeo, materials[10]);

			//weapon[n].material = materials[0];  
			level.add(weapon[n]);
		} else {
			if( ee.active ){
				setPosition( weapon[n], ee.x,  20, ee.y, ((-ee.dir*45)+90) );
			} else {
				level.remove(weapon[n]);
				//weapon[n].geometry.dispose();
				weapon[n] = null;
			}
			//weapon[n].rotation.y = ((-ee.dir*45)+90) * ToRad;
		    //weapon[n].position.set(ee.x, 20, ee.y);
		    
		}
	}

	//===========================================================================

	//-----------------------------------------------------
	//  TOOLS
	//-----------------------------------------------------

	function tell(Value) {
		document.getElementById('debug').innerHTML = Value;
	}

	//-----------------------------------------------------
	//  MATH
	//-----------------------------------------------------

	var ToRad = Math.PI / 180;

	function Orbit(origine, horizontal, vertical, distance) {
		var p = new THREE.Vector3(); 
		var phi = horizontal * ToRad;
		var theta = vertical * ToRad;
		p.x = (distance * Math.sin(phi) * Math.cos(theta)) + origine.x;
		p.z = (distance * Math.sin(phi) * Math.sin(theta)) + origine.z;
		p.y = (distance * Math.cos(phi)) + origine.y;
		return p;
	}

	//-----------------------------------------------------
	//  GUI
	//-----------------------------------------------------

	function addGUI() {
		gui = new dat.GUI({autoPlace:false, width:204});
		document.getElementById('gui').appendChild(gui.domElement);
		gui.close();
	}

	function addGUIView() {
		var f4 = gui.addFolder('View Option');
		f4.add( viewConfig, 'show2d' ).onChange( function() {
			if(viewConfig.show2d)document.getElementById("canvas").style.visibility = "visible"; 
			else document.getElementById("canvas").style.visibility = "hidden";
			window.game.no2d(viewConfig.show2d);
		});
		f4.add( viewConfig, 'showInfo' ).onChange( function() { if(!viewConfig.showInfo) list = "";});

		f4.add( viewConfig, 'fullStats' ).onChange( function() { fullStats() });
		f4.open();
	}

	function addGUICamera() {
		var f5 = gui.addFolder('Camera Option');
		f5.add( camConfig, 'horizontal', 0, 360 ).onChange( function() {  });
		f5.add( camConfig, 'vertical', 0, 360 ).onChange( function() {  });
		f5.add( camConfig, 'distance', 50, 500 ).onChange( function() {  });
		f5.open();
	}

	//window.onload = init;
	Game.run(Gauntlet);
</script>
</body>
</html>
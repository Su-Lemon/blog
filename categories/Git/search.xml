<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【Latex】在latex中添加notes</title>
      <link href="post/e32aaa71.html"/>
      <url>post/e32aaa71.html</url>
      
        <content type="html"><![CDATA[<p>有时候对于一个未完成的tex文件，为了方便与他人交流，或者为了给自己提个醒，我们希望能够在生成的pdf文件中加入醒目的注释。 <a id="more"></a></p><p>使用<code>todonotes</code>和<code>marginnote</code>都可以实现这样的功能。</p><h2 id="在页面两侧空白处添加notes">在页面两侧空白处添加notes</h2><h3 id="定义">定义</h3><div class="sourceCode" id="cb1"><pre class="sourceCode tex"><code class="sourceCode latex"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="bu">\usepackage</span>[textsize=tiny]&#123;<span class="ex">todonotes</span>&#125;</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="bu">\usepackage</span>&#123;<span class="ex">marginnote</span>&#125;</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="fu">\paperwidth</span>=<span class="fu">\dimexpr</span> <span class="fu">\paperwidth</span> + 6cm<span class="fu">\relax</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="fu">\oddsidemargin</span>=<span class="fu">\dimexpr\oddsidemargin</span> + 3cm<span class="fu">\relax</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="fu">\evensidemargin</span>=<span class="fu">\dimexpr\evensidemargin</span> + 3cm<span class="fu">\relax</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="fu">\marginparwidth</span>=<span class="fu">\dimexpr</span> <span class="fu">\marginparwidth</span> + 3cm<span class="fu">\relax</span></span></code></pre></div><p>其中最后四行是为了保持原来排版不变的情况下增加边距。 因为默认的边距往往较小，显示出来的效果比较糟糕，所以往往需要增加边距，以容纳注释文本。 在最终版本中应该将这四行删除。</p><h3 id="在文章中使用">在文章中使用</h3><ul><li><p>使用todonotes</p><pre><code>\todo&#123;Don&#39;t forget to put an introduction here.&#125;</code></pre></li><li><p>使用marginnote</p><pre><code>\marginnote&#123;This is a margin note&#125;[3cm]</code></pre></li></ul><p>这里的3cm定义了这个注释显示在页面中的高度。 关于使用marginnote的更详细用法可以参考 <a href="https://www.overleaf.com/learn/latex/Margin_notes">Marginnotes</a> 。</p><h2 id="使用todonotes实现inline-notes">使用todonotes实现inline notes</h2><p>行内的notes会占据正文的空间，这种方法的好处是不用考虑额外的边距问题，也更加方便阅读。</p><div class="sourceCode" id="cb4"><pre class="sourceCode tex"><code class="sourceCode latex"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="bu">\usepackage</span>[textsize=small]&#123;<span class="ex">todonotes</span>&#125;</span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>.</span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>.</span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>.</span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="fu">\todo</span>[inline,caption=&#123;&#125;]&#123;</span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  <span class="kw">\begin</span>&#123;<span class="ex">itemize</span>&#125;</span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="fu">\item</span> Bla bla bla</span><span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="kw">\end</span>&#123;<span class="ex">itemize</span>&#125;</span><span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>&#125;</span></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】各种系统信息查询指令</title>
      <link href="post/fd1aadb2.html"/>
      <url>post/fd1aadb2.html</url>
      
        <content type="html"><![CDATA[<p>总结在Linux中，查询各种系统信息的常用指令</p><a id="more"></a><h2 id="查询cpu信息">查询CPU信息</h2><h3 id="cpu个数核数等">CPU个数、核数等</h3><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co"># 查看物理CPU个数</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">cat</span> /proc/cpuinfo<span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;physical id&quot;</span><span class="kw">|</span> <span class="fu">sort</span><span class="kw">|</span> <span class="fu">uniq</span><span class="kw">|</span> <span class="fu">wc</span> -l</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co"># 查看 每个 物理CPU中core的个数(即核数)</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="fu">cat</span> /proc/cpuinfo<span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;cpu cores&quot;</span><span class="kw">|</span> <span class="fu">uniq</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co"># 总核数 = 物理CPU个数 * 每个物理CPU的核数 </span></span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="co"># 总逻辑CPU数 = 物理CPU个数 * 每个物理CPU的核数 * 超线程数</span></span><span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span><span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co"># 查看逻辑CPU的个数</span></span><span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="fu">cat</span> /proc/cpuinfo<span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;processor&quot;</span><span class="kw">|</span> <span class="fu">wc</span> -l</span><span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a></span><span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="co"># 查看CPU信息（型号）</span></span><span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a><span class="fu">cat</span> /proc/cpuinfo <span class="kw">|</span> <span class="fu">grep</span> name <span class="kw">|</span> <span class="fu">cut</span> -f2 -d: <span class="kw">|</span> <span class="fu">uniq</span> -c</span></code></pre></div><h3 id="cpu占用信息">CPU占用信息</h3><h3 id="top"><strong>top</strong></h3><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p><p>top显示系统当前的进程和其他状况,是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止.。比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p><ul><li>命令使用</li></ul><p><code>top [-] [d] [p] [q] [c] [C] [S] [s] [n]</code></p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co"># d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 </span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="co"># p 通过指定监控进程ID来仅仅监控某个进程的状态。 </span></span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co"># q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 </span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co"># S 指定累计模式 s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 </span></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co"># i 使top不显示任何闲置或者僵死进程。 </span></span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="co"># c 显示整个命令行而不只是显示命令名</span></span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span><span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co"># 示例，每隔1秒刷新显示信息</span></span><span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="ex">top</span> -d 1</span></code></pre></div><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210410205050.png" /></p><ul><li>输出信息含义</li></ul><p>如上图，统计信息区前五行是系统整体的统计信息。</p><p>第一行是任务队列信息，同 uptime 命令的执行结果；</p><p>第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行；</p><p>第四、五行为内存信息。</p><p>每行每隔元素的具体含义是：</p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co"># 第一行</span></span><span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ex">01</span>:06:48    当前时间</span><span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="ex">up</span> 1:22    系统运行时间，格式为时:分</span><span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ex">1</span> user    当前登录用户数</span><span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="ex">load</span> average: 0.06, 0.60, 0.48    系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</span><span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span><span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="co"># 第二、三行</span></span><span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a><span class="ex">total</span> 进程总数</span><span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="ex">running</span> 正在运行的进程数</span><span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="ex">sleeping</span> 睡眠的进程数</span><span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="ex">stopped</span> 停止的进程数</span><span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a><span class="ex">zombie</span> 僵尸进程数</span><span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a><span class="ex">Cpu</span>(s)<span class="bu">:</span> </span><span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a><span class="ex">0.3%</span> us 用户空间占用CPU百分比</span><span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a><span class="ex">1.0%</span> sy 内核空间占用CPU百分比</span><span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a><span class="ex">0.0%</span> ni 用户进程空间内改变过优先级的进程占用CPU百分比</span><span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a><span class="ex">98.7%</span> id 空闲CPU百分比</span><span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="ex">0.0%</span> wa 等待输入输出的CPU时间百分比</span><span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a><span class="ex">0.0%hi</span>：硬件CPU中断占用百分比</span><span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a><span class="ex">0.0%si</span>：软中断占用百分比</span><span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a><span class="ex">0.0%st</span>：虚拟机占用百分比</span><span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a></span><span id="cb3-23"><a href="#cb3-23" aria-hidden="true"></a><span class="co"># 第四、五行</span></span><span id="cb3-24"><a href="#cb3-24" aria-hidden="true"></a><span class="ex">Mem</span>:</span><span id="cb3-25"><a href="#cb3-25" aria-hidden="true"></a><span class="ex">191272k</span> total    物理内存总量</span><span id="cb3-26"><a href="#cb3-26" aria-hidden="true"></a><span class="ex">173656k</span> used    使用的物理内存总量</span><span id="cb3-27"><a href="#cb3-27" aria-hidden="true"></a><span class="ex">17616k</span> free    空闲内存总量</span><span id="cb3-28"><a href="#cb3-28" aria-hidden="true"></a><span class="ex">22052k</span> buffers    用作内核缓存的内存量</span><span id="cb3-29"><a href="#cb3-29" aria-hidden="true"></a><span class="ex">Swap</span>: </span><span id="cb3-30"><a href="#cb3-30" aria-hidden="true"></a><span class="ex">192772k</span> total    交换区总量</span><span id="cb3-31"><a href="#cb3-31" aria-hidden="true"></a><span class="ex">0k</span> used    使用的交换区总量</span><span id="cb3-32"><a href="#cb3-32" aria-hidden="true"></a><span class="ex">192772k</span> free    空闲交换区总量</span><span id="cb3-33"><a href="#cb3-33" aria-hidden="true"></a><span class="ex">123988k</span> cached    缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。</span></code></pre></div><p>进程信息区统计信息区域的下方显示了各个进程的详细信息。各列的含义如下：</p><div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>序号  列名    含义</span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ex">a</span>    PID     进程id</span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="ex">b</span>    PPID    父进程id</span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="ex">c</span>    RUSER   Real user name</span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="ex">d</span>    UID     进程所有者的用户id</span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="ex">e</span>    USER    进程所有者的用户名</span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="ex">f</span>    GROUP   进程所有者的组名</span><span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a><span class="ex">g</span>    TTY     启动进程的终端名。不是从终端启动的进程则显示为 ?</span><span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="ex">h</span>    PR      优先级</span><span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="ex">i</span>    NI      nice值。负值表示高优先级，正值表示低优先级</span><span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="ex">j</span>    P       最后使用的CPU，仅在多CPU环境下有意义</span><span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="ex">k</span>    %CPU    上次更新到现在的CPU时间占用百分比</span><span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="ex">l</span>    TIME    进程使用的CPU时间总计，单位秒</span><span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a><span class="ex">m</span>    TIME+   进程使用的CPU时间总计，单位1/100秒</span><span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="ex">n</span>    %MEM    进程使用的物理内存百分比</span><span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="ex">o</span>    VIRT    进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a><span class="ex">p</span>    SWAP    进程使用的虚拟内存中，被换出的大小，单位kb。</span><span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="ex">q</span>    RES     进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="ex">r</span>    CODE    可执行代码占用的物理内存大小，单位kb</span><span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="ex">s</span>    DATA    可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位<span class="ex">kb</span></span><span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ex">t</span>    SHR     共享内存大小，单位kb</span><span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a><span class="ex">u</span>    nFLT    页面错误次数</span><span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a><span class="ex">v</span>    nDRT    最后一次写入到现在，被修改过的页面数。</span><span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="fu">w</span>    S       进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)</span><span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a><span class="ex">x</span>    COMMAND 命令名/命令行</span><span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a><span class="ex">y</span>    WCHAN   若该进程在睡眠，则显示睡眠中的系统函数名</span><span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a><span class="ex">z</span>    Flags   任务标志，参考 sched.h</span></code></pre></div><p>默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。</p><p>更改显示内容通过 <strong>f</strong> 键可以选择显示的内容。按 f 键之后会显示列的列表，按 <strong>a-z</strong> 即可显示或隐藏对应的列，最后按回车键确定。 按 <strong>o</strong> 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。 按大写的 <strong>F</strong> 或 <strong>O</strong> 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 <strong>R</strong> 键可以将当前的排序倒转。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tools-Mujoco】创建自定义的Mujoco模型</title>
      <link href="post/bfad3f82.html"/>
      <url>post/bfad3f82.html</url>
      
        <content type="html"><![CDATA[<p>Mujoco是一个很好的仿真工具。你可能对它很熟悉，因为它强化学习领域受到众多学者的青睐，在OpenAI Gym中也有Mujoco的使用。 Mujoco提供了超快的动力学模拟，重点是接触动力学。它对于模拟机器人手臂和抓取任务特别有效，在模型预测控制和机器人模仿学习研究的文章中也颇具价值。</p><a id="more"></a><h2 id="前言">前言</h2><p>Mujoco官网有一个常用的<a href="http://www.mujoco.org/forum/index.php?resources/">模型库</a>，可以满足基本需求。但我们也可以针对特定的需求建立自己的模型，这在Mujoco中是比较容易的。定义一个模型有两个部分。</p><ol type="1"><li>STL文件，这是机器人部件的3D模型（导入STL允许你创建个性化的Mujoco模型，如果你不打算这样做，那么可以直接从第二步开始，利用Mujoco中基本的几何图形——长方体、椭圆等快速建立简单的模型）；</li><li>XML文件，它规定了模型中的运动学和动态关系。</li></ol><p>对于STL的操作，我们使用SketchUp（草图大师），它是免费提供的，并且操作简单容易上手。</p><p>这篇文章将从SketchUp中的一些基本设置开始，完成将机器人模型拆分，导出为各个关节组件的STL文件的任务（假设你已经完成了3D建模），最终生成Mujoco XML机器人描述文件的步骤。</p><p>如果你还没有完成3D建模，不妨在网上快速搜索一下，有很多免费的3D模型可供下载使用。例如在Github、https://www.traceparts.com/en等网站寻找3D模型。本文不打算涉及任何3D建模的内容。</p><h2 id="sketchup设置">Sketchup设置</h2><ul><li><strong>导入时设置模型单位</strong></li></ul><p>导入你的STL模型之前，在打开文件窗口中中选择你的文件，然后点击导入旁边的选项按钮，选择模型所定义的单位。如果你导入模型却看不到它，很可能是导入过程中选择的单位不正确，模型实在是太小而无法看到。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407165056.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">导入时设置模型单位</div></center><ul><li><strong>设置导出的模型单位</strong></li></ul><p>Mujoco使用你的STL模型中指定的单位。当使用相同的单位时，事情通常是最简单的。要修改模型导出时的单位，请到窗口 &gt; 模型信息 &gt; 单位 &gt; 长度。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407165919.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">设置导出时的模型单位</div></center><ul><li><strong>测量精度</strong></li></ul><p>在SketchUp中进行任何测量之前，请在 模型信息 中改变你的测量精度，精度为最大的数字，以确保你得到准确的测量结果(在建立Mujoco XML时需要)。</p><ul><li><strong>禁用捕捉</strong>。</li></ul><p>自动捕捉往往带来一些问题，要禁用它，请进入模型信息 &gt; 单位，并取消点击 "长度捕捉 "和 "角度捕捉"。</p><ul><li><strong>Xray模式</strong></li></ul><p>将默认视图设置为X射线模式会很有帮助，这样在操作组件时就可以看到模型内部。请进入 样式 &gt; 默认样式 &gt; X射线。</p><h2 id="如何从完整的机器人模型中保存一个单独的部件">如何从完整的机器人模型中保存一个单独的部件</h2><p>一个常见的状况是你有一个完整的机器人3D模型（就像上面的示意图中的机器人一样）。在这种情况下，建立Mujoco模型的第一步是为机器人的每个组件生成单独的STL文件，你希望能够独立控制每一个组件的运动。对于这些组件的每个STL文件，我们希望它连接到关节的点在原点 <span class="math inline">\((0,0,0)\)</span> ，因为这样可以简化在XML中建立模型的过程，并使正确指定惯性属性变得更加容易。</p><p>如果你的3D模型已经被分解成每个独立的组件，那么你可以跳到以原点为中心的部分。</p><h3 id="将各组件导出为单独的stl">将各组件导出为单独的STL</h3><p>确保你已经解锁了模型。要做到这一点，请使用 选择工具 突出显示整个模型。右击模型，并选择炸开模型（或打散）。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:80%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407171822.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">炸开模型</div></center><p>要得到单独的组件。例如，选择整个手臂，然后删除其余部分。选择 文件 &gt; 导出 &gt; 三维模型 &gt; STL。点击文件格式右侧的 选项 ，导出你的模型时，<strong>一定不要把你的模型保存为ASCII格式，选择二进制</strong>。重复此操作，直到将每个部件导出为自己的STL。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:80%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407172745.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">导出各个组件的STL文件</div></center><h3 id="将组件定位在原点">将组件定位在原点</h3><p>对于每个组件，需要确定它的哪个位置将会连接到其它组件，即连接机器人其它部分的关节点位置。我们要设置STL，使这个点在原点。通过这样做，我们可以简化以后构建XML文件的过程。</p><p>最简单的方法是用移动工具点击对象上的一个点，输入[0, 0, 0]，然后按回车键。这将会把选定的点移动到原点。或者用移动工具点击对象上的一个点后，将其移动到坐标系原点。</p><p>当选择下一个关节点时，需要测量其坐标。我们需要知道每个组件关节点的所有偏移距离，以便建立XML文件，所以一定要记下来!</p><h2 id="建立你的xml模型">建立你的XML模型</h2><p>一个完整的Mujoco模拟器应该包含三部分：</p><ul><li>STL文件，即三维模型；</li><li>XML 文件，用于定义运动学和动力学关系；</li><li>模拟器构建的py文件，使用mujoco-py将XML model创建成可交互的环境，供（强化学习）算法调用。</li></ul><h3 id="xml结构">XML结构</h3><p>当你在构建你的XML文件时，<strong>最好参考官方说明<a href="http://www.mujoco.org/book/XMLreference.html">Mujoco XML Reference</a></strong>。它是超级详细和彻底的，你主要需要<strong>关注官方对XML中各个标签的解释和它包含的各个属性的作用</strong>。这些内容主要包含在文档的asset和（world）body目录下。</p><p>在标准定义标签里面，我们主要使用以下三个部分。</p><ul><li><code>&lt;asset&gt;</code> ： 用<code>&lt;mesh&gt;</code> tag导入STL文件；</li><li><code>&lt;worldbody&gt;</code>：用<code>&lt;body&gt;</code>tag定义了所有的模拟器组件，包括灯光、地板以及你的机器人；</li><li><code>&lt;acutator&gt;</code>：定义可以执行运动的关节。定义的顺序需要按照运动学顺序来，比如多关节串联机器人以工具坐标附近的最后一个关节为joint0，依此类推。</li></ul><p>以下是一个XML的示例结构：</p><div class="sourceCode" id="cb1"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">&lt;mujoco</span><span class="ot"> model=</span><span class="st">&quot;example&quot;</span><span class="kw">&gt;</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="co">&lt;!-- set some defaults for units and lighting --&gt;</span></span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">&lt;compiler</span><span class="ot"> angle=</span><span class="st">&quot;radian&quot;</span><span class="ot"> meshdir=</span><span class="st">&quot;meshes&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="co">&lt;!-- 导入STL文件 --&gt;</span></span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="kw">&lt;asset&gt;</span></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        <span class="kw">&lt;mesh</span><span class="ot"> file=</span><span class="st">&quot;base.STL&quot;</span> <span class="kw">/&gt;</span></span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="kw">&lt;mesh</span><span class="ot"> file=</span><span class="st">&quot;link1.STL&quot;</span> <span class="kw">/&gt;</span></span><span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>        <span class="kw">&lt;mesh</span><span class="ot"> file=</span><span class="st">&quot;link2.STL&quot;</span> <span class="kw">/&gt;</span></span><span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="kw">&lt;/asset&gt;</span></span><span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a></span><span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>    <span class="co">&lt;!-- 定义所有模拟器组件 --&gt;</span></span><span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="kw">&lt;worldbody&gt;</span></span><span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>        <span class="co">&lt;!-- 灯光 --&gt;</span></span><span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>        <span class="kw">&lt;light</span><span class="ot"> directional=</span><span class="st">&quot;true&quot;</span><span class="ot"> pos=</span><span class="st">&quot;-0.5 0.5 3&quot;</span><span class="ot"> dir=</span><span class="st">&quot;0 0 -1&quot;</span> <span class="kw">/&gt;</span></span><span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>        <span class="co">&lt;!-- 添加地板，这样我们就不会凝视深渊 --&gt;</span></span><span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>        <span class="kw">&lt;geom</span><span class="ot"> name=</span><span class="st">&quot;floor&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> size=</span><span class="st">&quot;1 1 1&quot;</span><span class="ot"> type=</span><span class="st">&quot;plane&quot;</span><span class="ot"> rgba=</span><span class="st">&quot;1 0.83 0.61 0.5&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>        <span class="co">&lt;!-- the ABR Control Mujoco interface expects a hand mocap --&gt;</span></span><span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>        <span class="kw">&lt;body</span><span class="ot"> name=</span><span class="st">&quot;hand&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> mocap=</span><span class="st">&quot;true&quot;</span><span class="kw">&gt;</span></span><span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>            <span class="kw">&lt;geom</span><span class="ot"> type=</span><span class="st">&quot;box&quot;</span><span class="ot"> size=</span><span class="st">&quot;.01 .02 .03&quot;</span><span class="ot"> rgba=</span><span class="st">&quot;0 .9 0 .5&quot;</span><span class="ot"> contype=</span><span class="st">&quot;2&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>        <span class="kw">&lt;/body&gt;</span></span><span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a></span><span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        <span class="co">&lt;!-- 构建串联机器人 --&gt;</span></span><span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a><span class="co">        &lt;body name=&quot;base&quot; pos=&quot;0 0 0&quot;&gt;</span></span><span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a><span class="co">            &lt;geom name=&quot;link0&quot; type=&quot;mesh&quot; mesh=&quot;base&quot; pos=&quot;0 0 0&quot;/&gt;</span></span><span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a><span class="co">            &lt;inertial pos=&quot;0 0 0&quot; mass=&quot;0&quot; diaginertia=&quot;0 0 0&quot;/&gt;</span></span><span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a></span><span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a><span class="co">            &lt;!</span><span class="er">--</span><span class="co"> nest each child piece inside the parent body tags --&gt;</span></span><span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>            <span class="kw">&lt;body</span><span class="ot"> name=</span><span class="st">&quot;link1&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 1&quot;</span><span class="kw">&gt;</span></span><span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a>                <span class="co">&lt;!-- this joint connects link1 to the base --&gt;</span></span><span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>                <span class="kw">&lt;joint</span><span class="ot"> name=</span><span class="st">&quot;joint0&quot;</span><span class="ot"> axis=</span><span class="st">&quot;0 0 1&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a></span><span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>                <span class="kw">&lt;geom</span><span class="ot"> name=</span><span class="st">&quot;link1&quot;</span><span class="ot"> type=</span><span class="st">&quot;mesh&quot;</span><span class="ot"> mesh=</span><span class="st">&quot;link1&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> euler=</span><span class="st">&quot;0 3.14 0&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>                <span class="kw">&lt;inertial</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> mass=</span><span class="st">&quot;0.75&quot;</span><span class="ot"> diaginertia=</span><span class="st">&quot;1 1 1&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a></span><span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>                <span class="kw">&lt;body</span><span class="ot"> name=</span><span class="st">&quot;link2&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 1&quot;</span><span class="kw">&gt;</span></span><span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>                    <span class="co">&lt;!-- this joint connects link2 to link1 --&gt;</span></span><span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>                    <span class="kw">&lt;joint</span><span class="ot"> name=</span><span class="st">&quot;joint1&quot;</span><span class="ot"> axis=</span><span class="st">&quot;0 0 1&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a></span><span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>                    <span class="kw">&lt;geom</span><span class="ot"> name=</span><span class="st">&quot;link2&quot;</span><span class="ot"> type=</span><span class="st">&quot;mesh&quot;</span><span class="ot"> mesh=</span><span class="st">&quot;link2&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> euler=</span><span class="st">&quot;0 3.14 0&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a>                    <span class="kw">&lt;inertial</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> mass=</span><span class="st">&quot;0.75&quot;</span><span class="ot"> diaginertia=</span><span class="st">&quot;1 1 1&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a></span><span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>                    <span class="co">&lt;!-- the ABR Control Mujoco interface uses the EE body to --&gt;</span></span><span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>                    <span class="co">&lt;!-- identify the end-effector point to control with OSC--&gt;</span></span><span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a>                    <span class="kw">&lt;body</span><span class="ot"> name=</span><span class="st">&quot;EE&quot;</span><span class="ot"> pos=</span><span class="st">&quot;0 0.2 0.2&quot;</span><span class="kw">&gt;</span></span><span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>                        <span class="kw">&lt;inertial</span><span class="ot"> pos=</span><span class="st">&quot;0 0 0&quot;</span><span class="ot"> mass=</span><span class="st">&quot;0&quot;</span><span class="ot"> diaginertia=</span><span class="st">&quot;0 0 0&quot;</span> <span class="kw">/&gt;</span></span><span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>                    <span class="kw">&lt;/body&gt;</span></span><span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>                <span class="kw">&lt;/body&gt;</span></span><span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>            <span class="kw">&lt;/body&gt;</span></span><span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>        <span class="kw">&lt;/body&gt;</span></span><span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a>    <span class="kw">&lt;/worldbody&gt;</span></span><span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a></span><span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>    <span class="co">&lt;!-- 定义关节上的执行器 --&gt;</span></span><span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>    <span class="kw">&lt;actuator&gt;</span></span><span id="cb1-55"><a href="#cb1-55" aria-hidden="true"></a>        <span class="kw">&lt;motor</span><span class="ot"> name=</span><span class="st">&quot;joint0_motor&quot;</span><span class="ot"> joint=</span><span class="st">&quot;joint0&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-56"><a href="#cb1-56" aria-hidden="true"></a>        <span class="kw">&lt;motor</span><span class="ot"> name=</span><span class="st">&quot;joint1_motor&quot;</span><span class="ot"> joint=</span><span class="st">&quot;joint1&quot;</span><span class="kw">/&gt;</span></span><span id="cb1-57"><a href="#cb1-57" aria-hidden="true"></a>    <span class="kw">&lt;/actuator&gt;</span></span><span id="cb1-58"><a href="#cb1-58" aria-hidden="true"></a></span><span id="cb1-59"><a href="#cb1-59" aria-hidden="true"></a><span class="er">&lt;</span>/mujoco&gt;</span></code></pre></div><ul><li><p><strong>设置body position 和 geoms </strong></p><p>在<code>&lt;body&gt;</code>标签上的pos属性中设置与前一个<code>body</code>的偏移量，而不是在<code>geoms</code>上。在<code>&lt;joint&gt;</code>上你就可以设置<code>pos="0 0 0"</code>，这有助于简化后面的调试。</p><p>在每个主体部分，你可以有多个<code>&lt;joint&gt;</code>和<geom>。在同一主体上定义的<code>geom</code>将被融合在一起。如果你有几个融合在一起的geom的特定惯性属性，你必须为每个<code>geom</code>创建一个</p><body><p>，以便能够实例化它们自己的<code>&lt;inertial&gt;</code>标签。否则，建议将它们都放在同一个</p><body><p>中，以优化仿真速度。</p></li><li><p><strong>Orientation and inertia（方向和惯性）</strong></p><p>你可能需要旋转STLs，以便在您构建时将它们与机器人的其余部分正确对齐。你可以在<code>&lt;body&gt;</code>或<code>&lt;geom&gt;</code>标签中进行。如果你使用<code>&lt;inertial&gt;</code>标签，那么建议使用<code>&lt;geom&gt;</code>标签内的euler参数，而不是在<code>&lt;body&gt;</code>标签内。如果你在 <code>&lt;body&gt;</code> 标签中指定了旋转，还需要将相同的旋转应用于 <code>&lt;inertia&gt;</code> 参数，这使得事情变得复杂。</p><p>如果您没有提供 <code>&lt;inertial&gt;</code> 标签，惯性属性将由 geom 推断。</p></li><li><p><strong>Contype 和 conaffinity</strong></p><p>如果你不想让模型中的geom与其他部件发生碰撞，可以在geom标签上设置contype和conaffinity参数。如果你有一个紧密贴合的3D模型，并且遇到摩擦的问题，这可以很方便。</p></li><li><p><strong>ABR控制的End-effector tag（末端执行器）标签</strong></p><p>如果你要使用ABR控制库操作空间控制器，你需要在你要控制的机器人的点上添加一个标签<code>&lt;body name="EE" pos="0 0 0"&gt;</code>。通常是手。</p></li></ul><p>这些设置在 <strong><a href="http://www.mujoco.org/book/XMLreference.html">Mujoco XML Reference</a></strong> 都有简洁明了的说明。</p><p>一旦你添加了你的机器人身体部分，保存XML并用Mujoco仿真器仿真测试，指令类似于这样（Mujoco simulate的路径和xml文件的路径） <code>/.mujoco/mujoco200/bin/simulate file_path</code> 。你可能需要通过反复调整参数和在Mujoco中查看模型来进行一些微调。在XML文件中除了感兴趣的关节，先注释掉所有其它的关节，会使测试更容易。</p><p>最后，希望这些经验能够对你有所帮助，建模愉快。</p><h2 id="一些问题和解决方法">一些问题和解决方法</h2><ul><li><strong>SketchUp - 导入模型后看不到它</strong></li></ul><p>很可能是导入过程中选择的单位不正确，对象实在太小，看不清。打开STL文件时，在打开的文件窗口中选择你的文件，然后点击 "导入 "旁边的选项按钮来更改单位。</p><ul><li><strong>Mujoco - 我的手臂不动了，或者稍微移动一下就停止了。</strong></li></ul><p>在这种情况下，你很可能有链接之间的碰撞。可以在链接之间添加一个小的间隙（确保在随后的链接和关节中考虑到这种转变），或者可以使用contype和conaffinity标签来设置模型，以便不计算两个组件之间的碰撞。</p><p>例如，上述示例XML中，将链接之间的接触geom设置为具有不同的contype和conaffinity值，这样它们就不会相互刮擦而阻止运动。</p><ul><li><strong>Mujoco - 我的模型的一部分在疯狂地旋转。</strong></li></ul><p>这通常是由于被实例化后与模型的另一部分接触而产生的。有时看起来不同的模型段之间显然没有接触，但实际上是有的，因为接触动力学是如此计算的。</p><p>只支持凸形。在模型运行时按 F1，可以查看用于计算接触动力学的形状。</p><ul><li><strong>脖子和下巴之间没有空间</strong></li></ul><p>为了解决这个问题，你需要分解成多个组件STL文件，然后在XML中把它们拼接起来。例如，在上面的骨架中，你需要把它分解成头骨和脊柱STL。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Tools </tag>
            
            <tag> Mujoco </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL】深度强化学习、免模型强化学习接连被质疑，强化学习路在何方？</title>
      <link href="post/167a8eb9.html"/>
      <url>post/167a8eb9.html</url>
      
        <content type="html"><![CDATA[<p>DRL 热潮背后隐藏着诸多的“坑”，本文分析了DRL存在的危机，并指出了DRL未来可能的出路。</p><a id="more"></a><blockquote><p>注：本文转载自中国自动化学会模式识别与机器智能 (Pattern Recognition and Machine Intelligence, PRMI，以下简称为CAA-PRMI) 专业委员会通讯2018年第2期。</p></blockquote><h2 id="深度强化学习的泡沫">深度强化学习的泡沫</h2><p>2015年，DeepMind的Volodymyr Mnih等研究员在《自然》杂志上发表论文Human-level control through deep reinforcement learning[1]，该论文提出了一个结合深度学习（DL）技术和强化学习（RL）思想的模型Deep Q-Network(DQN)，在Atari游戏平台上展示出超越人类水平的表现。自此以后，结合DL与RL的深度强化学习（Deep Reinforcement Learning, DRL）迅速成为人工智能界的焦点。</p><p>过去三年间，DRL算法在不同领域大显神通：在视频游戏[1]、棋类游戏上打败人类顶尖高手[2,3]；控制复杂的机械进行操作[4]；调配网络资源[5]；为数据中心大幅节能[6]；甚至对机器学习算法自动调参[7]。各大高校和企业纷纷参与其中，提出了眼花缭乱的DRL算法和应用。可以说，过去三年是DRL的爆红期。DeepMind负责AlphaGo项目的研究员David Silver喊出“AI = RL + DL”，认为结合了DL的表示能力与RL的推理能力的DRL将会是人工智能的终极答案。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:70%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407100726.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">RL 论文数量迅速增长[8]</div></center><h3 id="drl的可复现性危机">DRL的可复现性危机</h3><p>然而，研究人员在最近半年开始了对DRL的反思。由于发表的文献中往往不提供重要参数设置和工程解决方案的细节，很多算法都难以复现。2017年9月，著名RL专家Doina Precup和Joelle Pineau所领导的的研究组发表了论文Deep Reinforcement Learning that Matters[8]，直指当前DRL领域论文数量多却水分大、实验难以复现等问题。该文在学术界和工业界引发热烈反响。很多人对此表示认同，并对DRL的实际能力产生强烈怀疑。</p><p>其实，这并非Precup&amp; Pineau研究组第一次对DRL发难。早在2个月前，该研究组就通过充足的实验对造成DRL算法难以复现的多个要素加以研究，并将研究成果撰写成文Reproducibility of Benchmarked Deep Reinforcement Learning Tasks for Continuous Control[9]。同年8月，他们在ICML 2017上作了题为“Reproducibility of Policy Gradient Methods for Continuous Control”的报告[10]，通过实例详细展示了在复现多个基于策略梯度的算法的过程中，由于种种不确定性因素导致的复现困难。12月，在万众瞩目的NIPS 2017 DRL专题研讨会上，Joelle Pineau受邀作了题为“Reproducibility of DRL and Beyond”的报告[11]。报告中，Pineau先介绍了当前科研领域的“可复现性危机” ：在《自然》杂志的一项调查中，90%的被访者认为“可复现性”问题是科研领域存在的危机，其中，52%的被访者认为这个问题很严重。在另一项调查中，不同领域的研究者几乎都有很高的比例无法复现他人甚至自己过去的实验。可见“可复现性危机”有多么严峻！Pineau针对机器学习领域发起的一项调研显示，同样有90%的研究者认识到了这个危机。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom: 80%" src=https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407101502.png> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">机器学习领域存在严重的“可复现性危机”[11]</div></center><p>随后，针对DRL领域，Pineau展示了该研究组对当前不同DRL算法的大量可复现性实验。实验结果表明，不同DRL算法在不同任务、不同超参数、不同随机种子下的效果大相径庭。在报告后半段，Pineau呼吁学界关注“可复现性危机”这一问题，并根据她的调研结果，提出了12条检验算法“可复现性”的准则，宣布计划在ICLR 2018开始举办“可复现实验挑战赛”（“可复现危机”在其他机器学习领域也受到了关注，ICML 2017已经举办了Reproducibility in Machine Learning Workshop，并将在今年继续举办第二届），旨在鼓励研究者做出真正扎实的工作，抑制机器学习领域的泡沫。Pineau &amp; Precup研究组的这一系列研究获得了广泛关注。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom: 80%" src=https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407101633.png> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Pineau基于大量调查提出的检验算法“可复现性”准则[11]</div></center><h3 id="drl研究存在多少坑">DRL研究存在多少坑？</h3><p>同样在12月，Reddit论坛上也开展了关于机器学习不正之风的热烈讨论[12]。有人点名指出，某些DRL代表性算法之所以在模拟器中取得了优秀却难以复现的表现，是因为作者们涉嫌在实验中修改模拟器的物理模型，却在论文中对此避而不谈。</p><p>对现有DRL算法的批判浪潮仍旧不断涌来。2018年的情人节当天，曾经就读于伯克利人工智能研究实验室（Berkeley Artificial Intelligence Research Lab, BAIR）的Alexirpan通过一篇博文Deep Reinforcement Learning Doesn't Work Yet[13]给DRL圈送来了一份苦涩的礼物。他在文中通过多个例子，从实验角度总结了DRL算法存在的几大问题：</p><p><strong>样本利用率非常低；</strong></p><p><strong>最终表现不够好，经常比不过基于模型的方法；</strong></p><p><strong>好的奖励函数难以设计；</strong></p><p><strong>难以平衡</strong>“<strong>探索</strong>”<strong>和</strong>“<strong>利用</strong>”<strong>,以致算法陷入局部极小；</strong></p><p><strong>对环境的过拟合；</strong></p><p><strong>灾难性的不稳定性…</strong></p><p>虽然作者在文章结尾试着提出DRL下一步应该解决的一系列问题，很多人还是把这篇文章看做DRL的“劝退文”。几天后，GIT的博士生Himanshu Sahni发表博文Reinforcement Learning never worked, and 'deep' only helped a bit与之呼应[14]，在赞同Alexirpan的观点同时，指出好的奖励函数难以设计和难以平衡“探索”和“利用”以致算法陷入局部极小是RL的固有缺陷。</p><p>另一位DRL研究者Matthew Rahtz则通过讲述自己试图复现一个DRL算法的坎坷历程来回应Alexirpan，让大家深刻体会了复现DRL算法有多么难[15]。半年前，Rahtz出于研究兴趣，选择对OpenAI的论文Deep Reinforcement Learning from Human Preferences进行复现。在复现的过程中，几乎踩了Alexirpan总结的所有的坑。他认为复现DRL算法与其是一个工程问题，更不如说像一个数学问题。“它更像是你在解决一个谜题，没有规律可循，唯一的方法是不断尝试，直到灵感出现彻底搞明白。……很多看上去无关紧要的小细节成了唯一的线索……做好每次卡住好几周的准备。”Rahtz在复现的过程中积累了很多宝贵的工程经验，但整个过程的难度还是让他花费了大量的金钱以及时间。他充分调动不同的计算资源，包括学校的机房资源、Google云计算引擎和FloydHub，总共花费高达850美元。可就算这样，原定于3个月完成的项目，最终用了8个月，其中大量时间用在调试上。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom: 80%" src=https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407101905.png> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">复现DRL算法的实际时间远多于预计时间[15]</div></center><p>Rahtz最终实现了复现论文的目标。他的博文除了给读者详细总结了一路走来的各种宝贵工程经验，更让大家从一个具体事例感受到了DRL研究实际上存在多大的泡沫、有多少的坑。有人评论到，“DRL的成功可能不是因为其真的有效，而是因为人们花了大力气。”</p><p>很多著名学者也纷纷加入讨论。目前普遍的观点是，<strong>DRL可能有AI领域最大的泡沫。</strong>机器学习专家Jacob Andreas发了一条意味深长的tweet说：</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:80%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407102055.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">Jacob Andreas对DRL的吐槽</div></center><p>DRL的成功归因于它是机器学习界中唯一一种允许在测试集上训练的方法。</p><p>从Pineau &amp; Precup打响第一枪到现在的1年多时间里，DRL被锤得千疮百孔，从万众瞩目到被普遍看衰。就在笔者准备投稿这篇文章的时候，Pineau又受邀在ICLR 2018上作了一个题为 Reproducibility, Reusability, and Robustness in DRL的报告[16]，并且正式开始举办“可复现实验挑战赛”。看来学界对DRL的吐槽将会持续，负面评论还将持续发酵。那么， DRL的问题根结在哪里？前景真的如此黯淡吗？如果不与深度学习结合，RL的出路又在哪里？</p><p>在大家纷纷吐槽DRL的时候，著名的优化专家 Ben Recht，从另一个角度给出一番分析。</p><h2 id="免模型强化学习的本质缺陷">免模型强化学习的本质缺陷</h2><p>RL算法可以分为基于模型的方法（Model-based）与免模型的方法（Model-free）。前者主要发展自最优控制领域。通常先通过高斯过程（GP）或贝叶斯网络（BN）等工具针对具体问题建立模型，然后再通过机器学习的方法或最优控制的方法，如模型预测控制（MPC）、线性二次调节器（LQR）、线性二次高斯（LQG）、迭代学习控制（ICL）等进行求解。而后者更多地发展自机器学习领域，属于数据驱动的方法。算法通过大量采样，估计代理的状态、动作的值函数或回报函数，从而优化动作策略。</p><p>从年初至今，Ben Recht连发了13篇博文，从控制与优化的视角，重点探讨了RL中的免模型方法[18]。Recht指出免模型方法自身存在以下几大缺陷：</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:80%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407102229.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">基于模型 vs. 免模型 [17]</div></center><ol type="1"><li>免模型方法无法从不带反馈信号的样本中学习，而反馈本身就是稀疏的，因此免模型方向样本利用率很低，而数据驱动的方法则需要大量采样。比如在Atari平台上的《Space Invader》和《Seaquest》游戏中，智能体所获得的分数会随训练数据增加而增加。利用免模型DRL方法可能需要 2 亿帧画面才能学到比较好的效果。AlphaGo 最早在 Nature 公布的版本也需要 3000 万个盘面进行训练。而但凡与机械控制相关的问题，训练数据远不如视频图像这样的数据容易获取，因此只能在模拟器中进行训练。而模拟器与现实世界间的Reality Gap，直接限制了训练自其中算法的泛化性能。另外，数据的稀缺性也影响了其与DL技术的结合。</li><li>免模型方法不对具体问题进行建模，而是尝试用一个通用的算法解决所有问题。而基于模型的方法则通过针对特定问题建立模型，充分利用了问题固有的信息。免模型方法在追求通用性的同时放弃这些富有价值的信息。</li><li>基于模型的方法针对问题建立动力学模型，这个模型具有解释性。而免模型方法因为没有模型，解释性不强，调试困难。</li><li>相比基于模型的方法，尤其是基于简单线性模型的方法，免模型方法不够稳定，在训练中极易发散。</li></ol><p>为了证实以上观点，Recht将一个简单的基于LQR的随机搜索方法与最好的免模型方法在MuJoCo实验环境上进行了实验对比。在采样率相近的情况下，基于模型的随机搜索算法的计算效率至少比免模型方法高15倍[19]。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407103651.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">基于模型的随机搜索方法ARS吊打一众免模型方法[19]</div></center><p>通过Recht的分析，我们似乎找到了DRL问题的根结。近三年在机器学习领域大火的DRL算法，多将免模型方法与DL结合，而免模型算法的天然缺陷，恰好与Alexirpan总结的DRL几大问题相对应（见上文）。</p><p>看来，DRL的病根多半在采用了免模型方法上。为什么多数DRL的工作都是基于免模型方法呢？笔者认为有几个原因。第一，免模型的方法相对简单直观，开源实现丰富，比较容易上手，从而吸引了更多的学者进行研究，有更大可能做出突破性的工作，如DQN和AlphaGo系列。第二，当前RL的发展还处于初级阶段，学界的研究重点还是集中在环境是确定的、静态的，状态主要是离散的、静态的、完全可观察的，反馈也是确定的问题（如Atari游戏）上。针对这种相对“简单”、基础、通用的问题，免模型方法本身很合适。最后，在“AI = RL + DL”这一观点的鼓动下，学界高估了DRL的能力。DQN展示出的令人兴奋的能力使得很多人围绕着DQN进行拓展，创造出了一系列同样属于免模型的工作。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:90%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407103841.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">绝大多数DRL方法是对DQN的扩展，属于免模型方法[20]</div></center><p>那么，DRL是不是应该抛弃免模型方法，拥抱基于模型的方法呢？</p><h2 id="基于模型或免模型问题没那么简单">基于模型或免模型，问题没那么简单</h2><h3 id="基于模型的方法未来潜力巨大">基于模型的方法，未来潜力巨大</h3><p>基于模型的方法一般先从数据中学习模型，然后基于学到的模型对策略进行优化。学习模型的过程和控制论中的系统参数辨识类似。因为模型的存在，基于模型的方法可以充分利用每一个样本来逼近模型，数据利用率极大提高。基于模型的方法则在一些控制问题中，相比于免模型方法，通常有10^2级的采样率提升。此外，学到的模型往往对环境的变化鲁棒,当遇到新环境时，算法可以依靠已学到的模型做推理，具有很好的泛化性能。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407103958.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">基于模型的方法具有更高采样率[22]</div></center><p>此外，基于模型的方法还与潜力巨大的预测学习（Predictive Learning）紧密相关。由于建立了模型，本身就可以通过模型预测未来，这与Predictive Learning的需求不谋而合。其实，Yann LeCun在广受关注的NIPS 2016主题报告上介绍Predictive Learning时，也是以基于模型的方法作为例子的[21]。笔者认为，基于模型的RL方法可能是实现Predictive Learning的重要技术之一。</p><p>这样看来，基于模型的方法似乎更有前途。但天下没有免费的午餐，模型的存在也带来了若干问题。</p><h3 id="免模型方法依旧是第一选择">免模型方法，依旧是第一选择</h3><p>基于模型的DRL方法相对而言不那么简单直观，RL与DL的结合方式相对更复杂，设计难度更高。目前基于模型的DRL方法通常用高斯过程、贝叶斯网络或概率神经网络（PNN）来构建模型，典型的如David Silver在2016年提出的Predictron模型[23]。另外一些工作，如Probabilistic Inference for Learning COntrol (PILCO)[24]，本身不基于神经网络，不过有与BN结合的扩展版本。而Guided Policy Search (GPS) 虽然在最优控制器的优化中使用了神经网络，但模型并不依赖神经网络[25]。此外还有一些模型将神经网络与模型耦合在一起[26]。这些工作不像免模型DRL方法那样直观且自然，DL所起的作用也各有不同。</p><p>除此之外，基于模型的方法也还存在若干自身缺陷：</p><ol type="1"><li>针对无法建模的问题束手无策。有些领域，比如NLP，存在大量难以归纳成模型的任务。在这种场景下，只能通过诸如R-max算法这样的方法先与环境交互，计算出一个模型为后续使用。但是这种方法的复杂度一般很高。近期有一些工作结合预测学习建立模型，部分地解决了建模难的问题，这一思路逐渐成为了研究热点。</li><li>建模会带来误差，而且误差往往随着算法与环境的迭代交互越来越大，使得算法难以保证收敛到最优解。</li><li>模型缺乏通用性，每次换一个问题，就要重新建模。</li></ol><p>针对以上几点，免模型方法都有相对优势：对现实中非常多的无法建模的问题以及模仿学习问题，免模型算法仍是最好的选择。并且，免模型方法在理论上具备渐近收敛性，经过无数次与环境的交互可以保证得到最优解，这是基于模型的方法很难获得的结果。最后，免模型最大的优势就是具备非常好的通用性。事实上，在处理真正困难的问题时，免模型方法的效果通常更好。Recht也在博文中指出，控制领域很有效的MPC算法其实与Q-Learning这样的免模型方法非常相关[18]。</p><p>基于模型的方法与免模型的方法的区别其实也可以看做基于知识的方法与基于统计的方法的区别。总体来讲，两种方法各有千秋，很难说其中一种方法优于另一种。在RL领域中，免模型算法只占很少一部分，但基于历史原因，当前免模型的DRL方法发展迅速数量庞大，而基于模型的DRL方法则相对较少。笔者认为，我们可以考虑多做一些基于模型的DRL方面的工作，克服当前DRL存在的诸多问题。此外，还可以多研究结合基于模型方法与免模型方法的半模型方法，兼具两种方法的优势。这方面经典的工作有RL泰斗Rich Sutton提出的Dyna框架 [27] 和其弟子David Silver提出的Dyna-2框架[28]。</p><p>通过以上讨论，我们似乎对DRL目前的困境找到了出路。但其实，造成当前DRL困境的原因远不止这些。</p><h3 id="不仅仅是模型与否的问题">不仅仅是模型与否的问题</h3><p>上文提到Recht使用基于随机搜索的方法吊打了免模型方法，似乎宣判了免模型方法的死刑。但其实这个对比并不公平。</p><p>2017年3月，机器学习专家Sham Kakade的研究组发表文章Towards Generalization and Simplicity in Continuous Control，试图探寻针对连续控制问题的简单通用的解法 [29] 。他们发现当前的模拟器存在非常大的问题，经过调试的线性策略就已经可以取得非常好的效果——这样的模拟器实在过于粗糙，难怪基于随机搜索的方法可以在同样的模拟器上战胜免模型方法！</p><p>可见目前RL领域的实验平台还非常不成熟，在这样的测试环境中的实验实验结果没有足够的说服力。很多研究结论都未必可信，因为好性能的取得或许仅仅是因为利用了模拟器的bugs。此外，一些学者指出当前RL算法的性能评判准则也不科学。Ben Recht和Sham Kakade都对RL的发展提出了多项具体建议，包括测试环境、基准算法、衡量标准等[18,29]。可见RL领域还有太多需要改进和规范化。</p><p>那么，RL接下来该如何突破呢？</p><h2 id="重新审视强化学习">重新审视强化学习</h2><p>对DRL和免模型RL的质疑与讨论，让我们可以重新审视RL，这对RL今后的发展大有裨益。</p><h3 id="重新审视drl的研究与应用">重新审视DRL的研究与应用</h3><p>DQN和AlphaGo系列工作给人留下深刻印象，但是这两种任务本质上其实相对“简单”。因为这些任务的环境是确定的、静态的，状态主要是离散的、静态的、完全可观察的，反馈是确定的，代理也是单一的。目前DRL在解决部分可见状态任务（如StarCraft），状态连续的任务（如机械控制任务），动态反馈任务和多代理任务中还没取得令人惊叹的突破。</p><p>当前大量的DRL研究，尤其是应用于计算机视觉领域任务的研究中，很多都是将计算机视觉的某一个基于DL的任务强行构造成RL问题进行求解，其结果往往不如传统方法好。这样的研究方式造成DRL领域论文数量暴增、水分巨大。作为DRL的研究者，<strong>我们不应该找一个DL任务强行将其RL化，而是应该针对一些天然适合RL处理的任务，尝试通过引入DL来提升现有方法在目标识别环节或函数逼近环节上的能力</strong>。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407104452.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">DRL取得成功的任务本质上相对简单[30]</div></center><p>在计算机视觉任务中，通过结合DL获得良好的特征表达或函数逼近是非常自然的思路。但在有些领域，DL未必能发挥强大的特征提取作用，也未必被用于函数逼近。比如DL至今在机器人领域最多起到感知作用，而无法取代基于力学分析的方法。虽然有一些将DRL应用于物体抓取等现实世界的机械控制任务上并取得成功的案例，如QT-Opt[70]，但往往需要大量的调试和训练时间。我们应该清晰地认识<strong>DRL算法的应用特点：因为其输出的随机性</strong>，当前的DRL算法更多地被用在模拟器而非真实环境中。而当前具有实用价值且只需运行于模拟器中的任务主要有三类，即视频游戏、棋类游戏和自动机器学习（AutoML，比如谷歌的AutoML Vision）。这并不是说DRL的应用被困在模拟器中——如果能针对某一具体问题，解决模拟器与真实世界间的差异，则可以发挥DRL的强大威力。最近Google的研究员就针对四足机器人运动问题，通过大力改进模拟器，使得在模拟器中训练的运动策略可以完美迁移到真实世界中，取得了令人惊艳的效果[71]。不过，考虑到RL算法的不稳定性，在实际应用中<strong>不应盲目追求端到端的解决方案，而可以考虑将特征提取（DL）与决策（RL）分开</strong>，从而获得更好的解释性与稳定性。此外，<strong>模块化RL</strong>（将RL算法封装成一个模块）以及将RL与其他模型融合，将在实际应用中有广阔前景。而<strong>如何通过DL学习一个合适于作为RL模块输入的表示</strong>，也值得研究。</p><h4 id="重新审视rl的研究">重新审视RL的研究</h4><p>机器学习是个跨学科的研究领域，而RL则是其中跨学科性质非常显著的一个分支。RL理论的发展受到生理学、神经科学和最优控制等领域的启发，现在依旧在很多相关领域被研究。在控制理论、机器人学、运筹学、经济学等领域内部，依旧有很多的学者投身RL的研究，类似的概念或算法往往在不同的领域被重新发明，起了不同的名字。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407105110.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">RL的发展受到多个学科的影响[31]</div></center><p>Princeton大学著名的运筹学专家Warren Powell曾经写了一篇题为AI, OR and Control Theory: A Rosetta Stone for Stochastic Optimization的文章，整理了RL中同一个概念、算法在AI、OR（运筹学）和Control Theory（控制理论）中各自对应的名称，打通了不同领域间的隔阂 [32] 。由于各种学科各自的特点，不同领域的RL研究又独具特色，这使得RL的研究可以充分借鉴不同领域的思想精华。</p><p>在这里，笔者根据自身对RL的理解，试着总结一些值得研究的方向：</p><ol type="1"><li><strong>基于模型的方法</strong>。如上文所述，基于模型的方法不仅能大幅降低采样需求，还可以通过学习任务的动力学模型，为预测学习打下基础。</li><li><strong>提高免模型方法的数据利用率和扩展性</strong>。这是免模型学习的两处硬伤，也是Rich Sutton的终极研究目标。这个领域很艰难，但是任何有意义的突破也将带来极大价值。</li><li><strong>更高效的探索策略</strong>（Exploration Strategies）。平衡“探索”与“利用”是RL的本质问题，这需要我们设计更加高效的探索策略。除了若干经典的算法如Softmax、ϵ-Greedy[1]、UCB[72]和Thompson Sampling[73]等，近期学界陆续提出了大批新算法，如Intrinsic Motivation [74]、Curiosity-driven Exploration[75]、Count-based Exploration [76]等。其实这些“新”算法的思想不少早在80年代就已出现[77]，而与DL的有机结合使它们重新得到重视。此外，OpenAI与DeepMind先后提出通过在策略参数[78]和神经网络权重[79]上引入噪声来提升探索策略, 开辟了一个新方向。</li><li><strong>与模仿学习（Imitation Learning, IL）结合</strong>。机器学习与自动驾驶领域最早的成功案例ALVINN[33]就是基于IL；当前RL领域最顶级的学者Pieter Abbeel在跟随Andrew Ng读博士时候,设计的通过IL控制直升机的算法[34]成为IL领域的代表性工作。2016年，英伟达提出的端到端自动驾驶系统也是通过IL进行学习[68]。而AlphaGo的学习方式也是IL。IL介于RL与监督学习之间，兼具两者的优势，既能更快地得到反馈、更快地收敛，又有推理能力，很有研究价值。关于IL的介绍，可以参见[35]这篇综述。</li><li><strong>奖赏塑形</strong>（Reward Shaping）。奖赏即反馈，其对RL算法性能的影响是巨大的。Alexirpan的博文中已经展示了没有精心设计的反馈信号会让RL算法产生多么差的结果。设计好的反馈信号一直是RL领域的研究热点。近年来涌现出很多基于“好奇心”的RL算法和层级RL算法，这两类算法的思路都是在模型训练的过程中插入反馈信号，从而部分地克服了反馈过于稀疏的问题。另一种思路是学习反馈函数，这是逆强化学习（Inverse RL, IRL）的主要方式之一。近些年大火的GAN也是基于这个思路来解决生成建模问题, GAN的提出者Ian Goodfellow也认为GAN就是RL的一种方式 [36]。而将GAN于传统IRL结合的GAIL[37]已经吸引了很多学者的注意。</li><li><strong>RL中的迁移学习与多任务学习</strong>。当前RL的采样效率极低，而且学到的知识不通用。迁移学习与多任务学习可以有效解决这些问题。通过将从原任务中学习的策略迁移至新任务中，避免了针对新任务从头开始学习，这样可以大大降低数据需求，同时也提升了算法的自适应能力。在真实环境中使用RL的一大困难在于RL的不稳定性，一个自然的思路是通过迁移学习将在模拟器中训练好的稳定策略迁移到真实环境中，策略在新环境中仅通过少量探索即可满足要求。然而，这一研究领域面临的一大问题就是现实鸿沟（Reality Gap），即模拟器的仿真环境与真实环境差异过大。好的模拟器不仅可以有效填补现实鸿沟，还同时满足RL算法大量采样的需求，因此可以极大促进RL的研究与开发，如上文提到的Sim-to-Real[71]。同时，这也是RL与VR技术的一个结合点。近期学术界和工业界纷纷在这一领域发力。在自动驾驶领域，Gazebo、EuroTruck Simulator、TORCS、Unity、Apollo、Prescan、Panosim和Carsim等模拟器各具特色，而英特尔研究院开发的CARLA模拟器[38]逐渐成为业界研究的标准。其他领域的模拟器开发也呈现百花齐放之势：在家庭环境模拟领域， MIT 和多伦多大学合力开发了功能丰富的VirturalHome模拟器；在无人机模拟训练领域，MIT也开发了Flight Goggles模拟器。</li><li><strong>提升RL的的泛化能力</strong>。机器学习最重要的目标就是泛化能力, 而现有的RL方法大多在这一指标上表现糟糕[8]，无怪乎Jacob Andreas会批评RL的成功是来自“train on the test set”。这一问题已经引起了学界的广泛重视，研究者们试图通过学习环境的动力学模型[80]、降低模型复杂度[29]或模型无关学习[81]来提升泛化能力，这也促进了基于模型的方法与元学习（Meta-Learning）方法的发展。BAIR提出的著名的Dex-Net项目主要目标就是构建具有良好鲁棒性、泛化能力的机器人抓取模型[82]，而OpenAI也于2018年4月组织了OpenAI Retro Contest ，鼓励参与者开发具有良好泛化能力的RL算法[83]。</li><li><strong>层级RL</strong>（Hierarchical RL, HRL）。周志华教授总结DL成功的三个条件为：有逐层处理、有特征的内部变化和有足够的模型复杂度[39]。而HRL不仅满足这三个条件，而且具备更强的推理能力，是一个非常潜力的研究领域。目前HRL已经在一些需要复杂推理的任务（如Atari平台上的《Montezuma's Revenge》游戏）中展示了强大的学习能力[40]。</li><li><strong>与序列预测</strong>（Sequence Prediction）结合。Sequence Prediction与RL、IL解决的问题相似又不相同。三者间有很多思想可以互相借鉴。当前已有一些基于RL和IL的方法在 Sequence Prediction任务上取得了很好的结果 [41,42,43]。这一方向的突破对Video Prediction和NLP中的很多任务都会产生广泛影响。</li><li>（<strong>免模型）方法探索行为的安全性</strong>（Safe RL）。相比于基于模型的方法，免模型方法缺乏预测能力，这使得其探索行为带有更多不稳定性。一种研究思路是结合贝叶斯方法为RL代理行为的不确定性建模，从而避免过于危险的探索行为。此外，为了安全地将RL应用于现实环境中，可以在模拟器中借助混合现实技术划定危险区域，通过限制代理的活动空间约束代理的行为。</li><li><strong>关系RL</strong>。近期学习客体间关系从而进行推理与预测的“关系学习”受到了学界的广泛关注。关系学习往往在训练中构建的状态链，而中间状态与最终的反馈是脱节的。RL可以将最终的反馈回传给中间状态，实现有效学习，因而成为实现关系学习的最佳方式。2017年DeepMind提出的VIN[44]和Pridictron[23]均是这方面的代表作。2018年6月，DeepMind又接连发表了多篇关系学习方向的工作如关系归纳偏置[45]、关系RL[46]、关系RNN[47]、图网络[48]和已经在《科学》杂志发表的生成查询网络（Generative Query Network，GQN）[49]。这一系列引人注目的工作将引领关系RL的热潮。</li><li><strong>对抗样本RL</strong>。RL被广泛应用于机械控制等领域，这些领域相比于图像识别语音识别等等，对鲁棒性和安全性的要求更高。因此针对RL的对抗攻击是一个非常重要的问题。近期有研究表明，会被对抗样本操控，很多经典模型如DQN等算法都经不住对抗攻击的扰动[50,51]。</li><li><strong>处理其他模态的输入</strong>。在NLP领域，学界已经将RL应用于处理很多模态的数据上，如句子、篇章、知识库等等。但是在计算机视觉领域，RL算法主要还是通过神经网络提取图像和视频的特征，对其他模态的数据很少涉及。我们可以探索将RL应用于其他模态的数据的方法，比如处理RGB-D数据和激光雷达数据等。一旦某一种数据的特征提取难度大大降低，将其与RL有机结合后都可能取得AlphaGo级别的突破。英特尔研究院已经基于CARLA模拟器在这方面开展了一系列的工作。</li></ol><h4 id="重新审视rl的应用">重新审视RL的应用</h4><p>当前的一种观点是“RL只能打游戏、下棋，其他的都做了”。而笔者认为，我们不应对RL过于悲观。其实能在视频游戏与棋类游戏中超越人类，已经证明了RL推理能力的强大。通过合理改进后，有希望得到广泛应用。往往，从研究到应用的转化并不直观。比如，IBM Watson® 系统以其对自然语言的理解能力和应答能力闻名世界，曾在2011年击败人类选手获得Jeopardy!冠军。而其背后的支撑技术之一竟然是当年Gerald Tesauro开发TD-Gammon程序[52]时使用的RL技术[53]。当年那个“只能用于”下棋的技术，已经在最好的问答系统中发挥不可或缺的作用了。今天的RL发展水平远高于当年，我们怎么能没有信心呢？</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407111329.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">强大的IBM Watson®背后也有RL发挥核心作用</div></center><p>通过调查，我们可以发现RL算法已经在各个领域被广泛使用：</p><ol type="1"><li>控制领域。这是RL思想的发源地之一，也是RL技术应用最成熟的领域。控制领域和机器学习领域各自发展了相似的思想、概念与技术，可以互相借鉴。比如当前被广泛应用的MPC算法与Model-based RL中的planning部分紧密相关。在机器人领域，相比于DL只能用于感知，RL相比传统的法有自己的优势：传统方法如LQR等一般要对具体问题建立动力学模型，从而进行求解，复杂度较高，不适合用于做重规划；而RL方法学习到的则是状态-动作空间中的策略，具有更好的适应性。</li><li>自动驾驶领域。驾驶就是一个序列决策过程，因此天然适合用RL来处理。从80年代的ALVINN、TORCS到如今的CARLA，业界一直在尝试用RL解决单车辆的自动驾驶问题以及多车辆的交通调度问题。类似的思想也广泛地应用在各种飞行器、水下无人机领域。</li><li>NLP领域。相比于计算机视觉领域的任务，NLP领域的很多任务是多轮的，即需通过多次迭代交互来寻求最优解（如对话系统）；而且任务的反馈信号往往需要在一系列决策后才能获得（如机器写作）。这样的问题的特性自然适合用RL来解决，因而近年来RL被应用于NLP领域中的诸多任务中，如文本生成、文本摘要、序列标注、对话机器人（文字/语音）、机器翻译、关系抽取和知识图谱推理等等。成功的应用案例也有很多，如对话机器人领域中Yoshua Bengio 研究组开发的 MILABOT 的模型[54]、Facebook聊天机器人[55]等；机器翻译领域Microsoft Translator [56]等。此外，在一系列跨越NLP与计算机视觉两种模态的任务如VQA、Image/Video Caption、Image Grounding、Video Summarization等中，RL技术也都大显身手。</li><li>推荐系统与检索系统领域。RL中的Bandits系列算法早已被广泛应用于商品推荐、新闻推荐和在线广告等领域。近年也有一系列的工作将RL应用于信息检索、排序的任务中[57]。</li><li>金融领域。RL强大的序列决策能力已经被金融系统所关注。无论是华尔街巨头摩根大通还是创业公司如Kensho，都在其交易系统中引入了RL技术。</li><li>对数据的选择。在数据足够多的情况下，如何选择数据来实现“快、好、省”地学习，具有非常大的应用价值。近期在这方面也涌现出一系列的工作，如UCSB的Jiawei Wu提出的Reinforced Co-Training [58]等。</li><li>通讯、生产调度、规划和资源访问控制等运筹领域。这些领域的任务往往涉及“选择”动作的过程，而且带标签数据难以取得，因此广泛使用RL进行求解。</li></ol><p>关于RL的更全面的应用综述请参见文献 [59，60]。</p><p>虽然有上文列举的诸多成功应用，但我们依旧要认识到，当前RL的发展还处于初级阶段，不能包打天下。目前还没有一个通用的RL解决方案像DL一样成熟到成为一种即插即用的算法。不同RL算法在各自领域各领风骚。在找到一个普适的方法之前，我们更应该针对特定问题设计专门的算法，比如在机器人领域，基于贝叶斯RL和演化算法的方法（如CMAES[61]）比DRL更合适。当然，不同的领域间应当互相借鉴与促进。RL算法的输出存在随机性，这是其“探索”哲学带来的本质问题，因此我们不能盲目 All in RL, 也不应该RL in All, 而是要找准RL适合解决的问题。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:80%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407110349.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">针对不同问题应该使用的不同RL方法[22]</div></center><h3 id="重新审视rl的价值">重新审视RL的价值</h3><p>在NIPS 2016上，Yan LeCun认为最有价值的问题是“Predictive Learning”问题，这其实类似于非监督学习问题。他的发言代表了学界近来的主流看法。而Ben Recht则认为，RL比监督学习（Supervised Learning, SL）和非监督学习（Unsupervised Learning, UL）更有价值。他把这三类学习方式分别与商业分析中的描述分析（UL）、预测分析（SL）和指导分析（RL）相对应[18]。</p><p>描述分析是对已有的数据进行总结，从而获得更鲁棒和清晰的表示，这个问题最容易，但价值也最低。因为描述分析的价值更多地在于美学方面而非实际方面。比如，“用GAN将一个房间的图片渲染成何种风格”远没有“依据房间的图片预测该房间的价格”更重要。而后者则是预测分析问题——基于历史数据对当前数据进行预测。但是在描述分析和预测分析中，系统都是不受算法影响的，而指导分析则更进一步地对算法与系统间的交互进行建模，通过主动影响系统，最大化价值收益。类比以上两个例子，指导分析则是解决“如何通过对房间进行一系列改造来最大化提升房间价格”之类的问题。这种问题最难，因为涉及到了算法与系统的复杂交互，但也最有价值，因为指导性分析（RL）的天然目标就是价值最大化，也是人类解决问题的方式。并且，无论是描述分析还是预测分析，所处理的问题的环境都是静态的、不变的，这个假设对大多数实际的问题都不成立。而指导分析则被用来处理环境动态变化的问题，甚至还要考虑到与其他对手的合作或竞争，与人类面临的大多数实际问题更相似。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407110542.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">指导分析问题最难，也最有价值[18]</div></center><p>在最后一节，笔者将试图在更广的范围内讨论类似于RL的从反馈中学习的方法，从而试图给读者介绍一种看待RL的新视角。</p><h2 id="广义的rl从反馈学习">广义的RL——从反馈学习</h2><p>本节使用“广义的RL”一词指代针对“从反馈学习”的横跨多个学科的研究。与上文中介绍的来自机器学习、控制论、经济学等领域的RL不同，本节涉及的学科更宽泛，一切涉及从反馈学习的系统，都暂且称为广义的RL。</p><h3 id="广义的rl是人工智能研究的最终目标">广义的RL，是人工智能研究的最终目标</h3><p>1950年，图灵在其划时代论文Computing Machinery and Intelligence[62]中提出了著名的“图灵测试”概念：如果一个人（代号C）使用测试对象皆理解的语言去询问两个他不能看见的对象任意一串问题。对象为：一个是正常<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%80%9D%E7%BB%B4">思维</a>的人（代号B）、一个是机器（代号A）。如果经过若干询问以后，C不能得出实质的区别来分辨A与B的不同，则此机器A通过图灵测试。</p><p>请注意，“图灵测试”的概念已经蕴含了“反馈”的概念——人类借由程序的反馈来进行判断，而人工智能程序则通过学习反馈来欺骗人类。同样在这篇论文中，图灵还说到“除了试图直接去建立一个可以模拟成人大脑的程序之外，为什么不试图建立一个可以模拟小孩大脑的程序呢？如果它接受适当的教育，就会获得成人的大脑。”——从反馈中逐渐提升能力，这不正是RL的学习方式么？可以看出，<strong>人工智能的概念从被提出时其最终目标就是构建一个足够好的从反馈学习的系统</strong>。</p><p>1959年，人工智能先驱Arthur Samuel正式定义了“机器学习”这概念。也正是这位Samuel，在50年代开发了基于RL的的象棋程序，成为人工智能领域最早的成功案例[63]。为何人工智能先驱们的工作往往集中在RL相关的任务呢？经典巨著《人工智能：一种现代方法》里对RL的评论或许可以回答这一问题：可以认为RL囊括了人工智能的所有要素：一个智能体被置于一个环境中，并且必须学会在其间游刃有余（Reinforcement Learning might be considered to encompass all of AI: an agent is placed in an environment and must learn to behave successfully therein.） [64]。</p><p>不仅仅在人工智能领域，哲学领域也强调了行为与反馈对智能形成的意义。生成论（Enactivism）认为行为是认知的基础，行为与感知是互相促进的，智能体通过感知获得行为的反馈，而行为则带给智能体对环境的真实有意义的经验[65]。</p><center><img style="border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); zoom:100%" src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210407111205.png"/> <br><div style="color:orange; border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 2px;">行为和反馈是智能形成的基石[65]</div></center><p>看来，从反馈学习确实是实现智能的核心要素。</p><p>回到人工智能领域。DL取得成功后，与RL结合成为DRL。知识库相关的研究取得成功后，RL算法中也逐渐加入了Memory机制。而变分推理也已经找到了与RL的结合点。近期学界开始了反思DL的热潮，重新燃起对因果推理与符号学习的兴趣，于是也出现了关系RL和符号RL[66]相关的工作。通过回顾学术的发展，我们也可以总结出人工智能发展的一个特点：每当一个相关方向取得突破，总是会回归到RL问题, 寻求与RL相结合。与其把DRL看作DL的拓展，不如看作RL的一次回归。因此我们不必特别担心DRL的泡沫，因为RL本就是人工智能的最终目标，有着旺盛的生命力，未来还会迎来一波又一波的发展。</p><h3 id="广义的rl是未来一切机器学习系统的形式">广义的RL，是未来一切机器学习系统的形式</h3><p>Recht在他的最后一篇博文中[67]中强调，只要一个机器学习系统会通过接收外部的反馈进行改进，这个系统就不仅仅是一个机器学习系统，而且是一个RL系统。当前在互联网领域广为使用的A/B测试就是RL的一种最简单的形式。而未来的机器学习系统，都要处理分布动态变化的数据并从反馈中学习。因此可以说，我们即将处于一个“一切机器学习都是RL”的时代，学界和工业界都亟需加大对RL的研究力度。Recht从社会与道德层面对这一问题进行了详细探讨[67]，并将他从控制与优化角度对RL的一系列思考总结成一篇综述文章供读者思考[69]。</p><h3 id="广义的rl是很多领域研究的共同目标">广义的RL，是很多领域研究的共同目标</h3><p>4.2节已经提到RL在机器学习相关的领域被分别发明与研究，其实这种从反馈中学习的思想，在很多其他领域也被不断地研究。仅举几例如下：</p><p>在心理学领域，经典条件反射与操作性条件反射的对比，就如同SL和RL的对比；而著名心理学家Albert Bandura 提出的“观察学习”理论则与IL非常相似；精神分析大师Melanie Klein 提出的“投射性认同”其实也可以看做一个RL的过程。在心理学诸多领域中，与RL关联最近的则是行为主义学派（Behaviorism）。其代表人物John Broadus Watson将行为主义心理学应用于广告业，极大推动了广告业的发展。这很难不让人联想到，RL算法的一大成熟应用就是互联网广告。而行为主义受到认知科学影响而发展出的认知行为疗法则与RL中的策略迁移方法有异曲同工之妙。行为主义与RL的渊源颇深，甚至可以说是RL思想的另一个源头。本文限于篇幅无法详述，请感兴趣的读者参阅心理学方面的文献如[53]。</p><p>在教育学领域，一直有关于“主动学习”与“被动学习”两种方式的对比与研究，代表性研究有Cone of Experience，其结论与机器学习领域关于RL与SL的对比非常相似。而教育学家杜威提倡的“探究式学习”就是指主动探索寻求反馈的学习方法；</p><p>在组织行为学领域，学者们探究“主动性人格”与“被动性人格”的不同以及对组织的影响；</p><p>在企业管理学领域，企业的“探索式行为”和“利用式行为”一直是一个研究热点；</p><p>……</p><p>可以说，一切涉及通过选择然后得到反馈，然后从反馈中学习的领域，几乎都有RL的思想以各种形式存在，因此笔者称之为广义的RL。这些学科为RL的发展提供了丰富的研究素材，积累了大量的思想与方法。同时，RL的发展不会仅仅对人工智能领域产生影响，也会推动广义的RL所包含的诸多学科共同前进。</p><h2 id="结语">结语</h2><p>虽然RL领域目前还存在诸多待解决的问题，在DRL这一方向上也出现不少泡沫，但我们应该看到RL领域本身在研究和应用领域取得的长足进步。这一领域值得持续投入研究，但在应用时需保持理性。而对基于反馈的学习的研究，不仅有望实现人工智能的最终目标，也对机器学习领域和诸多其他领域的发展颇有意义。这确实是通向人工智能的最佳路径。这条路上布满荆棘，但曙光已现。</p><h2 id="致谢">致谢</h2><p>在本文的写作过程中，得到了英特尔研究院郭怡文研究员、刘忠轩研究员和史雪松研究员的积极反馈。剑桥大学的Shane Gu博士、清华大学交叉信息学院的张崇洁教授和北京大学信息科学学院智能科学系的林宙辰教授分别在基于模型的方法、RL泛化性能和RL模型优化方法方面提供了很多非常有价值的指导意见。此外特别感谢强化学习研究者Flood Sung，为笔者介绍了RL领域多个最前沿的研究应用，并提供了这一研究交流平台。</p><h2 id="作者简介">作者简介:</h2><p><strong>侯宇清</strong></p><p>博士，现为英特尔中国研究院认知计算实验室和清华大学计算机科学与技术系智能技术与系统国家重点实验室联合培养博士后研究员，研究兴趣为强化学习的理论以及应用，研究方向为基于深度强化学习的视觉信息处理以及元学习。2016年毕业于北京大学，研究方向为多模态学习。发表学术论文7篇，拥有5项美国/国际专利及申请。</p><p><strong>陈玉荣</strong></p><p>博士，现任英特尔首席研究员、英特尔中国研究院认知计算实验室主任。负责领导视觉认知和机器学习研究工作，推动基于英特尔平台的智能视觉数据处理技术创新。发表学术论文50余篇，拥有50余项美国/国际专利及申请。</p><p><strong>参考文献</strong></p><p>[1] Mnih, Volodymyr, et al. "Human-level control through deep reinforcement learning." Nature 518.7540 (2015): 529.</p><p>[2] Silver, David, et al. "Mastering the game of Go with deep neural networks and tree search." Nature 529.7587 (2016): 484-489.</p><p>[3] Silver, David, et al. "Mastering the game of go without human knowledge." Nature 550.7676 (2017): 354.</p><p>[4] Levine, Sergey, et al. "End-to-end training of deep visuomotor policies." arXiv preprint arXiv:1504.00702, 2015.</p><p>[5] Mao, Hongzi, et al. "Resource management with deep reinforcement learning." Proceedings of the 15th ACM Workshop on Hot Topics in Networks. ACM, 2016.</p><p>[6] <a href="https://link.zhihu.com/?target=https%3A//deepmind.com/blog/deepmind-ai-reduces-google-data-centre-cooling-bill-40/">https://deepmind.com/blog/deepmind-ai-reduces-google-data-centre-cooling-bill-40/</a></p><p>[7] Jaques, Natasha, et al. "Tuning recurrent neural networks with reinforcement learning." (2017).</p><p>[8] Henderson, Peter, et al. "Deep reinforcement learning that matters." arXiv preprint arXiv:1709.06560 (2017).</p><p>[9] Islam, Riashat, et al. "Reproducibility of benchmarked deep reinforcement learning tasks for continuous control." arXiv preprint arXiv:1708.04133 (2017).</p><p>[10] <a href="https://link.zhihu.com/?target=https%3A//riashatislam.files.wordpress.com/2017/08/icml_rl_workshop_talk.pdf">https://riashatislam.files.wordpress.com/2017/08/icml_rl_workshop_talk.pdf</a></p><p>[11] <a href="https://link.zhihu.com/?target=https%3A//sites.google.com/view/deeprl-symposium-nips2017/">https://sites.google.com/view/deeprl-symposium-nips2017/</a></p><p>[12][https://www.reddit.com/r/MachineLearning/comments/7lq58j/d_what_ml_publication_hacks_are_you_familiar_with/](https://link.zhihu.com/?target=https%3A//www.reddit.com/r/MachineLearning/comments/7lq58j/d_what_ml_publication_hacks_are_you_familiar_with/)</p><p>[13] <a href="https://link.zhihu.com/?target=https%3A//www.alexirpan.com/2018/02/14/rl-hard.html">https://www.alexirpan.com/2018/02/14/rl-hard.html</a></p><p>[14] <a href="https://link.zhihu.com/?target=https%3A//himanshusahni.github.io/2018/02/23/reinforcement-learning-never-worked.html">https://himanshusahni.github.io/2018/02/23/reinforcement-learning-never-worked.html</a></p><p>[15] <a href="https://link.zhihu.com/?target=http%3A//amid.fish/reproducing-deep-rl">http://amid.fish/reproducing-deep-rl</a></p><p>[16] <a href="https://link.zhihu.com/?target=http%3A//rodeo.ai/2018/05/06/reproducibility-reusability-and-robustness-in-deep-reinforcement-learning/">http://rodeo.ai/2018/05/06/reproducibility-reusability-and-robustness-in-deep-reinforcement-learning/</a></p><p>[17] Dayan, Peter, and Yael Niv. "Reinforcement learning: the good, the bad and the ugly." Current opinion in neurobiology 18.2 (2008): 185-196.</p><p>[18] <a href="https://link.zhihu.com/?target=http%3A//www.argmin.net/2018/05/11/outsider-rl/">http://www.argmin.net/2018/05/11/outsider-rl/</a></p><p>[19] Mania, Horia, Aurelia Guy, and Benjamin Recht. "Simple random search provides a competitive approach to reinforcement learning." arXiv preprint arXiv:1803.07055 (2018).</p><p>[20] Justesen, Niels, et al. "Deep Learning for Video Game Playing." arXiv preprint arXiv:1708.07902 (2017).</p><p>[21] <a href="https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DOunt2Y4qxQo">https://www.youtube.com/watch?v=Ount2Y4qxQo</a></p><p>[22] <a href="https://link.zhihu.com/?target=https%3A//sites.google.com/view/icml17deeprl">https://sites.google.com/view/icml17deeprl</a></p><p>[23] Silver, David, et al. "The predictron: End-to-end learning and planning." arXiv preprint arXiv:1612.08810 (2016).</p><p>[24] Deisenroth, Marc, and Carl E. Rasmussen. "PILCO: A model-based and data-efficient approach to policy search." Proceedings of the 28th International Conference on machine learning (ICML-11). 2011.</p><p>[25] Levine, Sergey, and Vladlen Koltun. "Guided policy search." International Conference on Machine Learning. 2013.</p><p>[26] Weber, Théophane, et al. "Imagination-augmented agents for deep reinforcement learning." arXiv preprint arXiv:1707.06203 (2017).</p><p>[27] Sutton, Richard S. "Dyna, an integrated architecture for learning, planning, and reacting." ACM SIGART Bulletin 2.4 (1991): 160-163.</p><p>[28] Silver, David, Richard S. Sutton, and Martin Müller. "Sample-based learning and search with permanent and transient memories." Proceedings of the 25th international conference on Machine learning. ACM, 2008.</p><p>[29] Rajeswaran, Aravind, et al. "Towards generalization and simplicity in continuous control." Advances in Neural Information Processing Systems. 2017.</p><p>[30] <a href="https://link.zhihu.com/?target=http%3A//www.andreykurenkov.com/writing/is-alphago-zero-overrated/">http://www.andreykurenkov.com/writing/is-alphago-zero-overrated/</a></p><p>[31] UCL Course on RL: <a href="https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html">http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html</a></p><p>[32] Powell, Warren B. "AI, OR and control theory: A rosetta stone for stochastic optimization." Princeton University (2012).</p><p>[33] Pomerleau, Dean A. "Alvinn: An autonomous land vehicle in a neural network." Advances in neural information processing systems. 1989.</p><p>[34] Abbeel, Pieter, and Andrew Y. Ng. "Apprenticeship learning via inverse reinforcement learning." Proceedings of the twenty-first international conference on Machine learning. ACM, 2004.</p><p>[35] Osa, Takayuki, et al. "An algorithmic perspective on imitation learning." Foundations and Trends® in Robotics 7.1-2 (2018): 1-179.</p><p>[36] <a href="https://link.zhihu.com/?target=https%3A//fermatslibrary.com/arxiv_comments">https://fermatslibrary.com/arxiv_comments</a> url=https%3A%2F%2Farxiv.org%2Fpdf%2F1406.2661.pdf</p><p>[37] Ho, Jonathan, and Stefano Ermon. "Generative adversarial imitation learning." Advances in Neural Information Processing Systems. 2016.</p><p>[38] <a href="https://link.zhihu.com/?target=https%3A//github.com/carla-simulator/carla">https://github.com/carla-simulator/carla</a></p><p>[39] <a href="https://link.zhihu.com/?target=https%3A//36kr.com/p/5129474.html">https://36kr.com/p/5129474.html</a></p><p>[40] Vezhnevets, Alexander Sasha, et al. "Feudal networks for hierarchical reinforcement learning." arXiv preprint arXiv:1703.01161 (2017).</p><p>[41] Ranzato, Marc'Aurelio, et al. "Sequence level training with recurrent neural networks." arXiv preprint arXiv:1511.06732 (2015).</p><p>[42] Bahdanau, Dzmitry, et al. "An actor-critic algorithm for sequence prediction." arXiv preprint arXiv:1607.07086 (2016).</p><p>[43] Keneshloo, Yaser, et al. "Deep Reinforcement Learning For Sequence to Sequence Models." arXiv preprint arXiv:1805.09461 (2018).</p><p>[44] Watters, Nicholas, et al. "Visual interaction networks." arXiv preprint arXiv:1706.01433 (2017).</p><p>[45] Hamrick, Jessica B., et al. "Relational inductive bias for physical construction in humans and machines." arXiv preprint arXiv:1806.01203 (2018).</p><p>[46] Zambaldi, Vinicius, et al. "Relational Deep Reinforcement Learning." arXiv preprint arXiv:1806.01830 (2018).</p><p>[47] Santoro, Adam, et al. "Relational recurrent neural networks." arXiv preprint arXiv:1806.01822 (2018).</p><p>[48] Battaglia, Peter W., et al. "Relational inductive biases, deep learning, and graph networks." arXiv preprint arXiv:1806.01261 (2018).</p><p>[49] Eslami, SM Ali, et al. "Neural scene representation and rendering." Science 360.6394 (2018): 1204-1210.</p><p>[50] Huang, Sandy, et al. "Adversarial attacks on neural network policies." arXiv preprint arXiv:1702.02284 (2017).</p><p>[51] Behzadan, Vahid, and Arslan Munir. "Vulnerability of deep reinforcement learning to policy induction attacks." International Conference on Machine Learning and Data Mining in Pattern Recognition. Springer, Cham, 2017.</p><p>[52] Tesauro, Gerald. "Temporal difference learning and TD-Gammon." Communications of the ACM 38.3 (1995): 58-68.</p><p>[53] Jones, Rebecca M., et al. "Behavioral and neural properties of social reinforcement learning."Journal of Neuroscience 31.37 (2011): 13039-13045.</p><p>[54] <a href="https://link.zhihu.com/?target=https%3A//github.com/YBIGTA/DeepNLP-Study/wiki/MILABOT-%3A-A-Deep-Reinforcement-Learning-Chatbot">https://github.com/YBIGTA/DeepNLP-Study/wiki/MILABOT-:-A-Deep-Reinforcement-Learning-Chatbot</a></p><p>[55] Lewis, Mike, et al. "Deal or no deal? end-to-end learning for negotiation dialogues." arXiv preprint arXiv:1706.05125 (2017).</p><p>[56] <a href="https://link.zhihu.com/?target=https%3A//www.microsoft.com/zh-cn/translator/mt.aspx">https://www.microsoft.com/zh-cn/translator/mt.aspx</a></p><p>[57] Derhami, Vali, et al. "Applying reinforcement learning for web pages ranking algorithms." Applied Soft Computing 13.4 (2013): 1686-1692.</p><p>[58] Wu, Jiawei, Lei Li, and William Yang Wang. "Reinforced Co-Training." arXiv preprint arXiv:1804.06035 (2018).</p><p>[59] Li, Yuxi. "Deep reinforcement learning: An overview." arXiv preprint arXiv:1701.07274 (2017).</p><p>[60] Feinberg, Eugene A., and Adam Shwartz, eds. Handbook of Markov decision processes: methods and applications. Vol. 40. Springer Science &amp; Business Media, 2012.</p><p>[61] <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/CMA-ES">https://en.wikipedia.org/wiki/CMA-ES</a></p><p>[62] Turing, Alan M. "Computing machinery and intelligence." Parsing the Turing Test. Springer, Dordrecht, 2009. 23-65.</p><p>[63] <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Arthur_Samuel">https://en.wikipedia.org/wiki/Arthur_Samuel</a></p><p>[64] Russell, Stuart J., and Peter Norvig. Artificial intelligence: a modern approach. Malaysia; Pearson Education Limited,, 2016.</p><p>[65] Noë, Alva. Action in perception. MIT press, 2004.</p><p>[66] Garnelo, Marta, Kai Arulkumaran, and Murray Shanahan. "Towards deep symbolic reinforcement learning." arXiv preprint arXiv:1609.05518 (2016).</p><p>[67] <a href="https://link.zhihu.com/?target=http%3A//www.argmin.net/2018/04/16/ethical-rewards/">http://www.argmin.net/2018/04/16/ethical-rewards/</a></p><p>[68] Bojarski, Mariusz, et al. "End to end learning for self-driving cars." arXiv preprint arXiv:1604.07316 (2016).</p><p>[69] Recht, Benjamin . "A Tour of Reinforcement Learning:The View from Continuous Control." arXiv preprint arXiv: 1806.09460</p><p>[70] Kalashnikov, Dmitry, et al. "QT-Opt: Scalable Deep Reinforcement Learning for Vision-Based Robotic Manipulation." arXiv preprint arXiv:1806.10293 (2018).</p><p>[71] Tan, Jie, et al. "Sim-to-Real: Learning Agile Locomotion For Quadruped Robots." arXiv preprint arXiv:1804.10332 (2018).</p><p>[72] Auer, Peter. "Using confidence bounds for exploitation-exploration trade-offs." Journal of Machine Learning Research 3.Nov (2002): 397-422.</p><p>[73] Agrawal, Shipra, and Navin Goyal. "Thompson sampling for contextual bandits with linear payoffs." International Conference on Machine Learning. 2013.</p><p>[74] Mohamed, Shakir, and Danilo Jimenez Rezende. "Variational information maximisation for intrinsically motivated reinforcement learning." Advances in neural information processing systems. 2015.</p><p>[75] Pathak, Deepak, et al. "Curiosity-driven exploration by self-supervised prediction." International Conference on Machine Learning (ICML). Vol. 2017. 2017.</p><p>[76] Tang, Haoran, et al. "# Exploration: A study of count-based exploration for deep reinforcement learning." Advances in Neural Information Processing Systems. 2017.</p><p>[77] McFarlane, Roger. "A Survey of Exploration Strategies in Reinforcement Learning." McGill University, <a href="https://link.zhihu.com/?target=http%3A//www">http://www</a>. cs. mcgill. ca/∼ cs526/roger. pdf, accessed: April (2018).</p><p>[78] Plappert, Matthias, et al. "Parameter space noise for exploration." arXiv preprint arXiv:1706.01905 (2017).</p><p>[79] Fortunato, Meire, et al. "Noisy networks for exploration." arXiv preprint arXiv:1706.10295 (2017).</p><p>[80] Kansky, Ken, et al. "Schema networks: Zero-shot transfer with a generative causal model of intuitive physics." arXiv preprint arXiv:1706.04317 (2017).</p><p>[81] Li, Da, et al. "Learning to generalize: Meta-learning for domain generalization." arXiv preprint arXiv:1710.03463 (2017).</p><p>[82] <a href="https://link.zhihu.com/?target=https%3A//berkeleyautomation.github.io/dex-net/">https://berkeleyautomation.github.io/dex-net/</a></p><p>[83] <a href="https://link.zhihu.com/?target=https%3A//contest.openai.com/2018-1/">https://contest.openai.com/2018-1/</a></p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tools-FFmpeg】FFmpeg一个快速的音视频处理器</title>
      <link href="post/c71c7ed3.html"/>
      <url>post/c71c7ed3.html</url>
      
        <content type="html"><![CDATA[<p><code>ffmpeg</code> 是一个快速的音视频转码器，并且可是从实时的音视频源中抓取数据。他可以通过一个高质量的多相滤波器转换任意音频的采样频率，缩放任意视频的尺寸。</p><a id="more"></a><h2 id="常用指令">常用指令</h2><h3 id="视频处理">视频处理</h3><p>支持各种格式的视频和图片。</p><ul><li><p><strong>按帧导出图片</strong></p><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">ffmpeg</span> -i xxx.mp4 xxx%04d.png</span></code></pre></div></li><li><p><strong>视频格式转换</strong></p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">ffmpeg</span> -i input.mp4 output.avi</span></code></pre></div></li><li><p><strong>修改视频帧率</strong></p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">ffmpeg</span> -i input.avi -r 24 output.avi</span></code></pre></div><p>强制把输出视频文件帧率改为 24 fps</p></li><li><p><strong>缩小视频</strong></p><p>假设原始视频尺寸是 1080p（即 1920×1080 px，16:9），使用下面命令可以缩小到 480p：</p><pre><code>ffmpeg -i a.mov -vf scale=-1:480 -acodec aac -vcodec h264 out.mp4ffmpeg -i a.mov -vf scale=-1:480 out.mp4</code></pre><ul><li><code>-i a.mov</code> 指定待处理视频的文件名</li><li><code>-vf scale=853:480</code> vf 参数用于指定视频滤镜，其中 scale 表示缩放，后面的数字表示缩放至 853×480 px，其中的 853px 是计算而得，因为原始视频的宽高比为 16:9，所以为了让目标视频的高度为 480px，则宽度 = 480 x 9 / 16 = 853</li><li><code>-acodec aac</code> 指定音频使用 aac 编码。注：因为 ffmpeg 的内置 aac 编码目前（写这篇文章时）还是试验阶段，故会提示添加参数 “-strict -2” 才能继续，尽管添加即可。又或者使用外部的 libfaac（需要重新编译 ffmpeg）。</li><li><code>-vcodec h264</code> 指定视频使用 h264 编码。注：目前手机一般视频拍摄的格式（封装格式、文件格式）为 mov 或者 mp4，这两者的音频编码都是 aac，视频都是 h264。</li><li>上面的参数 scale=853:480 当中的宽度和高度实际应用场景中通常只需指定一个，比如指定高度为 480 或者 720，至于宽度则可以传入 “-1” 表示由原始视频的宽高比自动计算而得。即参数可以写为：<strong>scale=-1:480</strong>，当然也可以 scale=480:-1</li></ul></li><li><p><strong>裁剪视频</strong></p><p>有时可能只需要视频的正中一块，而两头的内容不需要，这时可以对视频进行裁剪（crop），比如有一个<strong>竖向</strong>的视频 1080 x 1920，如果指向保留中间 1080×1080 部分，可以使用下面的命令：</p><pre><code>ffmpeg -i a.mov -strict -2 -vf crop=1080:1080:0:420 out.mp4</code></pre><p>其中的 crop=1080:1080:0:420 是裁剪参数，含义是 crop=width:height: x:y，其中:</p><ul><li><p>width 和 height 表示裁剪后的尺寸，</p></li><li><p>x:y 表示裁剪区域的左上角坐标。</p></li></ul><p>比如当前这个示例，我们只需要保留竖向视频的中间部分，所以 x 不用偏移，故传入0，而 y 则需要向下偏移：(1920 – 1080) / 2 = 420</p><p>视频缩放和裁剪是可以同时进行的，如下命令则为将视频缩小至 853×480，然后裁剪保留横向中间部分：</p><pre><code>ffmpeg -i input.mov -strict -2 -vf scale=853:480,crop=480:480:186:0 out.mp4</code></pre></li><li><p><strong>剪辑视频</strong></p><p>如果有一段很长的视频只需保留其中的一段，可以使用下面命令对视频进行剪辑。</p><pre><code>ffmpeg -i input.mov -ss 00:00:21 -t 00:00:10 -acodec aac -vcodec h264 -strict -2 out.mov</code></pre><ul><li><p><code>-ss 00:00:21</code> 表示开始剪辑的位置（时间点），</p></li><li><p><code>-t 00:00:10</code> 表示剪辑的长度，即 10 秒钟。</p></li></ul><p>当然一段视频是可以在一个命令里同时进行剪辑、缩放、裁剪的，只需把相关的参数合在一起即可。</p></li></ul><h3 id="图像处理">图像处理</h3><ul><li><p><strong>调整图像大小</strong></p><p>指定长宽：</p><pre><code>ffmpeg -i input.jpg -vf scale=320:240 output_320x240.png</code></pre><p>指定长，高度按比例缩放：</p><pre><code>ffmpeg -i input.jpg -vf scale=320:-1 output_320x240.png</code></pre><p>缩放为之前的两倍：</p><pre><code>ffmpeg -i input.jpg -vf scale=iw*2:ih input_double_width.png</code></pre><p>缩放为之前的二分之一：</p><pre><code>ffmpeg -i input.jpg -vf “scale=iw*.5:ih*.5” input_half_size.pngffmpeg -i input.jpg -vf “scale=iw/2:ih/2” input_half_size.png</code></pre></li></ul><h2 id="总览">总览</h2><pre><code>ffmpeg [global_options] &#123;[input_file_options] -i input_url&#125; ... &#123;[output_file_options] output_url&#125; ...</code></pre><h2 id="说明">说明</h2><p><code>ffmpeg</code> 可以从任意数量的输入文件中读取数据，输出到任意数量的文件中，这里的文件包括通常意义的文件，管道，网络流，输入设备等，输入文件可以通过<code>-i</code> 选项指定，输出文件通过一个纯文本的字符串指定。在命令行上发现的所有的非选项内容都被认为是输出文件名。</p><p>原则上，所有的输入或输出文件都可以包含任意数量的不同类型的流，包括视频流，音频流，字幕流，附件流和数据流。数量和类型受容器的限制。输入文件中的某一个流保存到输出文件中的哪一个流，这件事情可以由<code>ffmpeg</code> 自动完成或由 <code>-map</code> 选项来指定 （见流选择章节）。</p><p>如果某个选项是针对哪一个输入文件的，需要使用从0开始的索引号指定，第一个文件的索引号为0，第二个文件的索引号为1，以此类推。同样的，文件中的流也是用索引号来表示的。例如 <code>2:3</code> 代表第3个文件中的第4个流，详见流选择章节。</p><p>通用规则是，所有选项作用于其后边的第一个文件。因此，顺序是非常重要的，你可以在命令行中重复指定相同的选项，只是指定的文件不同。那些全局的选项需要在命令行中优先指定。</p><p>千万不要输入文件和输出文件交叉出现在命令行中，先统一指定所有的输入文件，然后再指定所有的输入文件。同时也不要把指定给不同文件的选项弄混了。</p><ul><li><p>设置输出文件的视频码率为64kbit/s:</p><pre><code>ffmpeg -i input.avi -b:v 64k -bufsize 64k output.avi</code></pre></li><li><p>指定输出文件的帧率为24：</p><pre><code>ffmpeg -i input.avi -r 24 output.avi</code></pre></li><li><p>强制指定输入文件的帧率为1，输出文件的帧率为24</p><pre><code>ffmpeg -r 1 -i input.m2v -r 24 output.avi</code></pre></li></ul><h2 id="详细说明">详细说明</h2><p><code>ffmpeg</code> 中的转码流程可以用下图来描述:</p><p><code>ffmpeg</code> 调用 libavformat 库(包含demuxer) 读取输入文件，从中提取出编码的数据包。如果有多个输入文件，<code>ffmpeg</code> 会根据最低的时间戳信息保持文件间的输入流同步。</p><p>编码的数据包会交给解码器，除非使用了流拷贝，详情查看后边章节。解码器输出无压缩的数据帧，然后再交给滤波器做处理（见下一节）。经过滤波器后，这些数据帧会再传给编码器，输出压缩的数据包，最后把这些数据交给muxer, 把这些数据保存成文件。</p><h3 id="滤波">滤波</h3><p>在编码之前，<code>ffmpeg</code> 会在libavfilter库中使用滤波器处理解码后的原始音视频数据。各种不同的滤波器组成一个滤波器组。<code>ffmpeg</code> 可以区分简单和复杂两种滤波器组。</p><h4 id="简单滤波器组">简单滤波器组</h4><p>简单滤波器组由单输入单输出滤波器构成，并且滤波器都是同种类型。他们可以用下图表达。</p><p>简单滤波器组可以通过<code>-per-stream</code> <code>-filter</code> 选项进行配置，视频滤波器选项简化为 <code>-vf</code>, 音频滤波器选项简化为<code>-af</code>. 一个简单的视频滤波器组可以表达成以下形式：</p><p>注意，有些滤波器会改变帧的属性，但是并不会改变其内容。例如，上边例子中的 <code>fps</code> 滤波器改变了帧率 ，但是每一帧的内容是没有被改变的。再者，<code>setpts</code> 滤波器，只是改变了时间戳信息，而帧内容没有改变。</p><h4 id="复杂滤波器组">复杂滤波器组</h4><p>复杂滤波器组是那些不能简单的用线性处理描述的滤波器。举个例子，当这个滤波器组由多个输入和输出，或者输出的流类型跟输入不同。这样的滤波器组可以用下图描述：</p><p>复杂滤波器组通过 <code>-filter_complex</code> 选项进行配置。注意，这个选项是全局的，也就是说不能单独为单个流添加复杂滤波器组。</p><p><code>-lavfi</code> 选项跟 <code>-filter_complex</code> 选项等效。</p><p>常见的复杂滤波器组是 <code>overlay</code>, 有两个视频输入一个视频输出，其中一个视频会改在另一个视频的上边。与其对应的是 <code>amix</code> 滤波器。</p><h3 id="流拷贝">流拷贝</h3><p>流拷贝是通过给 <code>-codec</code> 选项添加 <code>copy</code> 参数的一种模式。可以让 ffmpeg 省掉了先解码再编码的步骤，只有demuxer和muxer. 经常应用于改变视频文件类型，或修改容器的元数据。可以用下图描述:</p><p>因为没有编解码，流拷贝运行的非常快并且可以做到无损。但是，有些时候是不能用流拷贝的，例如你想应用滤波器组。</p><h2 id="流选择">流选择</h2><p>默认情况下，ffmpeg 只从输入文件中选择一个视频流，一个音频流，一个字幕流，然后把这些流保存到输出文件中。ffmpeg通过下边的标准选择最优的视频，音频和字幕：</p><ul><li>视频，选择最高分辨率的流</li><li>音频，选择有最多升到的流</li><li>字幕，选择第一个字幕流</li><li>如果多个同类型的流具有相同的参数，那么选取第一个。</li></ul><p>我们可以通过 <code>-vn/-an/-sn/-dn</code> 选项禁用这些默认标准。如果你想全部手动选择，可以通过<code>-map</code> 选项进行配置。</p><h2 id="选项">选项</h2><p>除非特别标明，所有的数字选项都采用字符串表示，数字后边可能需要加国际单位制的前缀，像”K”, “M”或”G”等。</p><p>如果”i”被追加到国际单位制前缀后的话，组成的前缀表示二进制倍数，基于1024的幂而不是1000的幂。如果追加的是”B”的话，表示这个数值的8倍。因此，允许我们使用像”KB”, “MiB”, “G”和”B”作为后缀。</p><p>不带参数的选项表示是布尔选项，并且设置该选项为真。如果要设置此选项为假，那么只需要在该选项前边加上前缀”no”。举例来说，”nofoo”会设置”foo”选项为假。</p><h3 id="流指示符">流指示符</h3><p>有些选项要被应用到每一个流上，例如bitrate和codec。流指示符被用来精确的表明某个选项参数应用于哪一个流。</p><p>流指示符是一个字符串，通常被追加在选项后边，并用冒号分割。例如 <code>-codec:a:1 ac3</code> 包含了流指示符 <code>a:1</code>，这表示编码器 <code>ac3</code> 被用于第二个音频流。</p><p>流指示符也可以用于多个流，这样选项参数就可以应用于这些流。例如 <code>-b:a 128k</code> 被应用于所有的音频流。</p><p>如果没有流指示符，代表该选项参数被应用于所有的流，例如 <code>codec copy</code>，<code>-codec: copy</code> 表示直接拷贝流而不进行重新编码。</p><p>常用的流指示符有：</p><p><strong><code>stream_index</code></strong></p><blockquote><p>匹配该选项指定的流。例如 <code>-threads:1 4</code>， 表示设置第一个流的线程号为4.</p></blockquote><p><strong><code>stream_type[:stream_index]</code></strong></p><p><code>stream_type</code> 有以下几种类型，</p><blockquote><p>‘v’ 表示所有的视频流 ‘V’ 表示不带缩略图的视频流 ‘a’ 表示音频 ‘s’ 表示字幕 ‘d’ 表示数据 ‘t’ 表示附件</p></blockquote><p>如果给出 <code>stream_index</code> 那么表示<code>stream_index</code> 代表的流是这种类型，否则，代表所有的流都是这种类型。</p><p><strong><code>p:program_id[:stream_index]</code></strong></p><p>如果给出 <code>stream_index</code>, 则其代表的流在<code>program_id</code> 表达的进程中操作，否则，所有的流都在此进程中。</p><p><strong>#stream_id或i:stream_id</strong></p><p>匹配<code>stream_id</code> 表示的流(例如 MPEG-TS 容器中的PID)</p><p><strong>m:key[:value]</strong></p><p>匹配元数据标签 <code>key</code> 的值为指定值得流。如果没有给出<code>value</code>， 匹配所有具有该元数据标签的流。</p><p><strong>u</strong></p><p>匹配具有可用配置的流，codec必须指定必要的参数，像视频的长宽，音频的采样频率等。</p><p>注意，在 <code>FFmpeg</code> 中，用元数据匹配只作用于指定的输入文件。</p><h3 id="通用选项">通用选项</h3><p>以下选项在所有的 <code>ff*</code> 工具中通用，</p><p><strong><code>-L</code></strong></p><blockquote><p>显示许可证</p></blockquote><p><strong>-h, -?, -help, –help [arg]</strong></p><p>显示帮助。可选参数可以只打印指定项的帮助信息。如果没有指定可选参数，只显示基本的工具选项。</p><p>可选参数 <code>arg</code> ，请参考如下详细描述</p><table><colgroup><col style="width: 25%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: left;">arg</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">long</td><td style="text-align: left;">打印高级选项帮助信息</td></tr><tr class="even"><td style="text-align: left;">full</td><td style="text-align: left;">打印完整的选项列表，包含encoder，decoder，muxer, demuxer, filter的共享的和私有的选项信息</td></tr><tr class="odd"><td style="text-align: left;">decoder=decoder_name</td><td style="text-align: left;">打印指定解码器的详细信息，可以使用<code>-decoders</code> 选项获取所有支持的解码器列表</td></tr><tr class="even"><td style="text-align: left;">encoder=encoder_name</td><td style="text-align: left;">打印指定编码器的详细信息，可以使用<code>-encoders</code> 选项获取所有支持的编码器列表</td></tr><tr class="odd"><td style="text-align: left;">demuxer=demuxer_name</td><td style="text-align: left;">打印指定demuxer的详细信息，可以使用<code>-formats</code> 选项获取所有支持的demuxer和muxer列表</td></tr><tr class="even"><td style="text-align: left;">muxer=muxer_name</td><td style="text-align: left;">打印指定muxer的详细信息，可以使用<code>-formats</code> 获取所有支持的demuxer和muxer列表</td></tr><tr class="odd"><td style="text-align: left;">filter=filter_name</td><td style="text-align: left;">打印指定的filter的详细信息，可以使用<code>-filters</code> 获取所有支持的filter列表</td></tr></tbody></table><p><strong><code>-version</code></strong></p><p>显示版本号</p><p><strong><code>-formats</code></strong></p><p>显示可用的容器(包含设备)</p><p><strong><code>-devices</code></strong></p><p>显示可用的设备</p><p><strong><code>-codecs</code></strong></p><p>显示<code>libavcodec</code> 支持的所有编解码器, 注意此文档中的术语<code>codec</code> 代表媒体流格式。</p><p><strong><code>-decoders</code></strong></p><p>显示可用的解码器</p><p><strong><code>-encoders</code></strong></p><p>显示可用的编码器</p><p><strong><code>-bsfs</code></strong></p><p>显示可用的码流滤波器</p><p><strong><code>-protocols</code></strong></p><p>显示可用的协议栈</p><p><strong><code>-filters</code></strong></p><p>显示可用的<code>libavfilter</code> 滤波器。</p><p><strong><code>-pix_fmts</code></strong></p><p>显示可用的像素格式</p><p><strong><code>sample_fmts</code></strong></p><p>显示可用的采样格式</p><p><strong><code>-layout</code></strong></p><p>显示频道名和标准的频道布局</p><p><strong><code>-color</code></strong></p><p>显示识别的颜色名称</p><p><strong><code>sources device[, opt1=val1[,opts=val2]...]</code></strong></p><p>显示自动检测到的输入设备。有些输入设备的名称可能以来操作系统，这样就没法自动检测到。返回列表可能是不完整的。</p><pre><code>ffmpeg -sources pulse,server=192.168.0.4</code></pre><p><strong><code>-sinks device[,opt1=val1[,opt2=val2]...]</code></strong></p><p>显示自动侦测到的输出设备。有些输出设备的名称可能依赖操作系统，这样就没法自动检测到。返回列表可能是不完整的。</p><pre><code>ffmpeg -sinks pulse,server=192.168.0.4</code></pre><p><strong><code>-loglevel [repeat+]loglevel | -v [repeat+]loglevel</code></strong></p><p>设置库的日志等级。添加<code>repeat+</code> 表明重复的日志输出不会覆盖第一行，并且后边的重复日志会被忽略。<code>repeat</code> 也可以单独使用。如果<code>repeat</code> 被单独使用，也没有指定日志优先级，那么将使用默认的日志等级。如果指定了多个日志等级参数，使用<code>repeat</code> 将不会改变日志等级。<code>loglevel</code> 是一个字符串或一个数字，可以是一下的形式，</p><table><thead><tr class="header"><th style="text-align: left;">日志等级</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>quiet, -8</code></td><td style="text-align: left;">什么都不输入</td></tr><tr class="even"><td style="text-align: left;"><code>panic, 0</code></td><td style="text-align: left;">只显示那些可能导致程序崩溃的致命错误，例如所有的断言错误</td></tr><tr class="odd"><td style="text-align: left;"><code>fatal, 8</code></td><td style="text-align: left;">只显示导致程序崩溃的信息</td></tr><tr class="even"><td style="text-align: left;"><code>error, 16</code></td><td style="text-align: left;">显示所有的错误信息</td></tr><tr class="odd"><td style="text-align: left;"><code>warning, 24</code></td><td style="text-align: left;">显示所有的警告和错误信息</td></tr><tr class="even"><td style="text-align: left;"><code>info, 32</code></td><td style="text-align: left;">试试所有提示类信息，包含警告信息，错误信息</td></tr><tr class="odd"><td style="text-align: left;"><code>verbose, 40</code></td><td style="text-align: left;">跟 <code>info</code> 相同</td></tr><tr class="even"><td style="text-align: left;"><code>debug, 48</code></td><td style="text-align: left;">显示所有信息，包含调试信息</td></tr><tr class="odd"><td style="text-align: left;"><code>trace, 56</code></td><td style="text-align: left;"></td></tr></tbody></table><p>默认情况下，程序的logs会不给输出到<code>stderr</code>. 如果中断支持颜色，警告和错误会用颜色高亮显示出来。可以使用<code>AV_LOG_FORCE_NOCOLOR</code> 或 <code>NO_COLOR</code> 关掉颜色，也可以使用 <code>AV_LOG_FORCE_COLOR</code> 打开颜色。<code>NO_COLOR</code> 已经过时。</p><p><strong><code>-report</code></strong></p><p>把所有的命令行和终端打印信息输出到当前目录的文件<code>program-YYYYMMDD-HHMMSS.log</code> . 这个文件有助于分析bug, 默认使用 <code>-loglevel-verbose</code>.</p><p>设置任意值到环境变量<code>FFREPORT</code> 也可以达到同样的效果。也可以追加level, 举例如下</p><pre><code>FFREPORT=file=ffreport.log:level=32 ffmpeg -i input output</code></pre><p><strong><code>hide_banner</code></strong></p><p>禁止打印横幅。</p><p>所有的FFmpeg工具通常都会显示版权信息，编译选项和库版本号。增加这个选项可以让程序不打印这些信息。</p><p><strong><code>-cpuflags flags (global)</code></strong></p><p>允许设置和清空CPU标志，这个选项只是用于测试。如果你不了解这些标志位的意义，建议你不要使用。</p><pre><code>ffmpeg -cpuflags -sse+mmx ...ffmpeg -cpuflags mmx ...ffmpeg -cpuflags 0 ...</code></pre><p>可用的标志位如下：</p><table><colgroup><col style="width: 24%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th style="text-align: left;">平台</th><th style="text-align: left;">标志位</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">x86</td><td style="text-align: left;"><code>mmx</code>, <code>mmxext</code>, <code>sse</code>, <code>sse2</code>, <code>sse2slow</code>, <code>sse3</code>, <code>sse3slow</code>, <code>ssse3</code>, <code>atom</code>, <code>sse4.1</code>, <code>sse4.2</code>, <code>avx</code>, <code>avx2</code>, <code>xop</code>, <code>fma3</code>, <code>fma4</code>, <code>3dnow</code>, <code>3dnowext</code>, <code>bmi1</code>, <code>bmi2</code>, <code>cmov</code></td></tr><tr class="even"><td style="text-align: left;">ARM</td><td style="text-align: left;"><code>armv5te</code>, <code>armv6</code>, <code>armv6t2</code>, <code>vfp</code>, <code>vfpv3</code>, <code>neon</code>, <code>setend</code></td></tr><tr class="odd"><td style="text-align: left;">AArch64</td><td style="text-align: left;"><code>armv8</code>, <code>vfp</code>, <code>neon</code></td></tr><tr class="even"><td style="text-align: left;">PowerPC</td><td style="text-align: left;"><code>altivec</code></td></tr><tr class="odd"><td style="text-align: left;">Specific Processors</td><td style="text-align: left;"><code>pentium2</code>, <code>pentium3</code>, <code>pentium4</code>, <code>k6</code>, <code>k62</code>, <code>athlon</code>, <code>athlonxp</code>, <code>k8</code></td></tr></tbody></table><p><strong><code>-opencl_bench</code></strong></p><p>这个选项用于对支持<code>OpenCL</code> 的设备进行基准测试并且打印出结果。使用此选项前请确保你的FFmpeg编译的时候添加了选项<code>-enable-opencl</code>.</p><p>如果FFmpeg配置了<code>-enable-opencl</code>， <code>OpenCL</code> 的全局上下文选项可以通过<code>-opencl_options</code> 进行配置。请参考 <code>ffmpeg-utils</code> 手册中的 <code>OpenCL Options</code> 部分。还可以指定平台和设备来运行OpenCL代码。默认情况下，FFmpeg会运行在第一个平台的第一个设备上。而OpenCL 的全局上下文选项允许用户选择OpenCL设备，大多数用户会选择系统中最快的OpenCL设备。</p><p>这个选项有助于选择系统中最快的OpenCL设备。内置的基准程序会在所有的OpenCL设备上运行并且对设备的性能做出评价。运行结束后会输出一个按照性能高低的顺序排列的列表，性能越高，排名越靠前。然后用户可以用性能最好的设备运行FFmpeg, 以获取最高的硬件加速性能。</p><p>通常用下面的步骤来应用最快的OpenCL设备，</p><pre><code>ffmpeg -opencl_bench</code></pre><p>记录下平台ID(pidx)和设备ID(didx)，然后执行下边的指令，</p><pre><code>ffmpeg -opencl_options platform_idx=pidx:device_idx=didx ...</code></pre><p><strong><code>-opencl_options options (global)</code></strong></p><p>设置OpenCL环境变量，只有FFmpeg编译时添加了<code>--enable-opencl</code> 才能使用该选项。</p><p>选项必须是一个符合 <code>key=value</code> 的序列，中间用”:” 分割开。详见 <code>ffmpeg-utils</code> 手册中的 <code>OpenCL Options</code> 部分。</p><h3 id="avoptions">AVOptions</h3><p>这些选项由<code>libavformat</code>, <code>libavdevice</code>, <code>libavcodec</code> 库提供。可以使用<code>-help</code> 选项来查看AVOptions支持列表。其可以分为两类，</p><p><strong>通用</strong></p><p>这些选项可以用用于所有的容器，编解码器或设备。<code>AVFormatContext</code> 中定义了关于容器和设备的通用选项，<code>AVCodecContext</code> 中定义了关于编解码器的通用选项。</p><p><strong>私有</strong></p><p>这些选项是针对特定容器，设备或编解码器的。他们被定义在相应的容器/设备/编解码器中。</p><p>例如，要将一个MP3文件的文件头由默认的ID3V2.4改成ID3V2.3, 可以使用<code>id3v2_version</code> 这个MP3 容器的私有选项：</p><pre><code>ffmpeg -i input.flac -id3v2_version 3 out.mp3</code></pre><p>所有的编解码器AVOptions 都是针对特定流的，因此需要使用流指示符来指定这个选项应用于哪一个流。</p><blockquote><p><strong>注意</strong>， AVOptions不能使用布尔选项，即没有<code>nooption</code> 这样的语法，应该使用 <code>-option 0/ -option 1</code>.</p></blockquote><h3 id="主要选项">主要选项</h3><p><strong><code>-f fmt (input/output)</code></strong></p><p>指定输入文件和输出文件的格式。通常情况下输入文件的格式是自动检测出的，输出文件的格式是通过文件后缀猜出来的。所以，在大多数情况下，不需要使用这个选项。</p><p><strong><code>-i url (input)</code></strong></p><p>输入文件的路径。</p><p><strong><code>-y (global)</code></strong></p><p>不提示，直接覆盖输出文件。</p><p><strong><code>-n (global)</code></strong></p><p>不要覆盖输出文件，如果输出文件已存在直接退出。</p><p><strong><code>-stream_loop number (input)</code></strong></p><p>设置输入文件的循环次数。0 表示不循环，-1代表无限循环。</p><p><strong><code>-c[:stream_specifier] codec (input/output,per-stream)</code></strong></p><p><strong><code>-codec[:stream_specifier] codec (input/output,per-stream)</code></strong></p><p>给输出流选择编码器，给输入流选择解码器。codec 是编码器或解码器的名字，或者是 copy，表示不会对输入流进行重新编码。</p><p>例如：</p><pre><code>ffmpeg -i INPUT -map 0 -c:v libx264 -c:a copy OUTPUT</code></pre><p>表示对所有的视频流使用libx264编码，拷贝所有的音频流。</p><p>对每个流，总是应用最后的<code>-c</code> 选项，例如，</p><pre><code>ffmpeg -i INPUT -map 0 -c copy -c:v:1 libx264 -c:a:137 libvorbis OUTPUT</code></pre><p>除了第2个视频流使用libx264编码和第138个音频流使用libvorbis编码之外，拷贝所有剩余流。</p><p><strong><code>-t duration (input/output)</code></strong></p><p>作为输入文件的参数时，表示从输入文件中读取 duration指定时间的数据。</p><p>作为输出文件的参数是，表示当时间超过duration指定的时间时，停止写文件。</p><p>duration 必须符合时间持续标准，详见<a href="http://www.ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p><p><code>-t</code> 和 <code>-to</code> 互相排斥，不过 <code>-t</code> 具有更高的优先级。</p><p><strong><code>-to position (output)</code></strong></p><p>在某个位置时停止写文件。位置必须符号时间持续标准 ，详见<a href="http://www.ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p><p><code>-t</code> 和 <code>-to</code> 互相排斥，不过 <code>-t</code> 具有更高的优先级</p><p><strong><code>-fs limit_size (output)</code></strong></p><p>限制文件大小，以字节计。一旦达到了限定大小，停止写入数据。</p><p><strong><code>-ss position (input/output)</code></strong></p><p>作为输入文件参数时，跳转到输入文件的position位置，注意在大多数的文件格式中，是很难精确的跳转的，ffmpeg只会跳转到指定位置的附近。在转码时，默认开启 <code>-accurate_seek</code> 参数。在跳转点和position之间的数据，会在解码后丢弃。当流拷贝或使用 <code>-noaccurate_seek</code> 时，会保留这些数据。</p><p>当作为输出文件参数时，解码后丢弃输入，直到时间戳跟position匹配为止。</p><p>position 必须符号时间持续标准，详见<a href="http://www.ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p><p><strong><code>sseof position (input/output)</code></strong></p><p>跟 <code>-ss</code> 选项很像，只是会跳转到从文件结尾处开始计数的某一个为止，这个数是个负数，0表示文件尾。</p><p><strong><code>-itsoffset offset (input)</code></strong></p><p>设置输入文件的时间偏移量。</p><p>偏移量必须符合时间持续标准，详见<a href="http://www.ffmpeg.org/ffmpeg-utils.html#time-duration-syntax">(ffmpeg-utils)the Time duration section in the ffmpeg-utils(1) manual</a>.</p><p>这个偏移量会被加到输入文件的时间戳中。如果offset是正数，代表相应的流会延时offset的时间。</p><p><strong><code>-timestamp date (output)</code></strong></p><p>设置容器中的录制时间戳。</p><p>date必须符合日期标准，详见 <a href="http://www.ffmpeg.org/ffmpeg-utils.html#date-syntax">(ffmpeg-utils)the Date section in the ffmpeg-utils(1) manual</a>.</p><p><strong><code>-metadata[:metadata_specifier] key=value (output,per-metadata)</code></strong></p><p>设置元数据。</p><p>可以给流，章节和节目设置专门的元数据 metadata_specifier. 详见<code>-map_metadata</code>.</p><p>这个选项可以覆盖 <code>-map_metadata</code> 设置的元数据。可以是设置一个空值来删除元数据。</p><p>例如，设置输出文件的标题：</p><pre><code>ffmpeg -i in.avi -metadata title=&quot;my title&quot; out.flv</code></pre><p>设置第一个音频流的语言：</p><pre><code>ffmpeg -i INPUT -metadata:s:a:0 language=eng OUTPUT</code></pre><p><strong><code>-disposition[:stream_specifier] value (output,per-stream)</code></strong></p><p>设置流的属性。</p><p>这个选项会覆盖从输入文件中拷贝的流属性。也可以通过设置0值来删除某个属性。</p><p>可以使用如下的属性，</p><pre><code>default` `dub` `original` `comment` `lyrics` `karaoke` `forced` `hearing_imparied` `visual_imparied` `clean_effects` `captions` `descriptions` `metadata</code></pre><p>例如， 设置第二个音频流为默认流：</p><pre><code>ffmpeg -i in.mkv -disposition:a:1 default out.mkv</code></pre><p>设置第二个字幕流为默认流，并且删除第一个字幕流的默认属性:</p><pre><code>ffmpeg -i INPUT -disposition:s:0 0 -disposition:s:1 default OUTPUT</code></pre><p><strong><code>-program [title=title:][program_num=program_num:]st=stream[:st=stream...] (output)</code></strong></p><p>使用指定的标题和节目号创建节目。并且给节目添加指定的流。</p><p><strong><code>target type (output)</code></strong></p><p>指定目标文件类型，如 <code>vcd</code>, <code>svcd</code>, <code>dvd</code>, <code>dv</code>, <code>dv50</code>. 文件类型通常添加像<code>pal-</code>, <code>ntsc-</code> 或 <code>film-</code> 的前缀以满足相应的标准。然后所有的像码率，编解码器，内存大小等参数会被自动设置。例如</p><pre><code>ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg</code></pre><p>尽管如此，只要不跟相应的标准冲突，你也可以指定其他的选项，例如:</p><pre><code>ffmpeg -i myfile.avi -target vcd -bf 2 /tmp/vcd.mpg</code></pre><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Latex】数学符号-代码对照表</title>
      <link href="post/73a19565.html"/>
      <url>post/73a19565.html</url>
      
        <content type="html"><![CDATA[<p>Latex数学符号与公式的对照表</p><a id="more"></a><h2 id="希腊字母">希腊字母</h2><table><thead><tr class="header"><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\alpha\)</span></td><td>\alpha</td><td><span class="math inline">\(A\)</span></td><td>\Alpha</td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td>\beta</td><td><span class="math inline">\(B\)</span></td><td>\Beta</td></tr><tr class="odd"><td><span class="math inline">\(γ\)</span></td><td>\gamma</td><td><span class="math inline">\(Γ\)</span></td><td>\Gamma</td></tr><tr class="even"><td><span class="math inline">\(δ\)</span></td><td>\delta</td><td><span class="math inline">\(Δ\)</span></td><td>\Delta</td></tr><tr class="odd"><td><span class="math inline">\(ϵ\)</span></td><td>\epsilon</td><td><span class="math inline">\(E\)</span></td><td>\Epsilon</td></tr><tr class="even"><td><span class="math inline">\(ε\)</span></td><td>\varepsilon</td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\zeta\)</span></td><td>\zeta</td><td><span class="math inline">\(Z\)</span></td><td>\Zeta</td></tr><tr class="even"><td><span class="math inline">\(\eta\)</span></td><td>\eta</td><td><span class="math inline">\(H\)</span></td><td>\Eta</td></tr><tr class="odd"><td><span class="math inline">\(\theta\)</span></td><td>\theta</td><td><span class="math inline">\(Θ\)</span></td><td>\Theta</td></tr><tr class="even"><td><span class="math inline">\(\vartheta\)</span></td><td>\vartheta</td><td></td><td></td></tr><tr class="odd"><td><span class="math inline">\(\iota\)</span></td><td>\iota</td><td><span class="math inline">\(I\)</span></td><td>\Iota</td></tr><tr class="even"><td><span class="math inline">\(\kappa\)</span></td><td>\kappa</td><td><span class="math inline">\(K\)</span></td><td>\Kappa</td></tr><tr class="odd"><td><span class="math inline">\(\lambda\)</span></td><td>\lambda</td><td><span class="math inline">\(Λ\)</span></td><td>\Lambda</td></tr><tr class="even"><td><span class="math inline">\(\mu\)</span></td><td>\mu</td><td><span class="math inline">\(M\)</span></td><td>\Mu</td></tr><tr class="odd"><td><span class="math inline">\(\nu\)</span></td><td>\nu</td><td><span class="math inline">\(N\)</span></td><td>\Nu</td></tr><tr class="even"><td><span class="math inline">\(\xi\)</span></td><td>\xi</td><td><span class="math inline">\(Ξ\)</span></td><td>\Xi</td></tr><tr class="odd"><td><span class="math inline">\(\omicron\)</span></td><td>\omicron</td><td><span class="math inline">\(O\)</span></td><td>\Omicron</td></tr><tr class="even"><td><span class="math inline">\(\pi\)</span></td><td>\pi</td><td><span class="math inline">\(Π\)</span></td><td>\Pi</td></tr><tr class="odd"><td><span class="math inline">\(\varpi\)</span></td><td>\varpi</td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\rho\)</span></td><td>\rho</td><td><span class="math inline">\(P\)</span></td><td>\Rho</td></tr><tr class="odd"><td><span class="math inline">\(\varrho\)</span></td><td>\varrho</td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\sigma\)</span></td><td>\sigma</td><td><span class="math inline">\(Σ\)</span></td><td>\Sigma</td></tr><tr class="odd"><td><span class="math inline">\(\varsigma\)</span></td><td>\varsigma</td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\tau\)</span></td><td>\tau</td><td><span class="math inline">\(T\)</span></td><td>\Tau</td></tr><tr class="odd"><td><span class="math inline">\(\upsilon\)</span></td><td>\upsilon</td><td><span class="math inline">\(Υ\)</span></td><td>\Upsilon</td></tr><tr class="even"><td><span class="math inline">\(\phi\)</span></td><td>\phi</td><td><span class="math inline">\(Φ\)</span></td><td>\Phi</td></tr><tr class="odd"><td><span class="math inline">\(\varphi\)</span></td><td>\varphi</td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(\chi\)</span></td><td>\chi</td><td><span class="math inline">\(X\)</span></td><td>\Chi</td></tr><tr class="odd"><td><span class="math inline">\(\psi\)</span></td><td>\psi</td><td><span class="math inline">\(Ψ\)</span></td><td>\Psi</td></tr><tr class="even"><td><span class="math inline">\(\omega\)</span></td><td>\omega</td><td><span class="math inline">\(Ω\)</span></td><td>\Omega</td></tr></tbody></table><h2 id="运算符符号">运算符符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>名称</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\pm\)</span></td><td>\pm</td><td>加减</td></tr><tr class="even"><td><span class="math inline">\(∓\)</span></td><td>\mp</td><td>减加</td></tr><tr class="odd"><td><span class="math inline">\(×\)</span></td><td>\times</td><td>乘</td></tr><tr class="even"><td><span class="math inline">\(÷\)</span></td><td>\div</td><td>除</td></tr><tr class="odd"><td><span class="math inline">\(⋅\)</span></td><td>\cdot</td><td>点</td></tr><tr class="even"><td><span class="math inline">\(∗\)</span></td><td>\ast</td><td>星号</td></tr><tr class="odd"><td><span class="math inline">\(⋆\)</span></td><td>\star</td><td>五角星</td></tr><tr class="even"><td><span class="math inline">\(†\)</span></td><td>\dagger</td><td>剑号</td></tr><tr class="odd"><td><span class="math inline">\(‡\)</span></td><td>\ddagger</td><td>双剑号</td></tr><tr class="even"><td><span class="math inline">\(⨿\)</span></td><td>\amalg</td><td>amalg</td></tr><tr class="odd"><td><span class="math inline">\(∩\)</span></td><td>\cap</td><td>圆帽</td></tr><tr class="even"><td><span class="math inline">\(∪\)</span></td><td>\cup</td><td>圆杯</td></tr><tr class="odd"><td><span class="math inline">\(⊎\)</span></td><td>\uplus</td><td>圆杯加号</td></tr><tr class="even"><td><span class="math inline">\(⊓\)</span></td><td>\sqcap</td><td>方帽</td></tr><tr class="odd"><td><span class="math inline">\(\sqcup\)</span></td><td>\sqcup</td><td>方杯</td></tr><tr class="even"><td><span class="math inline">\(∨\)</span></td><td>\vee</td><td>正V</td></tr><tr class="odd"><td><span class="math inline">\(∧\)</span></td><td>\wedge</td><td>倒V</td></tr><tr class="even"><td><span class="math inline">\(\setminus\)</span></td><td>\setminus</td><td>集差</td></tr><tr class="odd"><td><span class="math inline">\(≀\)</span></td><td>\wr</td><td>环积</td></tr><tr class="even"><td><span class="math inline">\(∘\)</span></td><td>\circ</td><td>圆圈</td></tr><tr class="odd"><td><span class="math inline">\(∙\)</span></td><td>\bullet</td><td>实心圆</td></tr><tr class="even"><td><span class="math inline">\(⊘\)</span></td><td>\oslash</td><td>圆圈斜线</td></tr><tr class="odd"><td><span class="math inline">\(⊙\)</span></td><td>\odot</td><td>圆圈点</td></tr><tr class="even"><td><span class="math inline">\(◯\)</span></td><td>\bigcirc</td><td>大圆圈</td></tr><tr class="odd"><td><span class="math inline">\(△\)</span></td><td>\bigtriangleup</td><td>大正三角形</td></tr><tr class="even"><td><span class="math inline">\(▽\)</span></td><td>\bigtriangledown</td><td>大倒三角形</td></tr><tr class="odd"><td><span class="math inline">\(◃\)</span></td><td>\triangleleft</td><td>左三角形</td></tr><tr class="even"><td><span class="math inline">\(▹\)</span></td><td>\triangleright</td><td>右三角形</td></tr><tr class="odd"><td><span class="math inline">\(⊕\)</span></td><td>\oplus</td><td>圆圈加号</td></tr><tr class="even"><td><span class="math inline">\(\ominus\)</span></td><td>\ominus</td><td>圆圈减号</td></tr><tr class="odd"><td><span class="math inline">\(⊗\)</span></td><td>\otimes</td><td>圆圈乘号</td></tr><tr class="even"><td><span class="math inline">\(⊥\)</span></td><td>\bot</td><td>倒T</td></tr><tr class="odd"><td><span class="math inline">\(⊤\)</span></td><td>\top</td><td>正T</td></tr><tr class="even"><td><span class="math inline">\(∑\)</span></td><td>\sum</td><td>求和</td></tr><tr class="odd"><td><span class="math inline">\(∏\)</span></td><td>\prod</td><td>乘积</td></tr><tr class="even"><td><span class="math inline">\(∫\)</span></td><td>\int</td><td>积分</td></tr><tr class="odd"><td><span class="math inline">\(∮\)</span></td><td>\oint</td><td>围道积分</td></tr><tr class="even"><td><span class="math inline">\(⨄\)</span></td><td>\biguplus</td><td>大圆杯加号</td></tr><tr class="odd"><td><span class="math inline">\(⨁\)</span></td><td>\bigoplus</td><td>大圆圈加号</td></tr><tr class="even"><td><span class="math inline">\(⋁\)</span></td><td>\bigvee</td><td>大V</td></tr><tr class="odd"><td><span class="math inline">\(⋂\)</span></td><td>\bigcap</td><td>大圆帽</td></tr><tr class="even"><td><span class="math inline">\(⨂\)</span></td><td>\bigotimes</td><td>大圆圈乘号</td></tr><tr class="odd"><td><span class="math inline">\(⋀\)</span></td><td>\bigwedge</td><td>大倒V</td></tr><tr class="even"><td><span class="math inline">\(⋃\)</span></td><td>\bigcup</td><td>大圆杯</td></tr><tr class="odd"><td><span class="math inline">\(⨀\)</span></td><td>\bigodot</td><td>大圆圈点</td></tr><tr class="even"><td><span class="math inline">\(⨆\)</span></td><td>\bigsqcup</td><td>大方杯</td></tr></tbody></table><h2 id="关系符号">关系符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>名称</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(&lt;\)</span></td><td>&lt;</td><td>小于</td></tr><tr class="even"><td><span class="math inline">\(&gt;\)</span></td><td>&gt;</td><td>大于</td></tr><tr class="odd"><td><span class="math inline">\(≤\)</span></td><td>\leq</td><td>小于等于</td></tr><tr class="even"><td><span class="math inline">\(≥\)</span></td><td>\geq</td><td>大于等于</td></tr><tr class="odd"><td><span class="math inline">\(≪\)</span></td><td>\ll</td><td>远小于</td></tr><tr class="even"><td><span class="math inline">\(≫\)</span></td><td>\gg</td><td>远大于</td></tr><tr class="odd"><td><span class="math inline">\(≠\)</span></td><td>\neq</td><td>不等于</td></tr><tr class="even"><td><span class="math inline">\(≐\)</span></td><td>\doteq</td><td>点等于</td></tr><tr class="odd"><td><span class="math inline">\(∼\)</span></td><td>\sim</td><td>相似于</td></tr><tr class="even"><td><span class="math inline">\(≃\)</span></td><td>\simeq</td><td>近似等于</td></tr><tr class="odd"><td><span class="math inline">\(≈\)</span></td><td>\approx</td><td>约等于</td></tr><tr class="even"><td><span class="math inline">\(≍\)</span></td><td>\asymp</td><td>趋于</td></tr><tr class="odd"><td><span class="math inline">\(≅\)</span></td><td>\cong</td><td>全等于</td></tr><tr class="even"><td><span class="math inline">\(≡\)</span></td><td>\equiv</td><td>恒等于</td></tr><tr class="odd"><td><span class="math inline">\(⊂\)</span></td><td>\subset</td><td>子集</td></tr><tr class="even"><td><span class="math inline">\(⊃\)</span></td><td>\supset</td><td>超集</td></tr><tr class="odd"><td><span class="math inline">\(⊆\)</span></td><td>\subseteq</td><td>子集或等于</td></tr><tr class="even"><td><span class="math inline">\(⊇\)</span></td><td>\supseteq</td><td>超集或等于</td></tr><tr class="odd"><td><span class="math inline">\(⊑\)</span></td><td>\sqsubseteq</td><td>方形子集或等于</td></tr><tr class="even"><td><span class="math inline">\(⊒\)</span></td><td>\sqsupseteq</td><td>方形超集或等于</td></tr><tr class="odd"><td><span class="math inline">\(∈\)</span></td><td>\in</td><td>包含于</td></tr><tr class="even"><td><span class="math inline">\(∋\)</span></td><td>\ni</td><td>包含</td></tr><tr class="odd"><td><span class="math inline">\(∉\)</span></td><td>\notin</td><td>不包含于</td></tr><tr class="even"><td><span class="math inline">\(⊨\)</span></td><td>\models</td><td>Models</td></tr><tr class="odd"><td><span class="math inline">\(⊢\)</span></td><td>\vdash</td><td>竖线短横</td></tr><tr class="even"><td><span class="math inline">\(⊣\)</span></td><td>\dashv</td><td>短横竖线</td></tr><tr class="odd"><td><span class="math inline">\(⊥\)</span></td><td>\perp</td><td>垂直</td></tr><tr class="even"><td><span class="math inline">\(∣\)</span></td><td>\mid</td><td>中线</td></tr><tr class="odd"><td><span class="math inline">\(∥\)</span></td><td>\parallel</td><td>平行</td></tr><tr class="even"><td><span class="math inline">\(∝\)</span></td><td>\propto</td><td>成比例</td></tr><tr class="odd"><td><span class="math inline">\(⋈\)</span></td><td>\bowtie</td><td>领结</td></tr><tr class="even"><td><span class="math inline">\(≺\)</span></td><td>\prec</td><td>先于</td></tr><tr class="odd"><td><span class="math inline">\(⪯\)</span></td><td>\preceq</td><td>先于等于</td></tr><tr class="even"><td><span class="math inline">\(≻\)</span></td><td>\succ</td><td>后于</td></tr><tr class="odd"><td><span class="math inline">\(⪰\)</span></td><td>\succeq</td><td>后于等于</td></tr><tr class="even"><td><span class="math inline">\(≮\)</span></td><td>\nless</td><td>不小于</td></tr><tr class="odd"><td><span class="math inline">\(≯\)</span></td><td>\ngtr</td><td>不大于</td></tr><tr class="even"><td><span class="math inline">\(⪇\)</span></td><td>\nleqslant</td><td>不小于等于</td></tr><tr class="odd"><td><span class="math inline">\(⪈\)</span></td><td>\ngeqslant</td><td>不大于等于</td></tr><tr class="even"><td><span class="math inline">\(≢\)</span></td><td>\not\equiv</td><td>不恒等于</td></tr><tr class="odd"><td><span class="math inline">\(≉\)</span></td><td>\not\approx</td><td>不约等于</td></tr><tr class="even"><td><span class="math inline">\(≇\)</span></td><td>\not\cong</td><td>不全等于</td></tr><tr class="odd"><td><span class="math inline">\(≁\)</span></td><td>\not\sim</td><td>不相似于</td></tr><tr class="even"><td><span class="math inline">\(≄\)</span></td><td>\not\simeq</td><td>不近似等于</td></tr><tr class="odd"><td><span class="math inline">\(⊭\)</span></td><td>\not\models</td><td>Not Models</td></tr><tr class="even"><td><span class="math inline">\(∌\)</span></td><td>\not\ni</td><td>不包含</td></tr><tr class="odd"><td><span class="math inline">\(⊁\)</span></td><td>\not\succ</td><td>不后于</td></tr><tr class="even"><td><span class="math inline">\(⪰̸\)</span></td><td>\not\succeq</td><td>不后于等于</td></tr><tr class="odd"><td><span class="math inline">\(⊀\)</span></td><td>\not\prec</td><td>不先于</td></tr><tr class="even"><td><span class="math inline">\(⪯̸\)</span></td><td>\not\preceq</td><td>不先于等于</td></tr><tr class="odd"><td><span class="math inline">\(∦\)</span></td><td>\not\parallel</td><td>不平行</td></tr><tr class="even"><td><span class="math inline">\(⊄\)</span></td><td>\not\subset</td><td>非子集</td></tr><tr class="odd"><td><span class="math inline">\(⊅\)</span></td><td>\not\supset</td><td>非超集</td></tr><tr class="even"><td><span class="math inline">\(⊈\)</span></td><td>\not\subseteq</td><td>非子集或等于</td></tr><tr class="odd"><td><span class="math inline">\(\not\supseteq\)</span></td><td>\not\supseteq</td><td>非超集或等于</td></tr></tbody></table><h2 id="箭头符号">箭头符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>名称</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(←\)</span></td><td>\leftarrow</td><td>左箭头</td></tr><tr class="even"><td><span class="math inline">\(⇐\)</span></td><td>\Leftarrow</td><td>左双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(⟵\)</span></td><td>\longleftarrow</td><td>长左箭头</td></tr><tr class="even"><td><span class="math inline">\(⟸\)</span></td><td>\Longleftarrow</td><td>长双线左箭头</td></tr><tr class="odd"><td><span class="math inline">\(→\)</span></td><td>\rightarrow</td><td>右箭头</td></tr><tr class="even"><td><span class="math inline">\(⇒\)</span></td><td>\Rightarrow</td><td>右双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(⟶\)</span></td><td>\longrightarrow</td><td>长右箭头</td></tr><tr class="even"><td><span class="math inline">\(⟹\)</span></td><td>\Longrightarrow</td><td>长双线右箭头</td></tr><tr class="odd"><td><span class="math inline">\(↔\)</span></td><td>\leftrightarrow</td><td>左右双向箭头</td></tr><tr class="even"><td><span class="math inline">\(⇔\)</span></td><td>\Leftrightarrow</td><td>左右双向双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(⟷\)</span></td><td>\longleftrightarrow</td><td>长左右双向箭头</td></tr><tr class="even"><td><span class="math inline">\(⟺\)</span></td><td>\Longleftrightarrow</td><td>长左右双向双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(↩\)</span></td><td>\hookleftarrow</td><td>弯钩左箭头</td></tr><tr class="even"><td><span class="math inline">\(↪\)</span></td><td>\hookrightarrow</td><td>弯钩右箭头</td></tr><tr class="odd"><td><span class="math inline">\(↽\)</span></td><td>\leftharpoondown</td><td>下半钩左箭头</td></tr><tr class="even"><td><span class="math inline">\(⇁\)</span></td><td>\rightharpoondown</td><td>下半钩右箭头</td></tr><tr class="odd"><td><span class="math inline">\(↼\)</span></td><td>\leftharpoonup</td><td>上半钩左箭头</td></tr><tr class="even"><td><span class="math inline">\(⇀\)</span></td><td>\rightharpoonup</td><td>上半钩右箭头</td></tr><tr class="odd"><td><span class="math inline">\(↑\)</span></td><td>\uparrow</td><td>上箭头</td></tr><tr class="even"><td><span class="math inline">\(⇑\)</span></td><td>\Uparrow</td><td>上双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(↓\)</span></td><td>\downarrow</td><td>下箭头</td></tr><tr class="even"><td><span class="math inline">\(⇓\)</span></td><td>\Downarrow</td><td>下双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(↕\)</span></td><td>\updownarrow</td><td>上下双向箭头</td></tr><tr class="even"><td><span class="math inline">\(⇕\)</span></td><td>\Updownarrow</td><td>上下双向双线箭头</td></tr><tr class="odd"><td><span class="math inline">\(↙\)</span></td><td>\swarrow</td><td>左斜下箭头</td></tr><tr class="even"><td><span class="math inline">\(↗\)</span></td><td>\nearrow</td><td>右斜上箭头</td></tr><tr class="odd"><td><span class="math inline">\(↖\)</span></td><td>\nwarrow</td><td>左斜上箭头</td></tr><tr class="even"><td><span class="math inline">\(↘\)</span></td><td>\searrow</td><td>右斜下箭头</td></tr><tr class="odd"><td><span class="math inline">\(↦\)</span></td><td>\mapsto</td><td>映射箭头</td></tr><tr class="even"><td><span class="math inline">\(⟼\)</span></td><td>\longmapsto</td><td>长映射箭头</td></tr></tbody></table><h2 id="括号符号">括号符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>名称</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(\lbrace\)</span></td><td>\lbrace</td><td>左花括号</td></tr><tr class="even"><td><span class="math inline">\(\rbrace\)</span></td><td>\rbrace</td><td>右花括号</td></tr><tr class="odd"><td><span class="math inline">\(\lbrack\)</span></td><td>\lbrack</td><td>左方括号</td></tr><tr class="even"><td><span class="math inline">\(\rbrack\)</span></td><td>\rbrack</td><td>右方括号</td></tr><tr class="odd"><td><span class="math inline">\(\langle\)</span></td><td>\langle</td><td>左尖括号</td></tr><tr class="even"><td><span class="math inline">\(\rangle\)</span></td><td>\rangle</td><td>右尖括号</td></tr><tr class="odd"><td><span class="math inline">\(\lceil\)</span></td><td>\lceil</td><td>左上半框括号</td></tr><tr class="even"><td><span class="math inline">\(\rceil\)</span></td><td>\rceil</td><td>右上半框括号</td></tr><tr class="odd"><td><span class="math inline">\(\lfloor\)</span></td><td>\lfloor</td><td>左下半框括号</td></tr><tr class="even"><td><span class="math inline">\(\rfloor\)</span></td><td>\rfloor</td><td>右下半框括号</td></tr><tr class="odd"><td><span class="math inline">\(\vert\)</span></td><td>\vert</td><td>竖线</td></tr><tr class="even"><td><span class="math inline">\(\Vert\)</span></td><td>\Vert</td><td>双竖线</td></tr><tr class="odd"><td><span class="math inline">\(\backslash\)</span></td><td>\backslash</td><td>反斜线</td></tr></tbody></table><h2 id="其他符号">其他符号</h2><table><thead><tr class="header"><th>符号</th><th>实现</th><th>名称</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(∞\)</span></td><td>\infty</td><td>无穷</td></tr><tr class="even"><td><span class="math inline">\(∃\)</span></td><td>\exists</td><td>存在</td></tr><tr class="odd"><td><span class="math inline">\(∀\)</span></td><td>\forall</td><td>任取</td></tr><tr class="even"><td><span class="math inline">\(¬\)</span></td><td>\neg</td><td>取反号</td></tr><tr class="odd"><td><span class="math inline">\(∇\)</span></td><td>\nabla</td><td>劈形</td></tr><tr class="even"><td><span class="math inline">\(△\)</span></td><td>\triangle</td><td>三角形</td></tr><tr class="odd"><td><span class="math inline">\(∠\)</span></td><td>\angle</td><td>角</td></tr><tr class="even"><td><span class="math inline">\(∂\)</span></td><td>\partial</td><td>偏导数</td></tr><tr class="odd"><td><span class="math inline">\(∅\)</span></td><td>\emptyset</td><td>空集</td></tr><tr class="even"><td><span class="math inline">\(\prime\)</span></td><td>\prime</td><td>质数</td></tr><tr class="odd"><td><span class="math inline">\(\colon\)</span></td><td>\colon</td><td>冒号</td></tr><tr class="even"><td><span class="math inline">\(ℜ\)</span></td><td>\Re</td><td>实部</td></tr><tr class="odd"><td><span class="math inline">\(ℑ\)</span></td><td>\Im</td><td>虚部</td></tr><tr class="even"><td><span class="math inline">\(\ldots\)</span></td><td>\ldots</td><td>下三连点</td></tr><tr class="odd"><td><span class="math inline">\(\cdots\)</span></td><td>\cdots</td><td>中三连点</td></tr><tr class="even"><td><span class="math inline">\(\vdots\)</span></td><td>\vdots</td><td>竖三连点</td></tr><tr class="odd"><td><span class="math inline">\(\ddots\)</span></td><td>\ddots</td><td>斜三连点</td></tr><tr class="even"><td><span class="math inline">\(\surd\)</span></td><td>\surd</td><td>不尽根号</td></tr><tr class="odd"><td><span class="math inline">\(\ldotp\)</span></td><td>\ldotp</td><td>句点</td></tr><tr class="even"><td><span class="math inline">\(→\)</span></td><td>\to</td><td>结论</td></tr><tr class="odd"><td><span class="math inline">\(←\)</span></td><td>\gets</td><td>条件</td></tr><tr class="even"><td><span class="math inline">\(ℵ\)</span></td><td>\aleph</td><td>Aleph</td></tr><tr class="odd"><td><span class="math inline">\(ℏ\)</span></td><td>\hbar</td><td>普朗克常数</td></tr><tr class="even"><td><span class="math inline">\(℘\)</span></td><td>\wp</td><td>手写体大写P</td></tr><tr class="odd"><td><span class="math inline">\(ℓ\)</span></td><td>\ell</td><td>手写体小写l</td></tr><tr class="even"><td><span class="math inline">\(ı\)</span></td><td>\imath</td><td>数学小写无点i</td></tr><tr class="odd"><td><span class="math inline">\(ȷ\)</span></td><td>\jmath</td><td>数学小写无点j</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Git】rebase</title>
      <link href="post/223e533f.html"/>
      <url>post/223e533f.html</url>
      
        <content type="html"><![CDATA[<p>目前最好的版本管理工具——Git的学习笔记。</p><p>Rebase，中文世界里常被称为「变基」，即<strong>改变基础</strong>。</p><a id="more"></a><h2 id="改变基础-git-rebase">改变基础 – git rebase</h2><p>什么叫基础呢？除了第一条默认分支 master 以外，其他分支都是在别的分支的某个 commit 之上发展而来的，如下图：</p><figure><img src="https://zhangbuhuai.com/image/rebase-1@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>图中，分支 experiment 是在 master 分支的 commit C2 的基础上发展而来的，故而认为 C2 的 experiment 分支的 base。</p><p>通过<code>git rebase</code>命令可以改变分支的 base，动手体验一下。 首先，按照上图创建了 git 工程，commit 和 branch 信息如下（通过 SourceTree 查看，使用<code>git log --graph --decorate</code>也可以看到类似效果）：</p><figure><img src="https://zhangbuhuai.com/image/rebase-2@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在执行rebase操作：</p><div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">git</span> checkout experiment</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">git</span> rebase master</span></code></pre></div><p>新的 commit 和 branch 信息如下：</p><figure><img src="https://zhangbuhuai.com/image/rebase-3@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>显然，分支 experiment 的 base 变成了 C3：</p><figure><img src="https://zhangbuhuai.com/image/rebase-4@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到：分支 experiment 中的 commits 都是新的，原来的 commits 都没了。</p><p>rebase 和 merge 操作非常类似，<a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing">Rebasing</a>里有详细说明。</p><p><code>git rebase</code>的基本使用姿势有两种<code>git rebase &lt;branch&gt;</code>和<code>git rebase &lt;SHA-1&gt;</code>。分支名<code>&lt;branch&gt;</code>说到底是指向某个 commit 的指针，<code>git rebase &lt;branch&gt;</code>将当前分支的 base 重设为<code>&lt;branch&gt;</code>所指向的 commit；<code>git rebase &lt;SHA-1&gt;</code>更直接一些，<code>&lt;SHA-1&gt;</code>指的是目标 commit 的 id。</p><p>演示一下<code>git rebase &lt;SHA-1&gt;</code>的使用示例：</p><figure><img src="https://zhangbuhuai.com/image/rebase-5@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在上图的基础上执行<code>git rebase 32aafcb</code>（32aafcb 是 C3 的 SHA-1 标识符），得到的结果如下：</p><figure><img src="https://zhangbuhuai.com/image/rebase-6@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到，分支 experiment 的 base 由 C2 变成了 C3。</p><p>延伸问题：什么情景下，使用 rebase 而不是 merge？</p><h2 id="重写历史-git-rebase--i">重写历史 git rebase -i</h2><p>加上<code>-i</code>参数可以在 rebase 过程中对某些 commit 进行编辑，这里的参数<code>-i</code>表示的是 interactive，换句话说，这是个交互式的命令。</p><p>常会使用到<code>git rebase -i &lt;SHA-1&gt;</code>进行 commit 操作，包括删除 commit、合并 commit。</p><h3 id="删除-commit">删除 commit</h3><p>有时候，我们想删掉某个 commit。</p><figure><img src="https://zhangbuhuai.com/image/rebase-7@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>假如想删掉 experiment 最新的 commit E3，执行<code>git rebase -i 4063139</code> (若要从第一次commit开始删除，可以 <code>git rebase -i --root</code> )，之后会进入可交互的 vim 编辑器，如下：</p><figure><img src="https://zhangbuhuai.com/image/rebase-8@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以对分支 experiment 上的每个 commit 进行精细控制：</p><ul><li>pick 是默认操作，啥都不干；</li><li>squash，删除分支，把更新内容合并到前一个分支，在下一步中会让重新编辑 previous commit 的 log message</li><li>fixup，和 squash 差不多，只是不会让重新编辑 previous commit 的 log message</li><li>drop，删除 commit</li></ul><p>这里需要删除 E3，因此修改第三行的 pick 为 drop，得到的结果如下：</p><figure><img src="https://zhangbuhuai.com/image/rebase-9@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以看到，分支 experiment 的最后一个 commit E3 不见了。需要说明的是，由于没有修改分支 experiment 的 base，所以 experiment 上的其他 commit 并未发生变化（相应的 SHA-1 不变）。</p><h3 id="合并-commit">合并 commit</h3><p>现在，我想在上面的基础上合并 experiment 的 commit E1 和 commit E2，仍然执行<code>git rebase -i 4063139</code>，进入 vim 编辑器：</p><figure><img src="https://zhangbuhuai.com/image/rebase-10@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>修改第二行的 pick 为 squash，保存后，Git 会让重新编辑 E1 的 log message 信息：</p><figure><img src="https://zhangbuhuai.com/image/rebase-11@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>这里直接把原来 E2 的 log message 给注释起来，只保留 E1 的 log message，保存，得到的结果如下：</p><figure><img src="https://zhangbuhuai.com/image/rebase-12@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>原来 E1 内容发生了变化，因此产生被产生的新 commit 被替换，SHA-1 由 682f3dd 变为了 56f1332。 P.S: 如果当前只有 master 分支呢？该如何删除 commit 和合并 commit 呢？一回事儿...</p><h2 id="当-rebase-遇到冲突">当 Rebase 遇到冲突</h2><p>上文示例不存在冲突问题，相对比较简单，但实际情况没有这么完美，往往有一些冲突需要解决。</p><p>在实际开发中，我经常会面对这么一种情景：基于 dev 分支创建一个需求分支，搞定后，提交 pr，同事 review pr 时会陆陆续续指出一些问题，针对同事的问题后续又在这个分支上提交若干个 pr，终于被认可；是时候合并到 dev 分支了，但是在此过程中，dev 分支发生了一些改变（新增了若干个 commit），导致 merge 冲突，有些冲突无法手动 merge（譬如 Xcode 的工程文件.pbxconfig，该文件记录了大量信息，根本无法手动 merged）。</p><p>针对这种问题，比较常见的做法是，更新本地 dev 分支，然后将需求分支 rebase 到最新的 dev 分支上，此处的 rebase 过程往往会需要处理一些冲突。</p><p>举个稍微复杂点的例子模拟 rebase 过程中的冲突问题：</p><div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co"># 创建仓库</span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">git</span> init</span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co"># 创建名为foo的文件，注入一行内容「created by master」</span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="fu">cat</span> <span class="op">&lt;&lt; EOF</span> <span class="op">&gt;</span> <span class="ex">foo</span></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>created by master</span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>EOF</span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a># master分支的第一个commit - C0</span><span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>git add foo; git commit -m &quot;C0&quot;</span><span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a># 创建一个名为experiment的分支</span><span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>git checkout -b experiment</span><span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a> </span><span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a># 修改foo，重新注入内容「modified by experiment, 1st」</span><span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>cat &lt;&lt; EOF &gt; foo</span><span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>modified by experiment, 1st</span><span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>EOF</span><span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a># experiment分支的第一个commit - E1</span><span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>git add foo; git commit -m &quot;E1&quot;</span><span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a># 修改foo，重新注入内容「modified by experiment, 2st」</span><span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>cat &lt;&lt; EOF &gt; foo</span><span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>modified by experiment, 2st</span><span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>EOF</span><span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a># experiment分支的第一个commit - E2</span><span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>git add foo; git commit -m &quot;E2&quot;</span><span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a> </span><span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a># 修改foo，重新注入内容「modified by experiment, 3s」，并添加一行「appended by experiment」</span><span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>cat &lt;&lt; EOF &gt; foo</span><span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>modified by experiment, 3st</span><span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>appended by experiment</span><span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a>EOF</span><span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a># experiment分支的第一个commit - E3</span><span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a>git add foo; git commit -m &quot;E3&quot;</span><span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a> </span><span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a># 切回master分支</span><span id="cb2-34"><a href="#cb2-34" aria-hidden="true"></a>git checkout master</span><span id="cb2-35"><a href="#cb2-35" aria-hidden="true"></a> </span><span id="cb2-36"><a href="#cb2-36" aria-hidden="true"></a># 修改foo，重新注入内容「modified by experiment, 3s」，并添加一行「appended by experiment」</span><span id="cb2-37"><a href="#cb2-37" aria-hidden="true"></a>cat &lt;&lt; EOF &gt; foo</span><span id="cb2-38"><a href="#cb2-38" aria-hidden="true"></a>final! modified by master</span><span id="cb2-39"><a href="#cb2-39" aria-hidden="true"></a>EOF</span><span id="cb2-40"><a href="#cb2-40" aria-hidden="true"></a># master分支的第一个commit - C1</span><span id="cb2-41"><a href="#cb2-41" aria-hidden="true"></a>git add foo; git commit -m &quot;C1&quot;</span></code></pre></div><p>创建两个分支：master 和 experiment。</p><p>master 分支的第一个 commit C0 创建一个文本文件 foo，并注入一行文本「created by master」；第二个 commit C1 修改了第一行的文本。 experiment 分支在 master 的 C0 的基础上创建，之后提交了 3 次 commit，第一次和第二次均只修改了第一行文本，第三个 commit 也修改了第一行文本，并且新增了第二行文本「appended by experiment」。</p><p>下图是更形象的描述：</p><figure><img src="https://zhangbuhuai.com/image/rebase-13@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在的目标是将 experiment 分支 rebase 到 master 的最新 commit C1 上，且 experiment 分支最终 commit 的 foo 内容为：</p><pre class="textile"><code>final! modified by masterappended by experiment</code></pre><p>执行命令：</p><pre class="textile"><code>git checkout experimentgit rebase master</code></pre><p>有如下警告：</p><pre class="textile"><code>First, rewinding head to replay your work on top of it...Applying: E1Using index info to reconstruct a base tree...M   fooFalling back to patching base and 3-way merge...Auto-merging fooCONFLICT (content): Merge conflict in fooerror: Failed to merge in the changes.Patch failed at 0001 E1The copy of the patch that failed is found in: .git/rebase-apply/patchWhen you have resolved this problem, run &quot;git rebase --continue&quot;.If you prefer to skip this patch, run &quot;git rebase --skip&quot; instead.To check out the original branch and stop rebasing, run &quot;git rebase --abort&quot;.</code></pre><p>错误信息说明：合并 E1 和 C1 时产生冲突，冲突点在文件 foo 上。</p><p>此时有 3 个选择：abort，continue、skip。</p><ul><li>abort，顾名思义，放弃该 rebase</li><li>continue，在此之前，用户需要手动解决 E1 和 C1 的冲突，然后<code>git rebase --continue</code>通过</li><li>skip，略过 E1，这意味着用户愿意放弃「E1 与 C1 冲突的 patch」</li></ul><p>我认为可以这么理解 rebase 的过程：若想将 experiment 分支 rebase 到 master 分支上，先在 master 的基础上创建一个临时分支（类似于变量，记为_experiment_），然后将 experiment 分支上的 commit 对应的 patch 逐个添加到到_experiment_的 index 上，如果完全没问题，就创建一个 commit，并移动_experiment_到该 commit 上...如果有冲突，则终止该过程，给出如上的警告信息，用户可以选择 abort；也可以选择 skip，如果是 skip，则意味着忽略掉冲突的内容，没有冲突的内容仍然保留在暂存区，但不会创建 commit，接着处理下一个 commit，直到结束；如果用户在过程中选择 continue，则意味着用户不愿放弃冲突的 commit，要想游戏继续，用户得自己手动将 conflict 给干掉。</p><p>如下是根据自己对 rebase 解决冲突问题的理解所写的伪代码：</p><div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>var _experiment_ = master.copy()  <span class="co">// 创建一个临时分支</span></span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="cf">for</span> (var commit in experiment.commits) &#123;</span><span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    var noConflict = YES</span><span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    var conflictFiles = []</span><span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span class="cf">for</span> (file in commit) &#123;</span><span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>        <span class="cf">if</span> (file.isOK) &#123;</span><span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>            <span class="co">// 将无冲突文件添加到暂存区</span></span><span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>            _experiment_.index.add(file)</span><span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>        &#125; <span class="cf">else</span> &#123;</span><span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>            <span class="co">// 标记冲突</span></span><span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>            noConflict = NO</span><span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>            <span class="co">// 缓存冲突文件</span></span><span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>            conflictFiles.add(file)</span><span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        &#125;</span><span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>    &#125;</span><span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>    <span class="cf">if</span> (noConflict) &#123;</span><span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        <span class="co">// 无冲突，创建新分支（根据commit的元信息，及暂存区的内容）</span></span><span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        var newCommit = createNewCommit(commit, _experiment_.index)</span><span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>        <span class="co">// 添加新分支</span></span><span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>        _experiment_.next = newCommit</span><span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>        <span class="co">// 移动_experiment_</span></span><span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>        _experiment_ = newCommit</span><span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>        <span class="co">// 清空index</span></span><span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>        _experiment_.index.clear()</span><span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>    &#125; <span class="cf">else</span> &#123;</span><span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>        <span class="co">// ... 将冲突报告给用户，等待处理</span></span><span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>        <span class="cf">if</span> (skip) &#123;  <span class="co">// 放弃current commit中的冲突文件，处理下一个commit</span></span><span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>            conflictFiles.clear()</span><span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a>            <span class="cf">continue</span>;</span><span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>        &#125; <span class="cf">else</span> <span class="cf">if</span> (<span class="cf">continue</span>) &#123;  <span class="co">// 用户选择continue，并且已经解决掉了conflictFiles中的文件冲突问题</span></span><span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>            <span class="co">// 将无冲突文件添加到暂存区</span></span><span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>            _experiment_.index.add(conflictFiles)</span><span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a>            <span class="co">// 创建新分支（根据commit的元信息，及暂存区的内容）</span></span><span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>            var newCommit = createNewCommit(commit, _experiment_.index)</span><span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>            <span class="co">// 添加新分支</span></span><span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>            _experiment_.next = newCommit</span><span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>            <span class="co">// 移动_experiment_</span></span><span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>            _experiment_ = newCommit</span><span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>            <span class="co">// 清空index</span></span><span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>            _experiment_.index.clear()</span><span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a>        &#125;</span><span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a>    &#125;</span><span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>&#125;</span></code></pre></div><p>总之，要完成上述示例所要达到的目标，可以这样：</p><div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">git</span> rebase master</span><span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">git</span> rebase --skip  # 忽略E1中的冲突文件</span><span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">git</span> rebase --skip  # 忽略E2中的冲突文件</span></code></pre></div><p>到最后一个 commit 了，不能再 skip 了，否则最终得到的 experiment 完全和 master 一致。现在开始手动解决 foo 冲突：</p><pre class="textile"><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 305b5e89276ff01a66760ea9c7e8d65950154b13final! modified by master=======modified by experiment, 3stappended by experiment&gt;&gt;&gt;&gt;&gt;&gt;&gt; E3 </code></pre><p>解决结果：</p><pre class="textile"><code>final! modified by masterappended by experiment</code></pre><p>然后：</p><div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">git</span> add *  # 不要忘了</span><span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">git</span> rebase --continue</span></code></pre></div><p>Game over!</p><figure><img src="https://zhangbuhuai.com/image/rebase-14@2x.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论6】模型训练</title>
      <link href="post/6aa0d565.html"/>
      <url>post/6aa0d565.html</url>
      
        <content type="html"><![CDATA[<p>为了保证DRL算法能够顺利收敛，policy性能达标并具有实用价值，结果有说服力且能复现，需要算法工作者在训练前、训练中和训练后提供全方位一条龙服务。GANs刚火起来的时候，因为训练难度高，有人在GitHub上专门开了repository，总结来自学术界和工业界的最新训练经验，各种经过或未经验证的tricks被堆砌在一起，吸引了全世界AI爱好者的热烈讨论，可谓盛况空前。在玄学方面，DRL算法训练有得一拼。但毕竟在科研领域没有人真的喜欢玄学，只有久经考验的一般化规律才能凝结成知识被更多的人接受和推广。本篇接下来的内容融合了许多参考资料，算是在DRL训练“去玄学”化上做出的一点微不足道的努力。</p><a id="more"></a><h2 id="训练开始前">训练开始前</h2><h3 id="环境可视化">环境可视化</h3><p>如果条件允许，开始训练前最好先可视化一个随机环境，观察是否会出现你希望的状态（即上一篇里的主线事件）。如果靠随机选择action都能以一定概率探索到目标状态，那说明该任务难度比较低，心里就可以更有底；如果从来不会出现目标状态，说明该任务难度较高，需要在状态空间和reward函数设计时特别下功夫，从而更好地引导agent向目标状态前进。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225210423.png" /></p><h3 id="数据预处理">数据预处理</h3><p>你还可以实时打印出state和reward，看看它们是否在合理范围内取值，是否存在幅值过大的情况，如果是则需要增加必要的归一化操作。事实上，我推荐无条件进行状态空间归一化和reward rescale &amp; clipping，实践证明这两个操作无论在收敛速度还是最终性能上都会带来明显提升。前一个操作很好理解，我只介绍一下reward rescale &amp; clipping，该操作尤其适合基于episode的A3C/A2C/PPO算法，参考形式为 <span class="math inline">\(r=clip(r/(std(Return)+\epsilon ),-10,10)\)</span> ，其中 <span class="math inline">\(Return = \sum\limits_{t=0}^{T} \gamma^{t}r_{t}\)</span> ，是一段episode内reward的折扣累加和，也就是V网络拟合的对象，而V网络输出又为policy优化提供参考，使用该值的统计方差对reward进行rescale，可以反过来有效降低Return的variance，有助于V网络和policy网络进行更加无偏地学习。训练过程中通常采用Return的running std来rescale当前reward。最外层的clip操作可以滤除那些绝对值过大的reward，作用类似。</p><p><strong>注意reward只能进行rescale，而不能整体平移（减去均值）</strong>。回报函数中各项reward的符号以及它们之间的相对大小唯一确定了回报函数的实际功能，各项reward的整体缩放对其没有影响，但整体平移会改变这种相对大小，也就改变了回报函数的功能。事实上，哪怕是clip操作也在一定程度上存在这种问题，但通常影响不大。</p><h2 id="训练进行中">训练进行中</h2><h3 id="拥抱不确定性">拥抱不确定性</h3><p>终于要开始调参了！如果你做过CV项目，会发现相对来说DRL训练的不确定性更高，可复现性更差。这是因为DRL算法不仅超参数多，而且对它们非常敏感，这里贴张图给大家感受一下。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225210852.png" /></p><p>上图是三个DRL算法（纵向）在五个Atari游戏（横向）中的得分随学习率变化的趋势。可以看到，以10倍为单位，高性能所对应的学习率区间普遍很窄，要达到最优性能真得靠地毯式搜索。其实原作者本意是想通过这张图表明他们的方法对超参数变化抵抗力较好……，况且这还只是针对学习率这一个超参数。</p><p>当我们刚开始尝试用DRL算法解决一个全新问题时，性能好坏甚至都是其次，能否收敛才是最关键的。大佬OpenAI Five都有所耳闻吧？其团队成员在接受采访时承认，他们第一次将训练跑起来后因为心里实在没底，干脆全体度假去了，回来后打开屏幕发现竟然收敛了，上帝保佑！</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225211559.png" /></p><p>尽管DRL对超参数如此敏感，也没有必要过分悲观。当我们在心理上接受了这一事实，并开始潜心研究时，就会发现DRL训练还是有迹可循的，尤其是随着实际经验的积累和对算法本质理解的不断深入，将每个超参数的作用都了然于胸，那么训练出优秀policy的可能性就会大很多。接下来我以DQN，DDPG和PPO为例，介绍一下其中的主要超参数和调参技巧。</p><h3 id="drl通用超参数">DRL通用超参数</h3><p>有些超参数不是某个算法所特有，而是DRL普遍使用的，而且作用原理和设置依据都差不多，我放到最前面集中介绍。典型的通用超参数包括折扣因子、网络结构和学习率。</p><h4 id="折扣因子">折扣因子</h4><p><strong>1.作用原理</strong></p><p>折扣因子通常以符号γ表示，在强化学习中用来调节近远期影响，即agent做决策时考虑多长远，取值范围 <span class="math inline">\((0,1]\)</span> 。 <span class="math inline">\(\gamma\)</span> 越大agent往前考虑的步数越多，但训练难度也越高；<span class="math inline">\(\gamma\)</span> 越小agent越注重眼前利益，训练难度也越小。我们都希望agent能“深谋远虑”，但过高的折扣因子容易导致算法收敛困难。还以小车导航为例，由于只有到达终点时才有奖励，相比而言惩罚项则多很多，在训练初始阶段负反馈远多于正反馈，一个很高的折扣因子（如0.999）容易使agent过分忌惮前方的“荆棘丛生”，而宁愿待在原地不动；相对而言，一个较低的折扣因子（如0.9）则使agent更加敢于探索环境从而获取抵达终点的成功经验；而一个过低的折扣因子（如0.4），使得稍远一点的反馈都被淹没了，除非离终点很近，agent在大多数情况下根本看不到“光明的未来”，更谈不上为了抵达终点而努力了。</p><p><strong>2.选取方法</strong></p><p>总之，<strong>折扣因子的取值原则是，在算法能够收敛的前提下尽可能大</strong>。在实践中，有个经验公式 <span class="math inline">\(1/(1-\gamma)\)</span> ，可以用来估计agent做决策时往前考虑的步数。根据对特定任务的分析，合理选择 <span class="math inline">\(\gamma\)</span> 值，避免“近视”和“远视”。比如可以根据观察或统计agent到达终点所需的步数分布，选择合适的步数使得agent在该步数内的探索下有一定概率到达终点（正样本），注意这个概率越高训练难度就越小，然后利用经验公式把该步数换算成 <span class="math inline">\(\gamma\)</span> 即可。</p><p><strong>3.Frame Skipping</strong></p><p>上述折扣因子的选择方法并非无往不利，有时我们会面临这样的窘境：无法设置合理的γ在“近视”和“远视”间找到满意折中，常见于“细粒度”复杂任务。复杂决定了agent需要看得很远才能做出合理决策，而“细粒度”指agent决策间隔很短以至于一段较长的episode只对应较少的agent状态变化。仍以小车导航为例，0.1s的决策间隔显然满足了实时防碰撞的机动性要求，但也大大延长了episode长度，即到达终点所需步数。如果agent平均需要 <span class="math inline">\(1min\)</span> 才能到达终点，那就要求向前考虑 <span class="math inline">\(1min/0.1s=600\)</span> 步，按照经验公式计算合理的折扣因子 <span class="math inline">\(\gamma \approx 1-1/600=0.998\)</span> ，如此高的折扣因子+如此长的episode，训练难度可想而知。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225211751.png" /></p><p>假如我们在保证足够机动性的前提下适当延长决策间隔，比如0.5s，中间4帧重复上一次决策的action不变，相当于跳了几帧达到“快进”效果，从而使episode长度大大缩短，训练难度也直线下降，即使采用较高折扣因子也能顺利收敛。通过这个例子我们也可以知道，<strong>在DRL中agent“看得远”表面上指的是向前考虑的步数多，实质上是指agent向前考虑的系统动态演化跨度大</strong>。</p><h4 id="网络结构">网络结构</h4><p>DRL算法中的网络结构也属于超参数，然而与CV任务不同，DRL绝不应该片面追求网络的复杂化，否则你会发现训练根本无法收敛。对于网络结构的选择，DRL有自己的规矩——<strong>契合状态，够用就好</strong>。前者针对网络类型，后者针对网络深度。</p><p><strong>1.网络类型</strong></p><p>网络类型的选择主要取决于状态空间设计，如果状态信息是向量式的，即一组拉成一维的标量，比如位置、角度、速度等，那就适合采用全连接（MLP）网络；如果状态信息是imagelike的，比如图像，或者其他以二维形式重组的信息，就适合采用卷积神经网络（CNN）。实际应用中往往同时包含这两种状态信息，因此网络类型也可以既有CNN也有MLP，处理完各自对应的输入信息后，在高层通过concat操作汇集在一起，再通过若干层全连接，最后输出action或Q/V值。</p><p>对于on-policy算法，episode形式的数据天然适合采用RNN来挖掘更多时序信息，但同时也会显著提高训练难度，用与不用取决于决策对时序相关性的依赖程度。换句话说，如果之前的经验对当前决策很有参考意义（比如Dota）就适合用RNN，反之仅依靠即时信息做应激式决策就足以应付就没必要用RNN。实践中经常采取折中方案，将最近几个step的原始状态信息叠加到一起作为当前时刻的实际状态信息输入policy，既可以挖掘一定范围内的时序信息，又避免增加训练难度。</p><p><strong>2.网络深度</strong></p><p>至于网络深度，千万不要认为越深越好，虽然深层网络的表征能力更强，但训练难度非常高，更适合有监督训练。DRL算法由于数据效率低下又缺乏直接监督信号，并不擅长以end-to-end的方式训练过深的网络，如果还同时采用了RNN结构，那就是相当不擅长了。除非你有DeepMind或OpenAI那样的硬件资源，否则还是现实点好。其实多读几篇DRL方向的paper就会发现，所谓deep往往只是2-3层MLP或4-5层CNN，虚张声势的背后就是这么知趣。</p><p>当然，如果任务逻辑和状态信息确实非常复杂，浅层网络不足以提供所需的特征提取和加工能力，那么可以考虑适当加深网络，但仍应以够用为准则，不可矫枉过正。我曾经试过把已经work的3层MLP改成10层，发现根本就不收敛或收敛极慢，后来在各层中加了类似ResNet的跳线，勉强收敛，但相同训练量下性能还不如3层网络。如果输入状态信息是ImageNet那样的自然图像，可以像视觉检测应用那样，先用有监督方式预训练一个backbone，然后再放到DRL里finetune。</p><h4 id="学习率">学习率</h4><p>从整个AI技术来看，学习率是如此的平淡无奇，相关调参技巧早就被研究透了。毕竟DRL算法里的学习率也遵循同样的基本法——大了收敛快，稳定性差，且后期影响性能；小了收敛慢，浪费时间。学习率常用的淬火操作也同样可以应用到DRL中。当然，对于不同DRL算法而言，学习率也可能有各自的特点，如有必要，我会在下文介绍DRL特色超参数的时候顺带多说几句。</p><h3 id="drl特色超参数">DRL特色超参数</h3><h4 id="dqn">DQN</h4><p>DQN的特色超参数主要有：buffer size，起始训练时间，batchsize，探索时间占比，最终epsilon，目标网络更新频率等。</p><p>Buffer size指的是DQN中用来提高数据效率的replay buffer的大小。通常取 <span class="math inline">\(1e6\)</span> ，但不绝对。Buffer size过小显然是不利于训练的，replay buffer设计的初衷就是为了保证正样本，尤其是稀有正样本能够被多次利用，从而加快模型收敛。对于复杂任务，适当增大buffer size往往能带来性能提升。反过来过大的buffer size也会产生负面作用，由于标准DQN算法是在buffer中均匀采集样本用于训练，新旧样本被采集的概率是相等的，如果旧样本或者无效样本在buffer中存留时间过长，就会阻碍模型的进一步优化。总之，合理的buffer size需要兼顾样本的稳定性和优胜劣汰。顺便说一句，针对“等概率采样”的弊端，学术界有人提出了prioritized replay buffer，通过刻意提高那些loss较大的transition被选中的概率，从而提升性能，这样又会引入新的超参数，这里就不做介绍了。</p><p>起始训练时间的设置仅仅是为了保证replay buffer里有足够的数据供二次采样，因此与batchsize有直接关系，没啥可说的。Batchsize指的是从replay buffer中二次采样并用于梯度计算的batch大小，和CV任务中的设定原则基本一致，即兼顾训练稳定性和训练速度，也没啥好说的。</p><p>探索时间占比和最终 <span class="math inline">\(\epsilon\)</span> 共同决定了DQN探索和利用的平衡。ε-greedy策略在训练开始的时候，随机选择action的概率 <span class="math inline">\(\epsilon=1\)</span> ，探索力度最大；随着训练进行ε逐渐线性下降直至达到最终epsilon保持恒定，之后DQN的训练将以利用为主而只保留少量探索。因此，最终 <span class="math inline">\(\epsilon\)</span> 取值在区间 <span class="math inline">\([0,1]\)</span> 内靠近0的一端。探索时间占比指的是 <span class="math inline">\(\epsilon\)</span> 从1下降到最终 <span class="math inline">\(\epsilon\)</span> 的时间占总训练时间的比例，在 <span class="math inline">\((0,1)\)</span> 内取值，用来调节以探索为主到以利用为主的过渡。通常来说，复杂任务的探索时间占比应设得大一些，以保证充分的探索；最终 <span class="math inline">\(\epsilon\)</span> 不宜过大，否则影响模型最终阶段“好上加好”的性能冲刺，因为最好的状态往往是在足够好的Q网络指导下才能探索到的，训练后期过强的探索干扰了习得知识的利用，也就阻碍了性能的进一步提升。</p><p>标准DQN引入了一个延迟更新的目标网络用来计算Q的目标值，避免Q网络误差的“自激效应”，并借此来提高训练稳定性。目标网络更新频率就是用来控制这个延迟程度的，时间到了就把Q网络的参数整个复制过来。通常情况下根据具体问题，参考Q网络的更新周期设定，比如Q网络每1个step更新一次，目标Q网络可以设定每500个step更新一次。</p><h4 id="ddpg">DDPG</h4><p>DDPG的特色超参数主要包括：buffer size，batchsize，目标网络软更新参数τ，探索噪声等。其中很多超参数与DQN类似，比如buffer size和batchsize，这里就不重复介绍了。</p><p>DDPG也使用了目标网络（目标Q网络和目标Policy网络）稳定训练，不同的是DDPG的目标网络与主网络更新频率相同，稳定效果来自于软更新（soft-update），即 <span class="math inline">\((1-\tau)*target + \tau*main\)</span> ，<span class="math inline">\(\tau\)</span> 取很小的值（DDPG paper中建议0.001）限制每次更新的幅度。</p><p>DDPG值得特别介绍的是探索噪声及其参数。由于policy网络输出确定性action，DDPG的探索依靠在输出action空间叠加噪声来实现。可选的噪声类型主要包括Gaussian噪声和DDPG paper推荐的ou噪声（Ornstein-Uhlenbeck），后者相对于前者主要是增加了噪声强度逐渐衰减的功能。这两种噪声的主要参数是噪声方差，方差越大探索力度越强。虽然论文推荐使用ou噪声，但我在实践中发现ou噪声并不一定比Gaussian噪声效果好，还是要看具体任务。</p><p>后来DeepMind又提出了adaptive parameter noise，抛弃了在输出层叠加噪声的方法，转而采用在policy网络靠近输出的若干层网络参数上叠加噪声，优点是探索更充分，毕竟参数噪声的影响范围更大，而且可以根据实际情况自适应调节探索力度。类似地，我发现参数噪声在有些任务上效果不错，但在另一些任务中不如传统噪声。综上所述，关于不同噪声的优劣没有确定性结论（局限于我的个人经验），具体选择哪种噪声，还要实际试过才知道。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225211849.png" /></p><p>此外，值得一提的是Q网络和policy网络采用了不同的学习率，且一般Q网络的学习率比policy网络大一个数量级，比如前者用 <span class="math inline">\(1e-3\)</span> ，后者用 <span class="math inline">\(1e-4\)</span> 。这样做的原因是，用于更新policy网络的梯度完全来自于Q网络，两者地位不是对等的。</p><h4 id="ppo">PPO</h4><p>作为on-policy方法，PPO与前两种DRL框架有很大不同，无论是算法原理还是超参数设置。PPO的特色超参数包括：采样环境数量，episode长度，entropy系数，V网络系数，GAE factor，PPO cliprange等。</p><p>并行采样的环境数量越多，整体的探索效率越高，绝对收敛时间越快，该参数的设置主要取决于可用的硬件资源。</p><p>PPO的训练基于episode（或trajectory），将其中每个中间state到episode结束时的Return作为目标值拟合一个V网络，并用V网络作为baseline指导policy网络的更新。为了便于训练，通常每个环境都采集固定长度的episode并返回主进程中拼成一个batch。Episode越长，每次计算梯度时的数据量越大，但消耗内存也越多。Episode长度通常取4096, 2048, 1024等2的次幂，原因是更新网络参数时整个batch还会再分成minibatch（2的次幂比较好分），遍历若干个epoch，从而提高数据利用率，注意minibatch不能太大，否则有可能导致“学不动”的现象。在实际应用中，除了考虑内存开销，episode长度选取也跟任务难度息息相关。以小车导航为例，训练刚开始时agent可能需要探索很久才能幸运地抵达终点，episode长度最好能囊括整个探索过程，这样中间状态与理想状态（到终点）间的演进关系就很容易学习到。当然，episode不可能无限长，如果探索难度实在太高，那也只好提前终止探索，把截断的部分放到下一个episode中。</p><p>PPO算法的loss由三部分组成：policy loss，value loss和entropy loss。其中entropy loss项的系数是一个非常重要的超参数，对收敛速度和最终性能有直接影响。我在算法选择篇介绍PPO的探索-利用平衡时，说过随着训练进行policy输出的action分布的variance会越来越小，反映到统计指标上就是entropy越来越小。这本来是一个自然发生的过程，不需要人的干预，然而DRL训练早期往往受到各种local minima的干扰，容易陷入“拣了芝麻丢了西瓜”的怪圈。为了避免模型过早迷失方向，PPO加入了entropy loss用于强迫policy输出不那么“尖锐”的action分布，从而起到加强探索的效果。Entropy系数负责调节这种“强迫”力度，合理的系数既能确保训练早期充分探索从而使模型向正确方向前进，又能使模型在训练中后期充分利用学到的技能从而获得高性能。对于不同任务，最优entropy系数往往各不相同，需要若干次试错才能找到。比如在训练开始后policy entropy快速下降说明模型陷入了局部最优，根本没学到有用技能，这时就应该提升entropy系数；如果训练很长时间policy entropy仍然未下降或者下降缓慢，说明模型探索过头了，学到的知识被随机性淹没，无法进一步用来提升性能，此时应该适当降低entropy系数。</p><p>V网络系数是PPO loss中value loss项的系数，通常取0.5（policy loss系数默认是1），在实践中不太需要修改。</p><p>由于on-policy算法对数据的使用方式是“<strong>现采现用，用完就扔</strong>”。为了防止policy跑偏，在错误道路上越走越远，需要通过特定方法限制其每次参数更新的幅度。PPO与更早的TRPO类似，核心思想都是针对更新前后policy输出的KL散度设定阈值，但PPO通过一个简单的clip操作大大简化了运算，兼顾了效率和性能。PPO相关的参数主要是cliprange，通常取略大于0的小数，代表使policy更新前后KL散度控制在1-cliprange到1+cliprange之间，超出该范围的梯度直接被忽略（相当于对应数据被弃用）。Cliprange越小训练越稳定，越大越节省数据。一般在训练早期取较小的值，比如0.2，保证训练平稳进行；到训练后期可以适当放大，因为此时policy已经足够优秀，所采集数据中正样本比例非常高，可以放心利用。此外，PPO使用了GAE来估计advantage，相应增加了一个超参数GAE factor，用于在bias和variable之间寻求平衡，也是在(0,1]内取值，一般都默认取0.95。</p><h3 id="给drl初学者的建议">给DRL初学者的建议</h3><p><strong>以热门平台作为切入点</strong>。热门平台维护频率高，关注度高，遇到问题容易找到解决方案。比如在OpenAI Gym平台上找些简单的任务多练手，baselines里提供了大量参考代码。使用现成代码训练的最大好处是可以排除bug的干扰，把注意力都放在调参上，这对于初学者非常重要。</p><p><strong>不要迷信默认超参数。</strong>在实际应用中可以先采用参考代码里的默认超参数，但一定要记住它们不是万能的。可以用tensorboard显示出各种训练曲线，理解其中主要曲线的含义和作用，并根据这些曲线判断超参数设置是否合理，应该朝哪个方向调整。</p><p><strong>重视首次成功经验，学会简化问题</strong>。实践多了你会发现，对于特定Domain和特定算法，最优超参数组合分布都各有特点，最困难也最关键的是首次训练，一旦有了成功经验，后续根据观察结果做些微调就能得到高性能模型了。如果原任务训练难度太高，可以先尝试做适当简化，待成功收敛后再逐渐恢复任务难度。比如要实现任务目标A，必须满足条件B,C,D…，可以先暂时去掉对C,D,…的要求，只保留B，这样探索到A的概率就会显著提升，算法训练难度直线下降，待算法收敛并获得一定的经验后再逐步恢复所有条件。</p><p><strong>保持耐心。</strong>DRL训练本来就挺慢的，很多时候除了等待什么都不用做。除非你对相关Domain的算法训练流程已经很熟悉，否则不要轻易断定算法不收敛，可以等等再说。也不要整天一动不动地盯着屏幕发呆，既浪费时间，更浪费生命，间歇式检查一下就好。</p><h2 id="训练收敛后">训练收敛后</h2><p>当你发现policy已经可以如预期的那样完成任务了，先不要忙着喜形于色，你还需要做些检查和分析工作以确保policy性能达到了最优。以A3C为例，你至少应该：</p><ol type="1"><li><p><strong>观察Value网络对Returns拟合的精度如何，value loss是否还有进一步下降的空间？</strong></p><p>Value网络越精确，由其计算得到的advantage越有意义，也就越有利于policy的优化。注意精度和loss都是相对概念，与reward函数中各项的绝对值息息相关。一般说来，在DRL中对reward进行等比例缩放不会改变policy的最终特性，即 <span class="math inline">\((+10,-2,-1,-0.5)\)</span> 与 <span class="math inline">\((+100,-20,-10,-5)\)</span> 的作用是一样的，但体现在value loss上就差了10倍。对拟合精度更可靠的评估标准是explained variance，计算公式是 <span class="math inline">\(1-Var(return-value)/Var(return)\)</span> 取值区间 <span class="math inline">\((-\infty,1]\)</span> ，该值越接近1说明拟合精度越高。建议训练过程中将该值实时打印到tensorboard中，并不断监测Value网络的质量。</p></li><li><p><strong>观察entropy是否处在合理范围内，相对于action维度是否过高或过低？</strong></p></li></ol><p>假如policy输出10维categorical分布，其entropy有两种极端情况：(1) 完全随机，每个维度概率均为0.1，此时entropy最大等于 <span class="math inline">\(10*[-0.1*log(0.1)]=2.3\)</span> ；(2) 完全确定，其中一维为1.0其余都是0.0，此时entropy最小等于0。整个训练过程，entropy从2.3开始逐渐下降，当训练收敛后，entropy应该稳定在较低水平。如果太高则说明policy对决策信心不足，如果不是任务本身太复杂那就是entropy系数过大造成的，应该适当降低该系数增加exploitation的力度，很有可能继续提升模型性能。当然，entropy很少能降到0，除非是极其简单的任务。</p><h2 id="总结">总结</h2><p>经过前后近一个月零零星星的整理，这篇又臭又长的训练篇终于快要结束了，连我自己都觉得枯燥透顶，如果有哪位读者能坚持读到这里，我敬你是个勇士！我也时常怀疑写这些东西到底有没有意义，毕竟包括DRL在内的深度学习调参技巧往往琐碎而不成体系，很难总结得面面俱到，更何况新算法还在源源不断地涌现，旧的知识经验正在迅速“贬值”，就像现在有了Soft Actor-Critic，谁还用DDPG啊。最重要的是，假如读者不经过亲身实践，直接看这些干巴巴的总结，作用真心不大。对我自己来说，就权当备忘吧~</p><p>事实上，当你通过广泛阅读和动手实践，对各种DRL算法原理有了深入理解，对各种超参数的作用了然于胸，自然而然就会形成自己的调参方法论。只要算法收敛，性能达标，项目验收，调参的细节没那么重要。此外，调参工作毕竟只停留在“术”的层面，而我们应该追求的是算法之“道”，孰轻孰重每个人都要心里有数。祝愿每一个算法工程师最终都能做到“<strong>调尽千参，心中无参</strong>”。</p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python编程】GUI编程tkinter基础，并实现一个目录树遍历工具</title>
      <link href="post/56c2233b.html"/>
      <url>post/56c2233b.html</url>
      
        <content type="html"><![CDATA[<p>本文将对图形用户界面（Graphical User Interface，GUI）编程进行简要的介绍。我们将主要使用的GUI 工具包是Python 默认的GUI 库Tk，通过Python 的接口tkinter（“Tk interface”的缩写）可以访问Tk。 Tk 并不是最新和最好的，也没有包含最强大的GUI 构建模块集，但是它足够易用，你可以使用它构建能够运行在大多数平台下的GUI。</p><a id="more"></a><h2 id="引言">引言</h2><h3 id="tcltk和tkinter">Tcl、Tk和tkinter</h3><p>tkinter 是Python 的默认GUI 库。它基于Tk工具包，该工具包最初是为工具命令语言（Tool Command Language，Tcl）设计的。Tk 普及后，被移植到很多其他的脚本语言中，包括Perl（Perl/Tk）、Ruby（Ruby/Tk）和Python（tkinter）。结合Tk 的GUI 开发的可移植性与灵活性，以及与系统语言功能集成的脚本语言的简洁性，可以让你快速开发和实现很多与商业软件品质相当的GUI 应用。</p><h3 id="安装和使用tkinterpython3">安装和使用tkinter（python3）</h3><p>tkinter 在系统中不是默认必须安装的，可以通过在Python 解释器中尝试导入Tkinter 模块（Python 1 和2 版本，在Python 3 中重命名为tkinter）来检查Tkinter 是否可用。</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="im">import</span> tkinter</span></code></pre></div><h2 id="tkinter和python编程">tkinter和python编程</h2><h3 id="tkinter模块添加tk到应用中">tkinter模块：添加Tk到应用中</h3><p>为了让tkinter 成为应用的一部分，你需要做些什么呢？让GUI 程序启动和运行起来需要以下5 个主要步骤：</p><ol type="1"><li>导入Tkinter 模块（或from Tkinter import *）。</li><li>创建一个顶层窗口对象，用于容纳整个GUI 应用。</li><li>在顶层窗口对象之上（或者“其中”）构建所有的GUI 组件（及其功能）。</li><li>通过底层的应用代码将这些GUI 组件连接起来。</li><li>进入主事件循环。</li></ol><h3 id="gui-编程介绍">GUI 编程介绍</h3><p>创建一个GUI 应用就像艺术家作画一样。必须在搭建起画架之后，才能把画布拼装在上面。在tkinter 中，这个“画架”基础称为<strong>顶层窗口对象</strong>。</p><h4 id="窗口和控件">窗口和控件</h4><p>在GUI 编程中，顶层的根窗口对象包含组成GUI 应用的所有小窗口对象。它们可能是文字标签、按钮、列表框等。这些独立的GUI 组件称为控件。所以当我们说创建一个顶层窗口时，只是表示需要一个地方来摆放所有的控件。在Python 中，一般会写成如下语句。</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>top <span class="op">=</span> tkinter.Tk() <span class="co"># or just Tk() with &quot;from Tkinter import *&quot;</span></span></code></pre></div><p>tkinter.Tk()返回的对象通常称为根窗口，这也是一些应用使用root 而不是top 来指代它的原因。顶层窗口是那些在应用中独立显示的部分。GUI 程序中可以有多个顶层窗口，但是其中只能有一个是根窗口。可以选择先把控件全部设计好，再添加功能；也可以边设计控件边添加功能（这意味着上述步骤中的第3 步和第4 步会混合起来做）。</p><p>控件可以独立存在，也可以作为容器存在。如果一个控件包含其他控件，就可以将其认为是那些控件的父控件。相应地，如果一个控件被其他控件包含，则将其认为是那个控件的子控件，而父控件就是下一个直接包围它的容器控件。</p><p>通常，控件有一些相关的行为，比如按下按钮、将文本写入文本框等。这些用户行为称为事件，而GUI 对这类事件的响应称为回调。</p><h4 id="事件驱动处理">事件驱动处理</h4><p>事件可以包括按钮按下（及释放）、鼠标移动、敲击回车键等。一个GUI 应用从开始到结束就是通过整套事件体系来驱动的。这种方式称为事件驱动处理。最简单的鼠标移动就是一个带有回调的事件的例子。假设鼠标指针正停在GUI 应用顶层窗口的某处。如果你将鼠标移动到应用的另一部分，鼠标移动的行为会被复制到屏幕的光标上，于是看起来像是根据你的手移动的。系统必须处理的这些鼠标移动事件可以绘制窗口上的指针移动。当释放鼠标时，不再有事件需要处理，此时屏幕会重新恢复闲置的状态。</p><p>事件驱动的GUI 处理本质上非常适合于客户端/服务端架构。当启动一个GUI 应用时，需要一些启动步骤来准备核心部分的执行，就像网络服务器启动时必须先分配套接字并将其绑定到本地地址上一样。GUI 应用必须先创建所有的GUI 组件，然后将它们绘制在屏幕上。这是布局管理器（geometry manager）的职责所在。当布局管理器排列好所有控件（包括顶层窗口）后，GUI 应用进入其类似服务器的无限循环。这个循环会一直运行，直到出现GUI 事件，进行处理，然后再等待更多的事件去处理。</p><h4 id="布局管理器">布局管理器</h4><p>Tk 有3 种布局管理器来帮助控件集进行定位。最原始的一种称为Placer。它的做法 非常直接：你提供控件的大小和摆放位置，然后管理器就会将其摆放好。问题是你必须对所有控件进行这些操作，这样就会加重编程开发者的负担，因为这些操作本应该是自动完成的。</p><p>第二种布局管理器会是你主要使用的，它叫做Packer，这个命名十分恰当，因为它会把控件填充到正确的位置（即指定的父控件中），然后对于之后的每个控件，会去寻找剩余的空间进行填充。这个处理很像是旅行时往行李箱中填充行李的过程。</p><p>第三种布局管理器是Grid。你可以基于网格坐标，使用Grid 来指定GUI 控件的放置。Grid 会在它们的网格位置上渲染GUI 应用中的每个对象。本章将使用Packer。</p><p>一旦Packer 确定好所有控件的大小和对齐方式，它就会在屏幕上将其放置妥当。</p><p>当所有控件摆放好后，可以让应用进入前述的无限主循环中。在Tkinter 中，代码如下所示。</p><div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>tkinter.mainloop()</span></code></pre></div><p>一般这是程序运行的最后一段代码。当进入主循环后，GUI 就从这里开始接管程序的执行。所有其他行为都会通过回调来处理，甚至包括退出应用。当选择File 菜单并单击Exit 菜单选项，或者直接关闭窗口时，就会调用一个回调函数来结束这个GUI 应用。</p><h3 id="tk控件">Tk控件</h3><table><thead><tr class="header"><th>控 件</th><th>描 述</th></tr></thead><tbody><tr class="odd"><td>Button</td><td>与Label 类似，但提供额外的功能，如鼠标悬浮、按下、释放以及键盘活动/事件</td></tr><tr class="even"><td>Canvas</td><td>提供绘制形状的功能（线段、椭圆、多边形、矩形），可以包含图像或位图</td></tr><tr class="odd"><td>Checkbutton</td><td>一组选框，可以勾选其中的任意个（与HTML 的checkbox 输入类似）</td></tr><tr class="even"><td>Entry</td><td>单行文本框，用于收集键盘输入（与HTML 的文本输入类似）</td></tr><tr class="odd"><td>Frame</td><td>包含其他控件的纯容器</td></tr><tr class="even"><td>Label</td><td>用于包含文本或图像</td></tr><tr class="odd"><td>LabelFrame</td><td>标签和框架的组合，拥有额外的标签属性</td></tr><tr class="even"><td>Listbox</td><td>给用户显示一个选项列表来进行选择</td></tr><tr class="odd"><td>Menu</td><td>按下Menubutton 后弹出的选项列表，用户可以从中选择</td></tr><tr class="even"><td>Menubutton</td><td>用于包含菜单（下拉、级联等）</td></tr><tr class="odd"><td>Message</td><td>消息。与Label 类似，不过可以显示成多行</td></tr><tr class="even"><td>PanedWindow</td><td>一个可以控制其他控件在其中摆放的容器控件</td></tr><tr class="odd"><td>Radiobutton</td><td>一组按钮，其中只有一个可以“按下”（与HTML 的radio 输入类似）</td></tr><tr class="even"><td>Scale</td><td>线性“滑块”控件，根据已设定的起始值和终止值，给出当前设定的精确值</td></tr><tr class="odd"><td>Scrollbar</td><td>为Text、Canvas、Listbox、Enter 等支持的控件提供滚动功能</td></tr><tr class="even"><td>Spinbox Entry</td><td>和Button 的组合，允许对值进行调整</td></tr><tr class="odd"><td>Text</td><td>多行文本框，用于收集（或显示）用户输入的文本（与HTML 的textarea 类似）</td></tr><tr class="even"><td>Toplevel</td><td>与Frame 类似，不过它提供了一个单独的窗口容器</td></tr></tbody></table><h2 id="tkinter基本示例">tkinter基本示例</h2><h3 id="label控件">Label控件</h3><div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="im">import</span> tkinter <span class="im">as</span> tk</span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>top <span class="op">=</span> tk.Tk()</span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>label <span class="op">=</span> tk.Label(top, text<span class="op">=</span><span class="st">&#39;hello&#39;</span>)</span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>label.pack()</span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>tk.mainloop()</span></code></pre></div><h3 id="button控件">Button控件</h3><div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="im">import</span> tkinter <span class="im">as</span> tk</span><span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span><span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>top <span class="op">=</span> tk.Tk()</span><span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span><span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>quit <span class="op">=</span> tk.Button(top, text<span class="op">=</span><span class="st">&#39;start&#39;</span>, command<span class="op">=</span>top.quit)</span><span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>quit.pack()</span><span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>tk.mainloop()</span></code></pre></div><h2 id="目录树遍历工具">目录树遍历工具</h2><p>它会从当前目录开始，提供一个文件列表。双击列表中任意其他目录，就会使得工具切换到新目录中，用新目录中的文件列表代替旧文件列表。 <img src="https://img-blog.csdnimg.cn/20200224105058824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p><div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="im">import</span> os</span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="im">from</span> time <span class="im">import</span> sleep</span><span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="im">import</span> tkinter <span class="im">as</span> tk</span><span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="im">from</span> functools <span class="im">import</span> partial <span class="im">as</span> pto</span><span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a></span><span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span><span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span class="kw">class</span> DirList(<span class="bu">object</span>):</span><span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;读取并显示指定目录下的文件列表&quot;&quot;&quot;</span></span><span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, initdir<span class="op">=</span><span class="va">None</span>):</span><span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>        <span class="va">self</span>.top <span class="op">=</span> tk.Tk()</span><span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>        <span class="va">self</span>.label <span class="op">=</span> tk.Label(<span class="va">self</span>.top, text<span class="op">=</span><span class="st">&#39;DirList v1.1&#39;</span>)</span><span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>        <span class="va">self</span>.label.pack()</span><span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a></span><span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>        <span class="co"># 写入延迟</span></span><span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>        <span class="va">self</span>.cwd <span class="op">=</span> tk.StringVar(<span class="va">self</span>.top)</span><span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a></span><span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>        <span class="va">self</span>.dirl <span class="op">=</span> tk.Label(<span class="va">self</span>.top, fg<span class="op">=</span><span class="st">&#39;blue&#39;</span>, font<span class="op">=</span>(<span class="st">&#39;Helvetica&#39;</span>, <span class="dv">12</span>, <span class="st">&#39;bold&#39;</span>))</span><span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>        <span class="va">self</span>.dirl.pack()</span><span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a></span><span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>        <span class="va">self</span>.dirfm <span class="op">=</span> tk.Frame(<span class="va">self</span>.top)</span><span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>        <span class="va">self</span>.dirsb <span class="op">=</span> tk.Scrollbar(<span class="va">self</span>.dirfm)</span><span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>        <span class="va">self</span>.dirsb.pack(side<span class="op">=</span>tk.RIGHT, fill<span class="op">=</span>tk.Y)</span><span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>        <span class="va">self</span>.dirs <span class="op">=</span> tk.Listbox(<span class="va">self</span>.dirfm, height<span class="op">=</span><span class="dv">15</span>, width<span class="op">=</span><span class="dv">50</span>,</span><span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>                               yscrollcommand<span class="op">=</span><span class="va">self</span>.dirsb.<span class="bu">set</span>)</span><span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>        <span class="va">self</span>.dirs.bind(<span class="st">&#39;&lt;Double-1&gt;&#39;</span>, <span class="va">self</span>.setDirAndGo)</span><span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>        <span class="va">self</span>.dirsb.config(command<span class="op">=</span><span class="va">self</span>.dirs.yview)</span><span id="cb6-27"><a href="#cb6-27" aria-hidden="true"></a>        <span class="va">self</span>.dirs.pack(side<span class="op">=</span>tk.LEFT, fill<span class="op">=</span>tk.BOTH)</span><span id="cb6-28"><a href="#cb6-28" aria-hidden="true"></a>        <span class="va">self</span>.dirfm.pack()</span><span id="cb6-29"><a href="#cb6-29" aria-hidden="true"></a></span><span id="cb6-30"><a href="#cb6-30" aria-hidden="true"></a>        <span class="va">self</span>.dirn <span class="op">=</span> tk.Entry(<span class="va">self</span>.top, width<span class="op">=</span><span class="dv">50</span>, textvariable<span class="op">=</span><span class="va">self</span>.cwd)</span><span id="cb6-31"><a href="#cb6-31" aria-hidden="true"></a>        <span class="va">self</span>.dirn.bind(<span class="st">&#39;&lt;Return&gt;&#39;</span>, <span class="va">self</span>.doLS)</span><span id="cb6-32"><a href="#cb6-32" aria-hidden="true"></a>        <span class="va">self</span>.dirn.pack()</span><span id="cb6-33"><a href="#cb6-33" aria-hidden="true"></a></span><span id="cb6-34"><a href="#cb6-34" aria-hidden="true"></a>        <span class="va">self</span>.bfm <span class="op">=</span> tk.Frame(<span class="va">self</span>.top)</span><span id="cb6-35"><a href="#cb6-35" aria-hidden="true"></a>        <span class="va">self</span>.clr <span class="op">=</span> tk.Button(<span class="va">self</span>.bfm, text<span class="op">=</span><span class="st">&#39;Clear&#39;</span>, command<span class="op">=</span><span class="va">self</span>.clrDir,</span><span id="cb6-36"><a href="#cb6-36" aria-hidden="true"></a>                             activeforeground<span class="op">=</span><span class="st">&#39;white&#39;</span>, activebackground<span class="op">=</span><span class="st">&#39;blue&#39;</span>)</span><span id="cb6-37"><a href="#cb6-37" aria-hidden="true"></a>        <span class="va">self</span>.ls <span class="op">=</span> tk.Button(<span class="va">self</span>.bfm, text<span class="op">=</span><span class="st">&#39;List Directory&#39;</span>, command<span class="op">=</span><span class="va">self</span>.doLS,</span><span id="cb6-38"><a href="#cb6-38" aria-hidden="true"></a>                            activeforeground<span class="op">=</span><span class="st">&#39;white&#39;</span>, activebackground<span class="op">=</span><span class="st">&#39;green&#39;</span>)</span><span id="cb6-39"><a href="#cb6-39" aria-hidden="true"></a>        <span class="va">self</span>.quit <span class="op">=</span> tk.Button(<span class="va">self</span>.bfm, text<span class="op">=</span><span class="st">&#39;Quit&#39;</span>, command<span class="op">=</span><span class="va">self</span>.top.quit,</span><span id="cb6-40"><a href="#cb6-40" aria-hidden="true"></a>                              activeforeground<span class="op">=</span><span class="st">&#39;white&#39;</span>, activebackground<span class="op">=</span><span class="st">&#39;red&#39;</span>)</span><span id="cb6-41"><a href="#cb6-41" aria-hidden="true"></a>        <span class="va">self</span>.clr.pack(side<span class="op">=</span>tk.LEFT)</span><span id="cb6-42"><a href="#cb6-42" aria-hidden="true"></a>        <span class="va">self</span>.ls.pack(side<span class="op">=</span>tk.LEFT)</span><span id="cb6-43"><a href="#cb6-43" aria-hidden="true"></a>        <span class="va">self</span>.quit.pack(side<span class="op">=</span>tk.LEFT)</span><span id="cb6-44"><a href="#cb6-44" aria-hidden="true"></a>        <span class="va">self</span>.bfm.pack()</span><span id="cb6-45"><a href="#cb6-45" aria-hidden="true"></a></span><span id="cb6-46"><a href="#cb6-46" aria-hidden="true"></a>        <span class="cf">if</span> initdir:</span><span id="cb6-47"><a href="#cb6-47" aria-hidden="true"></a>            <span class="va">self</span>.cwd.<span class="bu">set</span>(os.curdir)</span><span id="cb6-48"><a href="#cb6-48" aria-hidden="true"></a>            <span class="va">self</span>.doLS()</span><span id="cb6-49"><a href="#cb6-49" aria-hidden="true"></a></span><span id="cb6-50"><a href="#cb6-50" aria-hidden="true"></a>    <span class="kw">def</span> clrDir(<span class="va">self</span>, ev<span class="op">=</span><span class="va">None</span>):</span><span id="cb6-51"><a href="#cb6-51" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;清空文件列表&quot;&quot;&quot;</span></span><span id="cb6-52"><a href="#cb6-52" aria-hidden="true"></a>        <span class="va">self</span>.cwd.<span class="bu">set</span>(<span class="st">&#39;&#39;</span>)</span><span id="cb6-53"><a href="#cb6-53" aria-hidden="true"></a></span><span id="cb6-54"><a href="#cb6-54" aria-hidden="true"></a>    <span class="kw">def</span> setDirAndGo(<span class="va">self</span>, ev<span class="op">=</span><span class="va">None</span>):</span><span id="cb6-55"><a href="#cb6-55" aria-hidden="true"></a>        <span class="co">&quot;&quot;&quot;设置文件夹路径并读取&quot;&quot;&quot;</span></span><span id="cb6-56"><a href="#cb6-56" aria-hidden="true"></a>        <span class="va">self</span>.last <span class="op">=</span> <span class="va">self</span>.cwd.get()</span><span id="cb6-57"><a href="#cb6-57" aria-hidden="true"></a>        <span class="va">self</span>.dirs.config(selectbackgroung<span class="op">=</span><span class="st">&#39;red&#39;</span>)</span><span id="cb6-58"><a href="#cb6-58" aria-hidden="true"></a>        check <span class="op">=</span> <span class="va">self</span>.dirs.get(<span class="va">self</span>.dirs.curselection())</span><span id="cb6-59"><a href="#cb6-59" aria-hidden="true"></a>        <span class="cf">if</span> <span class="kw">not</span> check:</span><span id="cb6-60"><a href="#cb6-60" aria-hidden="true"></a>            check <span class="op">=</span> os.curdir</span><span id="cb6-61"><a href="#cb6-61" aria-hidden="true"></a>        <span class="va">self</span>.cwd.<span class="bu">set</span>(check)</span><span id="cb6-62"><a href="#cb6-62" aria-hidden="true"></a>        <span class="va">self</span>.doLS()</span><span id="cb6-63"><a href="#cb6-63" aria-hidden="true"></a></span><span id="cb6-64"><a href="#cb6-64" aria-hidden="true"></a>    <span class="kw">def</span> doLS(<span class="va">self</span>, ev<span class="op">=</span><span class="va">None</span>):</span><span id="cb6-65"><a href="#cb6-65" aria-hidden="true"></a>        error <span class="op">=</span> <span class="st">&#39;&#39;</span></span><span id="cb6-66"><a href="#cb6-66" aria-hidden="true"></a>        tdir <span class="op">=</span> <span class="va">self</span>.cwd.get()</span><span id="cb6-67"><a href="#cb6-67" aria-hidden="true"></a>        <span class="cf">if</span> <span class="kw">not</span> tdir:</span><span id="cb6-68"><a href="#cb6-68" aria-hidden="true"></a>            tdir <span class="op">=</span> os.curdir</span><span id="cb6-69"><a href="#cb6-69" aria-hidden="true"></a>        <span class="cf">if</span> <span class="kw">not</span> os.path.exists(tdir):</span><span id="cb6-70"><a href="#cb6-70" aria-hidden="true"></a>            error <span class="op">=</span> tdir <span class="op">+</span> <span class="st">&#39;:no such file&#39;</span></span><span id="cb6-71"><a href="#cb6-71" aria-hidden="true"></a>        <span class="cf">elif</span> <span class="kw">not</span> os.path.isdir(tdir):</span><span id="cb6-72"><a href="#cb6-72" aria-hidden="true"></a>            error <span class="op">=</span> tdir <span class="op">+</span> <span class="st">&#39;:not a directory&#39;</span></span><span id="cb6-73"><a href="#cb6-73" aria-hidden="true"></a></span><span id="cb6-74"><a href="#cb6-74" aria-hidden="true"></a>        <span class="cf">if</span> error:</span><span id="cb6-75"><a href="#cb6-75" aria-hidden="true"></a>            <span class="va">self</span>.cwd.<span class="bu">set</span>(error)</span><span id="cb6-76"><a href="#cb6-76" aria-hidden="true"></a>            <span class="va">self</span>.top.update()</span><span id="cb6-77"><a href="#cb6-77" aria-hidden="true"></a>            sleep(<span class="dv">2</span>)</span><span id="cb6-78"><a href="#cb6-78" aria-hidden="true"></a>            <span class="cf">if</span> <span class="kw">not</span> (<span class="bu">hasattr</span>(<span class="va">self</span>, <span class="st">&#39;last&#39;</span>) <span class="kw">and</span> <span class="va">self</span>.last):</span><span id="cb6-79"><a href="#cb6-79" aria-hidden="true"></a>                <span class="va">self</span>.last <span class="op">=</span> os.curdir</span><span id="cb6-80"><a href="#cb6-80" aria-hidden="true"></a>            <span class="va">self</span>.cwd.<span class="bu">set</span>(<span class="va">self</span>.last)</span><span id="cb6-81"><a href="#cb6-81" aria-hidden="true"></a>            <span class="va">self</span>.dirs.config(selectbackground<span class="op">=</span><span class="st">&#39;LightSkyBlue&#39;</span>)</span><span id="cb6-82"><a href="#cb6-82" aria-hidden="true"></a>            <span class="va">self</span>.top.update()</span><span id="cb6-83"><a href="#cb6-83" aria-hidden="true"></a>            <span class="cf">return</span></span><span id="cb6-84"><a href="#cb6-84" aria-hidden="true"></a></span><span id="cb6-85"><a href="#cb6-85" aria-hidden="true"></a>        <span class="va">self</span>.cwd.<span class="bu">set</span>(<span class="st">&#39;Fetching directory contents...&#39;</span>)</span><span id="cb6-86"><a href="#cb6-86" aria-hidden="true"></a>        <span class="va">self</span>.top.update()</span><span id="cb6-87"><a href="#cb6-87" aria-hidden="true"></a>        dirlist <span class="op">=</span> os.listdir(tdir)</span><span id="cb6-88"><a href="#cb6-88" aria-hidden="true"></a>        dirlist.sort()</span><span id="cb6-89"><a href="#cb6-89" aria-hidden="true"></a>        os.chdir(tdir)</span><span id="cb6-90"><a href="#cb6-90" aria-hidden="true"></a></span><span id="cb6-91"><a href="#cb6-91" aria-hidden="true"></a>        <span class="va">self</span>.dirl.config(text<span class="op">=</span>os.getcwd())</span><span id="cb6-92"><a href="#cb6-92" aria-hidden="true"></a>        <span class="va">self</span>.dirs.delete(<span class="dv">0</span>, tk.END)</span><span id="cb6-93"><a href="#cb6-93" aria-hidden="true"></a>        <span class="va">self</span>.dirs.insert(tk.END, os.curdir)</span><span id="cb6-94"><a href="#cb6-94" aria-hidden="true"></a>        <span class="va">self</span>.dirs.insert(tk.END, os.pardir)</span><span id="cb6-95"><a href="#cb6-95" aria-hidden="true"></a>        <span class="cf">for</span> eachFile <span class="kw">in</span> dirlist:</span><span id="cb6-96"><a href="#cb6-96" aria-hidden="true"></a>            <span class="va">self</span>.dirs.insert(tk.END, eachFile)</span><span id="cb6-97"><a href="#cb6-97" aria-hidden="true"></a>        <span class="va">self</span>.cwd.<span class="bu">set</span>(os.curdir)</span><span id="cb6-98"><a href="#cb6-98" aria-hidden="true"></a>        <span class="va">self</span>.dirs.config(selectbackground<span class="op">=</span><span class="st">&#39;LightSkyBlue&#39;</span>)</span><span id="cb6-99"><a href="#cb6-99" aria-hidden="true"></a></span><span id="cb6-100"><a href="#cb6-100" aria-hidden="true"></a></span><span id="cb6-101"><a href="#cb6-101" aria-hidden="true"></a></span><span id="cb6-102"><a href="#cb6-102" aria-hidden="true"></a><span class="kw">def</span> main():</span><span id="cb6-103"><a href="#cb6-103" aria-hidden="true"></a>    DirList(os.curdir)</span><span id="cb6-104"><a href="#cb6-104" aria-hidden="true"></a>    tk.mainloop()</span><span id="cb6-105"><a href="#cb6-105" aria-hidden="true"></a></span><span id="cb6-106"><a href="#cb6-106" aria-hidden="true"></a></span><span id="cb6-107"><a href="#cb6-107" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span><span id="cb6-108"><a href="#cb6-108" aria-hidden="true"></a>    main()</span></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程实践 </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论5】回报函数</title>
      <link href="post/d73b0d23.html"/>
      <url>post/d73b0d23.html</url>
      
        <content type="html"><![CDATA[<p>回报函数（reward）设计在DRL应用中是极其重要的一环，通过将任务目标具体化和数值化，reward就如同一种特殊语言，实现了目标与算法之间的沟通，算法工作者在这里面承担了翻译的角色，翻译的好坏体现了其对任务逻辑的理解深度，决定了agent最终是否能学到期望的技能，并直接影响算法的收敛速度和最终性能。结合上一篇的内容，我们知道DRL算法中reward负责引导神经网络挖掘状态信息中的决策相关因素并经过提炼后用于action的计算生成。既然reward设计这么重要，想必分析起来又会是像状态空间那样的长篇大论吧。AI时代有了深度神经网络，也不缺数据和算力，难道这点人工就不能省下来吗？</p><a id="more"></a><h2 id="非要手工设计吗">非要手工设计吗？</h2><p>鉴于强化学习算法对优秀reward函数设计的依赖，学术界提出了很多方法改善这一状况。比如逆向强化学习，利用expert demonstration（专家示范）学习到reward函数，再用这个reward函数训练RL策略。此外，还有一大堆模仿学习的方法，干脆抛开reward直接拟合专家策略。以上方法的前提是要有专家数据，不具备普适性，这里就不多说了。</p><p>近年来学术界有个趋势，希望通过深度神经网络自动学习reward函数，从而代替手工设计。其中一篇比较有代表性的工作[1] ，在传统Actor-Critic框架的基础上，又增加了一个Reward网络，输入当前的状（state）和动作（action），输出这一步的reward值。Actor和Critic网络都依据最新的reward网络输出进行优化，而reward网络则依据人类（supervisor）的喜好用有监督的方式进行更新，具体方法是周期性地采集一些episode片段并成对地让人类观看，后者反馈更喜欢哪个片段，再由reward网络拟合这个二分类问题。这篇paper的思想我非常欣赏，现实生活中确实存在很多难以分解和量化的目标，比如让agent学会后空翻，reward就很难设计；有些目标虽然是本身是量化的，但过于笼统难以分解成具体的reward，此时这种方法就很有吸引力。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225212358.png" /></p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225212421.png" /></p><p>可惜啊~~~，我们在现实中遇到的需求不大可能是第一种情况，比起“不能做→能做”，工业界更喜欢“能做→做得更好”，一般都会给出一个明确的指标用来最大化或最小化。假如这个指标能通过少量采样统计出来或体现出优劣关系，那就适合采用这种方法自动学习reward函数，而且不需要人的介入，全程自动化进行。但如果这个指标必须通过大量采样才能统计出来或者获得可靠的优劣关系，该方法的效率就非常低了，这种情况下就得老老实实地手工设计reward，走传统DRL路线了。</p><h2 id="主线reward和稀疏回报问题">主线reward和稀疏回报问题</h2><p>当我们拿到一个任务目标，往往能够简单分析就能找出与该目标紧密联系的主线事件，比如小车到达终点的任务中“到终点”就是这样的事件，拳皇里“KO”也是这样的事件，超级马里奥中“通关”还是这样的事件。此时我们就有了第一个reward项，我把它称之为主线reward，一般是正奖励，当主线事件发生时即反馈给agent。理论上，只要有主线reward就可以用强化学习算法进行训练了。在很多简单任务中，agent在探索过程中靠误打误撞就能以一定概率遇到主线事件，通过正反馈尝到甜头后通过更新policy逐渐提升得到奖励的概率直至收敛。可是当问题稍微复杂一些，通过随机方式探索到主线事件（正样本）的概率变得很低，而强化学习算法本身的数据效率不高，只靠这些少得可怜的正样本，算法难以收敛或收敛很慢。下面我引用伯克利RL大神Pieter Abbeel的课程CS294-40中的例子具体说明。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213337.png" /></p><p>在上图中agent从最左端起始位置S处出发（state=1），目标是到达最右端的G位置(state=5)，允许的动作包括向左一格和向右一格。在图中的reward系统下，agent只有到达G才能得到1分的奖励（主线reward），其他状态都没有任何反馈，那么仅靠随机探索agent是很难到达G的，<strong>因为中间缺乏有效信号来指导agent向正确的方向前进</strong>。在强化学习中，这一类问题被称作稀疏回报问题（Sparse Reward Problem），一直都是DRL领域研究的热点。显然，只定义了主线reward的任务几乎都是稀疏回报问题，对数据效率低下的RL算法而言，学习难度是很大的。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213402.png" /></p><p>当稀疏回报问题遇上高难度探索（Hard Exploration）问题，DRL算法收敛更是难上加难，几乎是不可能完成的任务。比如让机器人学会打开盒子，抓起木块放到盒子里，然后再把盒子盖上，如果只在成功完成这一系列动作的时候才给出奖励，那么用一般的DRL算法和探索策略根本不可能学会目标技能，因为正样本产生的概率跟闭着眼用针尖扎到平面上一点的概率差不多，可以认为是0。</p><p>针对稀疏回报问题，学术界提出了很多方法，比如通过鼓励agent探索未见过的状态，提高正样本利用率，或者干脆用遗传算法或进化策略代替RL学习policy网络。这些方法不在本篇的讨论范围内，我们关心的是如何通过reward设计本身来规避稀疏回报问题，并尽可能提高训练效率和最终性能。</p><p>此外，联系上一篇状态空间设计的内容，由于主线事件通常难以一蹴而就，大部分状态信息相对于主线reward也就都属于间接相关信息，这也从另一个角度解释了为什么在稀疏回报下算法训练难度高。</p><h2 id="目标分解和辅助reward">目标分解和辅助reward</h2><p>既然只有主线reward不行，我们接下来就要将原始任务目标进一步分解成子目标，并分别给予合理的奖励或惩罚，从而达到引导agent趋利避害提高主线事件发生概率的目的。学术界一般称该过程为credit assignment，credit意译过来就是功劳，说的是某个子目标在达成总目标的过程中起了多大作用，是正向作用还是负向作用。这些子目标对应的reward可以称之为辅助reward，它们使reward不再稀疏。通常情况下，<strong>为了保证主线奖励的核心地位和吸引力，各种辅助reward的绝对值都设得相对较小，以免喧宾夺主</strong>。</p><h3 id="目标分解实例">目标分解实例</h3><p>Agent在环境中探索时需要获得反馈，即刚刚的决策好不好，反馈越及时学得越快，理想情况是每一步都有反馈。还以小车导航到终点的应用为例，除了抵达终点+10分，如果每次靠近终点也+1分，那么小车在抵达终点之前就学会主动靠近终点，这样探索到抵达终点的概率也大大提高了，DRL算法收敛速度自然会加快。</p><p>除了抵达终点，小车还要避免与障碍物和其他小车发生碰撞，我们还要对碰撞事件做出惩罚。为了使agent更好地学会避免碰撞，我们除了对已经发生的碰撞事件给予惩罚，还可以再增加一个预防式的靠近惩罚，并利用状态空间里的直接相关信息——与最近邻居的距离，提高算法学习效率，具体可以参考<a href="https://su-lemon.github.io/blog/post/63561af6.html">状态空间篇</a>。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213423.png" /></p><p>辅助reward的设计建立在对任务逻辑的深刻分析和理解之上，有很多细节都会对最终目标的实现产生正向或负向的影响，值得我们深入挖掘。比如，为了使小车尽快到达终点，就要求少绕路，而绕路的典型表现是转弯多，于是可以增加对转弯的惩罚。类似这样的链式思考有助于找到更好的辅助reward，帮助降低学习难度和提升最终性能。</p><p>此外，由于将最终目标分解成了子目标，在设计对应辅助reward时往往很容易找到与之即时联动的直接相关状态信息，或者相关性较强的间接相关信息。事实上，我们每设计一个reward项，就应该回过头去检查状态空间中是否包含了直接或间接相关信息，已经包含的信息是否足够直接高效，有没有改进的空间。</p><h3 id="杜绝异常行为">杜绝异常行为</h3><p>OK，让我们来捋一捋目前的reward项：抵达奖励，靠近终点奖励，碰撞惩罚和转弯惩罚。Reward项一多，我们就要特别注意它们之间的相对大小。首先，应该避免某个（些）reward项的绝对值过大，以至于淹没其他reward项的影响，必要时应使用系数加以调控；其次，应该避免reward项的不合理取值及多项reward之间的不合理相对大小，导致agent学到异常行为。因为不合理reward造成的常见异常行为主要包括三种类型：鲁莽、贪婪和胆怯，怎么感觉我在说炒股呢~~~</p><h4 id="鲁莽">鲁莽</h4><p>鲁莽行为指的是reward中漏掉了针对某个不希望出现的事件的惩罚项或者惩罚力度太小，被其他reward项盖过，导致agent无法学到主动规避该事件或者权衡利弊后仍然选择接受该事件的惩罚以换取更大收益。比如下图中金币搜索任务中，设计者忘了给予进入岩浆的惩罚，结果机器人为了尽快得到金币而甘愿“赴汤蹈火”；在小车导航的例子中，碰撞惩罚相对于远离惩罚过小，小车可能为了尽快到达终点宁愿撞到其他小车上也不愿意绕远。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213439.png" /></p><h4 id="贪婪">贪婪</h4><p>靠近终点奖励使reward变稠密了，但这样做就够了吗？我们说过RL追求的是长期收益，事实上对小车来说收益最高的选择不是尽快抵达终点，而是不断重复“靠近-远离”的动作，如此一点点地累加，收益远超过抵达终点的一锤子买卖！很显然，agent钻了reward设计漏洞的空子，变得不思进取，贪得无厌。为了防止这种情况发生，我们还要对原地不动或远离终点的行为进行惩罚，而且相对于靠近奖励，扣分太少也不行，否则agent仍然会发现钻空子是划算的。一劳永逸的办法是，将靠近终点的正向奖励改成微小惩罚，绝对值小于原地不动或远离惩罚，这样做的好处是不仅不给agent钻空子的机会，而且还能督促小车尽快向终点行驶。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213456.png" /></p><p>再比如在蒙特祖玛的复仇中，要想通关（主线事件，+10）必须先吃到钥匙，为了鼓励agent吃钥匙我们还可以为这个子目标提供专门的奖励（+1）。这种情况下房间只有一把钥匙还好，但如果到处都是钥匙呢？Agent很可能会变得乐不思蜀，一直留在房间里找新的钥匙，忘记通关这回事了。如果真是这样，那就不如不设吃钥匙奖励，只保留主线奖励，由Agent自己去发掘通关与吃钥匙之间的内在联系。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213513.png" /></p><p>实际上，<strong>除了主线reward应该提供正向奖励以外，其他辅助reward最好都设置为惩罚项</strong>。除非某个子目标与主线事件之间存在强关联，而且该子目标的达成是一次性的或者数量可控，否则不应轻易设置额外奖励项，因为这样很容易诱导agent学习到短视的贪婪策略，只捡芝麻，不要西瓜。</p><h4 id="胆怯">胆怯</h4><p>与贪婪相反的另一个异常行为是胆怯，如果惩罚项很多且绝对值相对于主线reward太大，那么agent在探索过程中会收到大量负反馈，从而变得畏首畏尾，学习到各种意想不到的“绥靖”策略。比如在小车到终点的例子中，假如碰撞惩罚和转弯惩罚绝对值过大，agent有可能宁愿选择原地不动，这是因为训练初期policy很差，需要经历大量转弯和碰撞后才可能出现主线事件（到达终点），而收到的负反馈完全湮没了主线奖励，因此在agent看来原地不动的长期累计收益<strong>暂时</strong>不比到终点差，尽管只是暂时的，但agent很可能陷在这个局部最优里出不来了。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213530.png" /></p><p>在上述情况下，你会发现只需要将惩罚项绝对值减小，突出主线奖励的影响，其他什么也不用干，DRL模型就能顺利收敛了。当然，还可以适当降低折扣因子，让agent变成“近视眼”，更多关注眼前利益，忽略长期的负收益期望（靠后的负反馈都被折扣掉了），只要agent“迈开腿”出来探索，就有更大可能遇到主线事件，并在主线reward的奖励下学习到目标技能。折扣因子的设置技巧我将在训练篇中详细介绍。</p><h3 id="reward-shaping">Reward Shaping</h3><p>把任务目标分解得足够细，又避开了上述各种坑，这样就完美了吗？并没有~~~如果你读过Andrew Ng在1999年发表的关于reward shaping的paper，你就会发现还可以让RL算法收敛得更快一些。Reward shaping技术的证明这里就不赘述了，喜欢手推公式的朋友可以去读原著。我大概说下原理，在原有reward基础上增加一项shaping reward，该项代表某种势能函数，与最终目标的差距决定了势能大小。对于我们上一节举过的例子，如果把reward修改为下图中的形式，agent每向右移动一格都会获得奖励，且离G越近奖励越高，那么agent就很容易被引导到G位置，从而大大加速算法收敛。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225213927.png" /></p><p>Ng从理论上证明了理想势能函数就是 <span class="math inline">\(V(s)\)</span> ，这很好解释，我们前边说过 <span class="math inline">\(V(s)\)</span> 是对长期收益的期望，policy就是根据它优化的，如果一开始就把完美的 <span class="math inline">\(V(s)\)</span> 提供给小车，那也就不用学了。对小车到终点的应用而言，用小车当前位置与终点的距离作为势能函数，增加一个惩罚项 <span class="math inline">\(-\alpha \cdot dist\)</span> ，离终点较远时惩罚得多一些，较近时惩罚得小一些，这样就能起到reward shaping的作用。此外，参考上一篇状态空间设计的内容，你会发现增加的惩罚项可以与状态空间中描述小车与终点相对位置的信息即时联动，从而使后者由间接相关信息转变为直接相关信息，这就从另一个角度解释了reward shaping为什么能提高算法训练的效率。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225214007.png" /></p><h2 id="optimal-reward-problem">Optimal Reward Problem</h2><p>看到这里你可能会问，针对特定任务，比如小车导航到终点，是否存在一组最优reward使得DRL算法在同等条件下收敛最快、性能最高？答案是肯定的，但要想找到它是困难的，该问题在学术界被称为Optimal Reward Problem（ORP），解决方案包括暴力搜索[2]、基于在线策略梯度的PGRD[3]、分层强化学习[4]、遗传算法[5]、Bayes方法[6]等等，有兴趣的朋友可以找来相关paper读一读，相关参考文献我列到最后。</p><h2 id="总结">总结</h2><p>总结一下，reward设计的原则是：<strong>尽可能稠密（最好每步都有反馈），能够反映任务目标/子目标逻辑，与状态空间相呼应，控制好各项取值和相对大小，避免异常行为，适时采用reward shaping</strong>。当算法选择好，动作空间定义好，状态空间和回报函数都设计好，接下来就该进入训练环节了。</p><h2 id="参考">参考</h2><ol type="1"><li>Christiano, P. F.; Leike, J.; Brown, T. B.; Martic, M.; Legg, S.; and Amodei, D. 2017. Deep Reinforcement Learning from Human Preferences. Neural Information Processing Systems: 4299-4307.</li><li>Sorg, J.; Singh, S. P.; and Lewis, R. L. 2010. Internal Rewards Mitigate Agent Boundedness. International Conference on Machine Learning: 1007-1014.</li><li>Sorg, J.; Lewis, R. L.; and Singh, S. P. 2010. Reward Design via Online Gradient Ascent. Neural Information Processing Systems: 2190-2198.</li><li>Bratman, J.; Singh, S. P.; Sorg, J.; and Lewis, R. L. 2012. Strong Mitigation: Nesting Search for Good Policies within Search for Good Reward. Adaptive Agents and Multi Agents Systems: 407-414.</li><li>Niekum, S.; Barto, A. G.; and Spector, L. 2010. Genetic Programming for Reward Function Search. IEEE Transactions on Autonomous Mental Development 2(2): 83-90.</li><li>Hadfield-Menell, D.; Milli, S.; Abbeel, P.; Russell, S.; and Dragan, A. D. 2017. Inverse Reward Design. Neural Information Processing Systems: 6765-6774.</li></ol>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Hexo博客】从搭建到部署，快速构建私人博客</title>
      <link href="post/5bd42e8c.html"/>
      <url>post/5bd42e8c.html</url>
      
        <content type="html"><![CDATA[<p>有时候我们希望有一个受控的博客，来记录或分享一些东西。这个博客的主题内容由你自己来决定，可以是技术分享(编程、汉化分享等)，也可以是生活感想。</p><p>本文将介绍一个可以迅速搭建并部署的受控博客。</p><a id="more"></a><h2 id="为什么搭建博客">为什么搭建博客</h2><p>在线类博客有很多选择，为什么我们需要从零搭建新的博客呢？自己搭建的博客有什么好处吗？</p><p>首先，前文所提的 <strong>“博客受控”</strong>，指的就是能够自己控制的博客的样式、内容等，自己想怎么改就怎么改。</p><p>内容受控是指我们知道在线类的博客是受平台限制的，这意味着你所发表的内容是需要受审才能发出的，一些敏感的技术词汇，该篇文章都可能会被和谐或被删除。但在自己搭建博客就没有这样的问题，最起码能保留源文件。</p><p>其二，博客的样式是受控的。像著名在线博客<code>CSDN</code>上一些博主的文章确实是有学习参考的价值，但问题的是该站广告是在是太多了，字体和排版的阅读体验并不太好。但如果是自己搭建的博客的话，就可以自己着手优化这些问题。</p><p>但博客的搭建还需要我们从各方面考虑利弊。平台类博客会有相应的推荐系统，会对同类型文章相互引流，在 SEO 方面会做得比我们好。</p><p>个人搭建的博客，刚起步时的浏览量并不高，但是可以通过<code>SEO</code>等方式来逐步增加自己网站的权重。或者提高博客的质量和干货，读者认为文章有价值，自然会收藏起来形成熟客。</p><p>那么博客能写什么东西呢？在日常生活中，有很多知识点是呈碎片状，写博客的本质上就是对自己知识的一种梳理，然后再将这些知识分享出来，可能会有对这方面知识有疑惑，或者想找到解决方案，自身分享出来的东西能给读者做一定的参考。同时这也会是一个良性循环，因为分享的同时，你可能也需要去查询一些资料，同时也可以找到别人遇到过并分享出来的解决方案，是一个相互收益的过程。</p><p>我们的基本需求是梳理与分享，那么更应该把注意力放在内容本身，网站布局的排版样式等则是增加读者阅读体验的问题。因此我们可以使用现成的博客框架快速完成这些事。</p><p>博客框架有很多种选择，笔者选择的是 <a href="https://hexo.io/zh-cn/">Hexo</a>，因为它足够便捷优雅。</p><h2 id="开始">开始</h2><p><code>Hexo</code> 依赖 <a href="https://nodejs.org/en/">Node.js</a> 和 <code>NPM</code>包管理，<code>Node.js</code> 安装后一般会自带<code>NPM</code>。</p><p>我们打开终端(<code>Windows PowerShell / cmd.exe</code>、<code>bash</code>、<code>macOS</code> 里的终端)，输入以下命令：</p><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co"># 1 检查npm版本</span></span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">npm</span> -v</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co"># 2 安装 hexo cli，</span></span><span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ex">npm</span> install -g hexo-cli</span><span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span><span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co"># 3 检查 hexo 是否安装成功</span></span><span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ex">hexo</span> -v</span><span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span><span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="co"># 4 查看使用方式</span></span><span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a><span class="ex">hexo</span> help</span></code></pre></div><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221124920.png" /></p><p>在官网 <a href="https://hexo.io/zh-cn/docs/commands">commands</a> 中可以找到hexo命令完整的解释。</p><h2 id="建站">建站</h2><p>我们可以使用 <code>init</code> 命令来初始化 <code>hexo</code> 项目，但在建站之前我们需要先决定在哪里存放博客源代码。</p><p>笔者使用 <code>iCloud</code> 云文件夹，将源文件在多设备同步。当然根据个人情况也可以选择 <code>OneDrive</code> 等云存储空间。</p><p>该方式只是数据备份与同步的问题，不使用它也不会影响下文的构建。如果读着暂时没有合适的云存储空间，可以直接存储在本地。</p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co"># 1 查看路径（Unix系统）</span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="bu">pwd</span></span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="co"># /Users/susu/Library/Mobile Documents/com~apple~CloudDocs</span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="co"># 2 初始化文件夹名为 blog</span></span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ex">hexo</span> init blog</span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span><span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="bu">cd</span> blog</span></code></pre></div><p>初始化安装完成后，blog文件夹下的文件目录如下：</p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">.</span></span><span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>├── <span class="ex">_config.yml</span>  # 网站的配置信息</span><span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>├── <span class="ex">node_modules</span>  # 应用依赖信息</span><span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>├── <span class="ex">package-lock.json</span></span><span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>├── <span class="ex">package.json</span>  # 依赖包</span><span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>├── <span class="ex">scaffolds</span>  # 模板文件</span><span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>├── <span class="bu">source</span>  # 资源文件夹是存放用户资源的地方</span><span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>│   ├── <span class="ex">_drafts</span>  # 草稿文件夹，刚初始化时可能不存在</span><span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>│   ├── <span class="ex">_posts</span>  # 文章/帖子源码列表</span><span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>└── <span class="ex">themes</span>  # 博客主题</span></code></pre></div><h2 id="配置">配置</h2><p>建站完成后我们需要进行 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a>，<code>hexo</code> 中主要有两项配置。</p><ul><li><code>站点配置文件</code>，路径为 <code>/_config.yml</code> ；</li><li><code>主题配置文件</code> ，路径是 <code>/themes/(下载的主题)/_config.yml</code> 。</li></ul><p>我们可以先在 <code>站点配置文件</code> 修改以下基础选项：</p><div class="sourceCode" id="cb4"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co"># Hexo Configuration</span></span><span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span><span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co"># 网站主标题，SEO元素之一</span></span><span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="fu">title</span><span class="kw">:</span><span class="at"> blog</span></span><span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span><span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="co"># 网站副标题，可选</span></span><span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="fu">subtitle</span><span class="kw">:</span></span><span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a></span><span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a><span class="co"># 网站描述, SEO元素之一，用于告诉搜索引擎关于这个站点的描述</span></span><span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="fu">description</span><span class="kw">:</span><span class="at"> </span></span><span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a></span><span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a><span class="co"># 网站的关键词</span></span><span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a><span class="fu">keywords</span><span class="kw">:</span><span class="at"> </span></span><span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a></span><span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a><span class="co"># 网站作者</span></span><span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a><span class="fu">author</span><span class="kw">:</span><span class="at"> SuSu</span></span><span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a></span><span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a><span class="co"># 网站使用的语言, 由于 Hexo 具备多语言配置，默认为英文，我们需要修改回中文语言</span></span><span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a><span class="fu">language</span><span class="kw">:</span><span class="at"> zh-CN</span></span></code></pre></div><h2 id="启动">启动</h2><p>初始化项目后默认会安装相关的依赖，接着在命令行输入如下命令来 <strong>运行博客</strong> ：</p><div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co"># 启动服务，默认端口为 4000，启动服务后可以在浏览器输入 `http://localhost:4000` 查看效果</span></span><span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ex">hexo</span> server</span><span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co"># 简写方式</span></span><span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ex">hexo</span> s</span><span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span><span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co"># 还可以使用 -p, 指定 9000 端口</span></span><span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ex">hexo</span> s -p 9000</span></code></pre></div><h2 id="写作">写作</h2><p>一般我们都会使用 <code>hexo new &lt;title&gt;</code> 来建立文章，这种建立方法会将新文章建立在 <code>source/_posts</code> 目录下，当使用 <code>hexo generate</code> 编译 markdown 文件时，会将其 HTML 结果编译在 <code>public</code> 目录下，之后 <code>hexo deploy</code> 将会把 <code>public</code> 目录下所有文章部署到 GitHub，这是我们熟悉的 Hexo 流程。</p><p>这种建立文章方式的缺点是：若我们同时编辑多篇文章，只要其中一篇文章尚未编辑完成，也会随着 <code>hexo deploy</code> 一起部署到 GitHub，也就是 GitHub 可能会看到我们尚未完成的文章。</p><p>笔者个人的写作习惯是：</p><ol type="1"><li>创建草稿 (<code>drafts</code> )</li><li>在草稿上进行写作</li><li>整理细节并在本地服务器上查看效果(<code>server</code>)</li><li>发布至正式的帖子上</li><li>生成静态文件并部署</li></ol><h3 id="创建草稿">创建草稿</h3><div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co"># hexo new draft &lt;title&gt;</span></span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ex">hexo</span> new draft ”博文示例“</span></code></pre></div><p>Hexo 提供 <code>draft</code> 机制，它将新文章将建立在 <code>source/_drafts</code> 目录下。<code>博文示例.md</code> 是一个 <code>markdown</code> 文件，默认的内容如下：</p><div class="sourceCode" id="cb7"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">---</span></span><span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="an">title:</span><span class="co"> 博文示例</span></span><span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="an">tags:</span><span class="co"> </span></span><span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="co">---</span></span></code></pre></div><h3 id="在本地服务器预览草稿">在本地服务器预览草稿</h3><div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ex">hexo</span> s --draft</span></code></pre></div><p>Hexo 的 <code>Hexo server</code> 另外提供 <code>--draft</code> 参数，这让我们可以达到一边编辑 <code>markdown</code> 文章，一边使用浏览器预览的目的。</p><h3 id="发布草稿">发布草稿</h3><p>如果我们在本地服务器上校队完草稿细节后，可以将草稿发布为文章，否则在后续生成博客静态文件时不会被打包出来：</p><div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="co"># hexo publish [layout] &lt;filename&gt;</span></span><span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="ex">hexo</span> publish post 博文示例</span></code></pre></div><p>输入命令后你可以发现发布的文章被转移到了<code>source/_posts/</code>上，这样就完成了本地的文章发布。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221155150.jpg" /></p><h3 id="生成静态文件">生成静态文件</h3><p><code>Hexo</code>框架的一项工作就是将源文件 <code>markdown</code> 最后生成为 <code>HTML</code>：</p><div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co"># 生成文件</span></span><span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="ex">hexo</span> g</span><span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span><span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="co"># 监控文件变化，并生成静态文件</span></span><span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="ex">hexo</span> g --watch</span><span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span><span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="co"># 生成文件并部署(部署后面单独章节来讲)</span></span><span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a><span class="ex">hexo</span> g -d</span></code></pre></div><h2 id="主题">主题</h2><p>熟悉了博客系统的操作后，接下来就是美化博客。<code>Hexo</code> 支持主题，我们可以根据<a href="https://hexo.io/zh-cn/docs/themes.html">官网的创建主题教程</a>自己来设计，也可以直接在<a href="https://hexo.io/themes/">主题商城</a> 中找现成的主题。这里以笔者的主题为例，演示安装主题的步骤。（主题配置及自定义各种功能，在随后的系列文章讲解）</p><p>安装主题可以通过 <code>git clone</code> 克隆至 <code>blog/theme/</code> 目录下：</p><div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="bu">pwd</span></span><span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co"># /Users/susu/Library/Mobile Documents/com~apple~CloudDocs</span></span><span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a></span><span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="co"># 启动主题前需要清除缓存与已部署的文件</span></span><span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a><span class="ex">hexo</span> clean</span><span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span><span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co"># clone 主题（在主题商城中，每个主题都提供了各自的安装说明）</span></span><span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="fu">git</span> clone <span class="op">&lt;</span>主题的GitHub仓库地址<span class="op">&gt;</span> themes/next</span></code></pre></div><p>接着在 <code>站点配置文件(/_config.yml)</code> 中启动 <code>theme</code> 。</p><div class="sourceCode" id="cb12"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co"># _config.yml</span></span><span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">-</span><span class="at"> </span><span class="fu">theme</span><span class="kw">:</span><span class="at"> landscape</span></span><span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="fu">+ theme</span><span class="kw">:</span><span class="at"> 下载的主题名称</span></span></code></pre></div><h2 id="部署">部署</h2><p>我们使用<code>git</code>进行部署，可以将网站部署至私人服务器、也可以部署到免费的<code>github pages</code>上。本文将介绍部署至<code>github</code>的方法，如果你还没有<code>github</code>账号的话，那你需要先<a href="https://anran758.github.io/blog/2019/08/19/hexo-blog/github.com">注册一个账号</a>。</p><ol type="1"><li><p>注册 <code>github</code> 账号</p></li><li><p>创建一个仓库，这里我们先创建一个<code>blog</code>。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221155508.png" /></p><p>接着</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221155836.png" /></p></li><li><p>复制仓库链接，拷贝至 <code>站点配置文件(/_config.yml)</code> 里。同时安装 <code>hexo-deployer-git</code> 的依赖：</p><div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ex">npm</span> install hexo-deployer-git --save</span></code></pre></div><div class="sourceCode" id="cb14"><pre class="sourceCode yml"><code class="sourceCode yaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="fu">url</span><span class="kw">:</span><span class="at"> https://yourname.github.io/blog</span><span class="co">  # 修改为 github io 的地址</span></span><span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="fu">root</span><span class="kw">:</span><span class="at"> /blog/</span><span class="co">  # 要将资源映射到仓库名</span></span><span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a></span><span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="fu">deploy</span><span class="kw">:</span></span><span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="at">  </span><span class="fu">type</span><span class="kw">:</span><span class="at"> git</span></span><span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="at">  </span><span class="fu">repo</span><span class="kw">:</span><span class="at"> https://github.com/yourname/blog.git</span><span class="co">  # blog 的 git 地址</span></span><span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a><span class="at">  </span><span class="fu">branch</span><span class="kw">:</span><span class="at"> gh-pages</span><span class="co">  # 发布至 gh-pages 分支，如果该分支不存在，就会自动创建它</span></span></code></pre></div></li><li><p>接着开始部署。如果你还没配置<code>git</code>账号的话，会提示你输入账号密码，输入正确的账号密码后就部署成功了。</p><div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ex">hexo</span> g -d</span></code></pre></div></li><li><p>接着在github创建的 <code>blog</code> 下进入 <code>settings</code> 项，设置 <code>github pages</code> 为 <code>gh-pages</code> 也就是之前在配置里设置的分支即可。</p></li><li><p><code>github pages</code> 绿色底色处提示我们博客的地址，点击就可以线上查看啦~</p></li></ol><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221160720.png" /></p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221160639.png" /></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL算法】VPG与AC的思想和推导</title>
      <link href="post/46d87670.html"/>
      <url>post/46d87670.html</url>
      
        <content type="html"><![CDATA[<p>策略梯度与Actor-Critic的思想和推导</p><a id="more"></a><h1 id="rl学习什么">RL学习什么</h1><ul><li><p>动作值函数（Q函数）。</p><p>以Q-Learning、DQN为代表，这个系列的算法学习最优动作值函数 <span class="math inline">\(Q^*(s,a)\)</span> 的近似函数 <span class="math inline">\(Q_\theta(s,a)\)</span> 。</p><p>Q-learning 智能体的动作由下面的式子给出：</p></li></ul><p><span class="math display">\[\begin{equation}a(s)=\arg\,\max_a\, Q_\theta(s,a)\label{222}\end{equation}\]</span></p><ul><li><p>策略（随机或确定的）。</p><p>这个系列的方法将策略显示表示为 <span class="math inline">\(\pi_{w}(a \mid s)\)</span> ，它们直接对性能目标 <span class="math inline">\(J(\pi_{w})\)</span> 进行梯度下降来优化参数 <span class="math inline">\(w\)</span> ，使得我们输入当前的 <span class="math inline">\(s\)</span> 就能输出应该执行的最佳动作 <span class="math inline">\(a\)</span> 。</p></li><li><p>值函数。</p></li><li><p>以及/或者环境模型。</p></li></ul><h1 id="vanilla-policy-gradientvpg">Vanilla Policy Gradient（VPG）</h1><p>以下考虑的情况是状态 <span class="math inline">\(s\)</span> 为连续高维变量、动作 <span class="math inline">\(a\)</span> 为分类变量（有限个）的MDP。并且，设环境 <span class="math inline">\(P_{s, s^{\prime}}^{a}\)</span> 与 <span class="math inline">\(r_{5}^{a}\)</span> 为时齐的，不随时间的变化而变化。（状态与动作都是连续变量的MDP有更高效的DDPG等方法解决，不在VPG里讨论）</p><h2 id="策略网络的构造">策略网络的构造</h2><p>在随机且时齐的MDP中，<strong>策略是状态到动作的映射</strong>。由于 <span class="math inline">\(a\)</span> 是分类变量，所以没有办法直接输出 <span class="math inline">\(a\)</span> ，只能输出一个条件分布 <span class="math inline">\(\pi(a \mid s)\)</span> 。为了拟合这个策略，我们定义一个神经网络policy net。网络的输入是 <span class="math inline">\(s\)</span> ，输出是一个 <span class="math inline">\(n\)</span> 维向量，对它进行softmax之后，得到 <span class="math inline">\(n\)</span> 个不同的概率（其和为1），分别对应于最佳动作是各个 <span class="math inline">\(a\)</span> 的概率。设网络的参数为 <span class="math inline">\(w\)</span> ，则可以将网络输出简记为 <span class="math inline">\(\pi_{w}(a \mid s)\)</span> ，它表示在 <span class="math inline">\(s\)</span> 状态下最佳动作是 <span class="math inline">\(a\)</span> 的条件概率。</p><p>与我们熟悉的分类网络做比较：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjrducvd24j31d80om4ge.jpg" /></p><p>我们可以认为分类网络是在用“权重相同的训练集”去训练，而策略网络则是在用“带有不同权重的训练集”去训练。只要我们能够找出衡量 <span class="math inline">\((s,a)\)</span> 好坏的标准.<span class="math inline">\(v\)</span> ，得到形式 <span class="math inline">\((s,a,v)\)</span> 的数据，就可以把训练策略网络的过程看成“带权重的监督学习”。但是，我们如何找出这个 <span class="math inline">\(v\)</span> 呢？找出之后具体 <span class="math inline">\(v\)</span> 应该按照什么公式训练呢？下面，要详细地根据定义推导出policy gradient的表达式。</p><h2 id="推导最基本的策略梯度">推导最基本的策略梯度</h2><p>接下来推导策略梯度的公式及其计算方法。</p><p>假设策略网络的参数为 <span class="math inline">\(w\)</span> ，则可以将策略记为 <span class="math inline">\(\pi_w\)</span> 。</p><ul><li><strong>轨迹的概率</strong>。在不同网络参数 <span class="math inline">\(w\)</span> 下，策略 <span class="math inline">\(\pi_w\)</span> 给出的轨迹 <span class="math inline">\(\tau = \left(s_{0}, a_{0}, r_{0}, s_{1}, a_{1}, r_{1}, s_{2}, a_{2}, r_{2}, \ldots, s_{t}, a_{t}, r_{t}\right)\)</span> 有不同的分布 <span class="math inline">\(P_{\pi_{w}}(\tau)\)</span> ，简记为<span class="math inline">\(P_{w}(\tau)\)</span> 。</li></ul><p><span class="math display">\[P_{w}(\tau)=\Pi_{t=0}^{n} \pi_{w}\left(a_{t} \mid s_{t}\right) \Pi_{t=0}^{T-1} P_{s_{t}, s_{t+1}}^{a_{t}} \Pi_{t=0}^{T} P\left(r_{t} \mid s_{t}, a_{t}\right)\label{2}\]</span></p><ul><li><strong>目标函数</strong>。我们的目标是最大化期望回报 <span class="math inline">\(J(w)=E_{w}(r(\tau))\)</span> ，这里假设回报无衰减（ <span class="math inline">\(\gamma=1\)</span> ，对于 <span class="math inline">\(\gamma&lt;1\)</span> 的情况推导过程类似）。</li></ul><p><span class="math display">\[J(w) = E_{w}(r(\tau)) = \int_{\tau} P_{w}(\tau) r(\tau) d \tau\]</span></p><ul><li><strong>策略梯度</strong>。我们想求的“策略梯度”就是 <span class="math inline">\(\nabla_{w} J(w)\)</span> 。得到策略梯度就可以通过梯度下降来优化策略 <span class="math inline">\(w_{k+1} = w_{k} + \alpha\,\nabla_{w} J(w)\)</span> 。</li></ul><p><span class="math display">\[\nabla_{w} J(w)=\int_{\tau}\left(\nabla_{w} P_{w}(\tau)\right) r(\tau) d \tau\label{4}\]</span></p><p>​ 上面的<span class="math inline">\(\nabla_{w} J(w)\)</span>仍然是一个积分式，我们很自然地希望将其表示为<span class="math inline">\(\int_{\tau} P_{w}(\tau) \nabla_{w} f(\tau) d \tau\)</span>的形式，其中的<span class="math inline">\(f\)</span>是某个函数。根据期望的定义，这个积分的结果就是<span class="math inline">\(E_{w}\left[\nabla_{w} f(\tau)\right]\)</span>。这样的形式更加简便，并且也更容易计算——只要我们用当前的策略与环境交互采样很多<span class="math inline">\(\tau\)</span>，并计算出梯度<span class="math inline">\(\nabla_{w} f(\tau)\)</span>的均值，就能将其作为<span class="math inline">\(\nabla_{w} J(w)\)</span>的一个估计。</p><ul><li><strong>对数导数技巧</strong>。</li></ul><p><span class="math display">\[P_{w}(\tau) \nabla_{w} \log P_{w}(\tau)=P_{w}(\tau) \frac{\nabla_{w} P_{w}(\tau)}{P_{w}(\tau)}=\nabla_{w} P_{w}(\tau)\label{5}\]</span></p><p>​ 将 <span class="math inline">\((\ref{5})\)</span> 带入 <span class="math inline">\((\ref{4})\)</span> 得： <span class="math display">\[\begin{eqnarray*}\nabla_{w} J(w) &amp;=&amp; \int_{\gamma}\left(\nabla_{w} P_{w}(\tau)\right) r(\tau) d \tau \\&amp;=&amp; \int_{\gamma} P_{w}(\tau) \nabla_{w} \log \left(P_{w}(\tau)\right) r(\tau) d \tau \\&amp;=&amp; E_{w}\left[\nabla_{w} \log \left(P_{w}(\tau)\right) r(\tau)\right]\end{eqnarray*}\]</span></p><ul><li><strong>环境函数的梯度</strong>。环境不依赖于参数 <span class="math inline">\(w\)</span> ，所以式 (<span class="math inline">\(\ref{2}\)</span>) 中 <span class="math inline">\(P_{s_{i}, s_{i+1}}^{a_{i}}\)</span> ，<span class="math inline">\(P\left(r_{i} \mid s_{i}, a_{i}\right)\)</span> 的梯度为零。</li><li><strong>轨迹对数概率的梯度</strong>。所以轨迹对数概率的梯度为：</li></ul><p><span class="math display">\[\nabla_{w} \log \left(P_{w}(\tau)\right)=\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}(a_{t} \mid s_{t})\]</span></p><ul><li><strong>简化后的基本策略梯度</strong>。</li></ul><p><span class="math display">\[\nabla_{w} J(w)=E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right)r(\tau) \right]\label{7}\]</span></p><p>​ 这是一个期望，这意味着我们可以使用样本均值对其进行估计。 如果我们收集一组轨迹 <span class="math inline">\(D = {\left\{ \tau_i \right\}}_{i=1,\cdots,N}\)</span> ， 其中每一个轨迹通过让智能体在环境中使用策略 <span class="math inline">\(\pi_w\)</span> 执行操作得到，则策略梯度可以使用以下式子进行估计： <span class="math display">\[\hat{g} = \frac{1}{N}\sum_{\tau \in D} \sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right)r(\tau)\label{ref9}\]</span></p><h2 id="vpg算法">VPG算法</h2><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Policy gradient</th></tr></thead><tbody><tr class="odd"><td>构建策略网络 <span class="math inline">\(\pi_{w}(a \mid s)\)</span> ，并随机初始化参数</td></tr><tr class="even"><td>重复下面步骤：</td></tr><tr class="odd"><td>- 用策略 <span class="math inline">\(\pi_{w}(a \mid s)\)</span> 与环境交互，产生大量 <span class="math inline">\(\tau\)</span></td></tr><tr class="even"><td>- 计算 <span class="math inline">\(\nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right)r(\tau)\)</span> 的均值，作为策略梯度 <span class="math inline">\(\nabla_wJ(w)\)</span> 的估计</td></tr><tr class="odd"><td>- 让 <span class="math inline">\(w\)</span> 沿着策略梯度的方向前进：<span class="math inline">\(w = w + \alpha\,\nabla_{w} J(w)\)</span></td></tr><tr class="even"><td>直到收敛</td></tr></tbody></table><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqfrynopsj30tp0ga77s.jpg" style="zoom:50%;" /></p><h1 id="actor-critic">Actor-Critic</h1><h2 id="ac的出发点">AC的出发点</h2><p>上述策略梯度式 <span class="math inline">\((\ref{7})\)</span> 可以理解为：“用带有权重的训练集去训练策略网络”，对于每一步决策，我们用一个能衡量这步决策好坏的“学习权重” <span class="math inline">\(r(\tau)\)</span> 去”促进“或”抑制“当前轨迹 <span class="math inline">\(\tau\)</span> 上的所有决策 <span class="math inline">\(\pi_{w}(a \mid s)\)</span> 。<span class="math inline">\(r(\tau)&gt;0\)</span> ，则”促进“这个轨迹上的所有策略；<span class="math inline">\(r(\tau)&lt;0\)</span> ，则”抑制“这个轨迹上的所有策略。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjrbg6to5vj318z0ch45l.jpg" /></p><p>但是，即使 <span class="math inline">\(r(\tau)&gt;0\)</span> ，轨迹 <span class="math inline">\(\tau\)</span> 上也有可能出现少量差的决策，如果采用上面的方法，会同时”促进“这些差的决策。<strong>在采样样本比较有限的情况下，这可能会导致巨大的均方误差</strong>。</p><p>一个最自然的想法是，<strong>我们不应该将一个 <span class="math inline">\(\tau\)</span> 上所有 <span class="math inline">\((s, a)\)</span> 编成一个batch，用一个统一的“权重” <span class="math inline">\(r(\tau)\)</span> 来衡量它们的好坏。而应该找出一个“权重”能够单独衡量每一个 <span class="math inline">\((s, a)\)</span> 的好坏</strong>。</p><h2 id="对策略梯度的优化">对策略梯度的优化</h2><h3 id="不要受过去的影响dont-let-the-past-distract-you">不要受过去的影响（Don’t Let the Past Distract You）</h3><p>回顾我们的策略梯度表达式 <span class="math inline">\((\ref{7})\)</span> ，他将“轨迹”上<strong>每个动作</strong>的对数概率都乘了一个“权重” <span class="math inline">\(r(\tau)\)</span> （曾经与将来所有奖励的总和）。</p><p>但这没有多大意义。智能体实际上仅应根据其<strong>采取动作后的 <em>结果</em> 强化动作</strong>。采取动作之前获得的奖励与该动作的效果无关。这种直觉体现在数学上，可以证明策略梯度也可以表示为： <span class="math display">\[\nabla_{w} J(w) = E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right) \sum_{t‘=t}^{T}R(s_{t&#39;},a_{t&#39;},s_{t&#39;+1}) \right] \\= E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right) \hat{Q}(s_t,a_t) \right]\label{9}\]</span> <img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjq3p6w8muj30k70cxwgf.jpg" style="zoom:60%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqfnq05f7j30uv0gzgpc.jpg" style="zoom:50%;" /></p><p><strong>为什么这样做会更好</strong>？策略梯度的关键问题是需要多少个样本轨迹才能获得它们的低方差样本估计。 我们从公式开始就包括了与过去的奖励成比例的强化动作的项， 它们均值为零，但方差不为零：导致它们只会给策略梯度的样本估计值增加噪音。 通过删除它们，<strong>减少了所需的样本轨迹数量</strong>。</p><h3 id="hatqs_ta_t-的baseline"><span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 的Baseline</h3><p>式 <span class="math inline">\((\ref{9})\)</span> 用当前动作的”状态-动作“价值函数的估计 <span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 作为衡量本次决策的”权重“，看起来是很合适的，但是必须考虑这样一种情形：在回报都是大于零的环境中（例如贪吃蛇游戏，把游戏结束时蛇身的长度作为回报），<strong><span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 会是恒正的值</strong>，按照上面的思路，<strong>即使是一个很差的决策（例如游戏结束时蛇身长为3），策略梯度也会在”权重“ <span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 的作用下比较缓慢的”促进“这个决策</strong>。</p><p>但是，如果我们采样了 <span class="math inline">\(N\)</span> 条轨迹，就可以<strong>用 <span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 减去自己的均值，使得比均值小的 <span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 变为负，比均值大的 <span class="math inline">\(\hat{Q}(s_t,a_t)\)</span> 变为正，”赏罚分明“的进行训练策略</strong>。</p><p>那么，给式 <span class="math inline">\((\ref{9})\)</span> 策略梯度的 <span class="math inline">\(\hat{Q}(s_t,a_t)+b(s_t)\)</span> 后该式还成立吗？可以证明它仍然是成立的。</p><p>由ELPG引理可得： <span class="math display">\[E_{w}\left[\nabla_{w} \log \left(P_{w}(x)\right) b\right]=\int_{x} \nabla_{w} P_{w}(x)b\  dx = b \nabla_{w} \int_{x} P_{w}(x)\  dx=0\]</span> 所以： <span class="math display">\[\nabla_{w} J(w) = E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right) \left(\hat{Q}(s_t,a_t)-b(s_t)\right) \right]\]</span> 其中 <span class="math inline">\(b(s_t)=\frac{1}{N} \sum_i^N Q_{i,t}\)</span> ，它可以看作是对状态值函数 <span class="math inline">\(V(s_t)=E_w(Q(s_t,a_t))\)</span> 的估计，因此<strong>策略梯度可以表示为</strong>： <span class="math display">\[\nabla_{w} J(w) \approx E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right) \left(\hat{Q}(s_t,a_t)-V(s_t)\right) \right]\label{12}\]</span></p><p>而由Bellman Equation知道：<span class="math inline">\(A(s_t,a_t)=Q(s_t,a_t)-V(s_t)\)</span> ，因此策略梯度又可以表示为： <span class="math display">\[\nabla_{w} J(w) \approx E_{w} \left[\sum_{t=0}^{T} \nabla_{w} \log \pi_{w}\left(a_{t} \mid s_{t}\right) A(s_t,a_t) \right]\label{13}\]</span> 由于： <span class="math display">\[Q(s_t,a_t) = r(s_t,a_t)+V(s_{t+1}) \\A(s_t,a_t) \approx r(s_t,a_t)+V(s_{t+1})-V(s_{t})\]</span> 所以，计算策略梯度式 <span class="math inline">\((\ref{12})\)</span> 的关键是计算 <span class="math inline">\(V(s_t)\)</span> 。实际上，无法精确计算 <strong><span class="math inline">\(V(s_t)\)</span> ，通常这是通过神经网络 <span class="math inline">\(V_{\phi}(s_t)\)</span> 来近似的（Value net）</strong>。该神经网络会与策略同时进行更新（以便价值网络始终近似于最新策略的值函数）。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqc1z6kmgj321i0n2e2s.jpg" style="zoom:20%;" /></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqfpvb4qaj30vg0g377r.jpg" style="zoom:50%;" /></p><h3 id="value-net怎么更新">Value net怎么更新</h3><p>Value net的目的是估计 <span class="math inline">\(V(s_t)\)</span> ，那么最小化它们之间的均方误差就可以作为一个监督信号，用来在神经网络中反向传播学习 <span class="math inline">\(V_{\phi}\)</span> 。 <span class="math display">\[\begin{eqnarray*}L(\phi) &amp;=&amp; \frac{1}{N}\sum_{i}^{N} {\left\| V_{\phi}(s_{i,t})-V(s_{i,t}) \right\|}^2 \\&amp;=&amp; \frac{1}{N}\sum_{i}^{N} {\left\| V_{\phi}(s_{i,t})-\left(r(s_{i,t},a_{i,t})+V_{\phi}(s_{i,t+1})\right) \right\|}^2\end{eqnarray*}\]</span> 至此，Value net可以通过训练，很好的估计 <span class="math inline">\(V(s_t)\)</span> 。将它替代VPG中的 <span class="math inline">\(r(\tau)\)</span> 作为”权重“，指引策略网络学习最优策略。同时也达到了本节开始提出的目的——找出一个能够单独衡量每一个 <span class="math inline">\((s, a)\)</span> 好坏的“权重”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqdcs4up3j30s60dvgnb.jpg" style="zoom:50%;" /></p><h2 id="actor-critic算法">Actor-Critic算法</h2><p>AC算法的大体框架是这样的：我们定义两个神经网络：一个是用来计算 <span class="math inline">\(V_{\phi}(s_t)\)</span> 价值网络，另一个则是策略网络。我们用策略网络与环境交互产生许多数据集，并用这些数据集同时训练两个网络，提升网络的性能。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gjqemesrcyj31bs0rqdpk.jpg" /></p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Actor-Critic</th></tr></thead><tbody><tr class="odd"><td>构造并初始化Value net的参数 <span class="math inline">\(w\)</span> 和Policy net的参数 <span class="math inline">\(\phi\)</span></td></tr><tr class="even"><td>重复以下步骤：</td></tr><tr class="odd"><td>- 通过Policy net与环境交互产生数据集 <span class="math inline">\((s,a,r,s&#39;)\)</span></td></tr><tr class="even"><td>- 训练Value net：让 <span class="math inline">\(\phi\)</span> 沿着使损失 <span class="math inline">\(L(\phi)=\left\| V_{\phi}(s)-(r+V_{\phi}(s&#39;)) \right\|^2\)</span> 下降的方向前进</td></tr><tr class="odd"><td>- 训练Pollicy net：让 <span class="math inline">\(w\)</span> 沿着梯度 <span class="math inline">\(\nabla_wJ(w)\)</span> 的方向前进</td></tr><tr class="even"><td>直到收敛</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> Algorithm </tag>
            
            <tag> PG </tag>
            
            <tag> AC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论4】状态空间</title>
      <link href="post/63561af6.html"/>
      <url>post/63561af6.html</url>
      
        <content type="html"><![CDATA[<p>DRL的状态信息代表了agent所感知到的环境信息，以及因自身的action带来的变化。状态信息是agent制定决策和评估其长期收益的依据，而状态设计的好坏直接决定了DRL算法能否收敛、收敛速度以及最终性能，兹事体大，不可不察。</p><a id="more"></a><h2 id="前言">前言</h2><p>DRL的状态信息代表了agent所感知到的环境信息，以及因自身的action带来的变化。状态信息是agent制定决策和评估其长期收益的依据，而状态设计的好坏直接决定了DRL算法能否收敛、收敛速度以及最终性能，兹事体大，不可不察。通常在一些公共平台，如Gym，大部分domain的状态空间都是现成的，学者们在上边比的是谁的算法收敛快、性能好；然而，在实际项目中，状态空间设计工作却要自己来，根据我的个人经验，增加一个优秀的新状态信息所带来的性能提升明显高于其他方面的工作（如调参），性价比非常高，因此状态空间的优化工作几乎贯彻项目始终。</p><p>大家注意到我多次使用“设计”这个词，这不就是特征工程（feature engineering）嘛，9102年都快过完了，怎么还搞这一套？直接上深度神经网络呀！真要那么简单就好了……把所有原始信息一股脑堆砌起来，让神经网络去挑选其中有用的成分并学习它们与决策间的相关性，原理上是没毛病的，可端到端的DRL学习效率实在不太给力，比有监督学习差老远了，即使经过大量训练神经网络能够最终提取到有用信息，因为训练时间的延长也会导致算法实用性的下降。更糟糕的是，一些不相关的干扰信息还会起到反作用。因此，要想在可控时间内得到比较好的policy，的确需要人为筛选出一些好的状态信息，可以是raw information，也可以是经过二次加工的信息，帮助神经网络更轻松准确地建立起决策相关性。</p><h2 id="状态设计的四个步骤">状态设计的四个步骤</h2><p>那么具体该如何做呢？我把状态空间设计的精髓总结成以下4个步骤：<strong>任务分析，相关信息筛选，统一性考虑，效果验证</strong>。</p><h3 id="任务分析">任务分析</h3><p>任务分析是状态设计的灵魂，好的状态信息建立在对任务逻辑的深入理解之上。客户提出最终目标，优秀的算法工程师需要把这个目标进一步分解，研究该目标的本质是什么，要实现它涉及到哪些重要环节，每个环节有哪些影响因素，每个因素又由哪些信息体现。对任务逻辑的深入分析也有助于我们设计优秀的回报函数（reward），并反哺状态空间的设计。对一个复杂任务的理解，除非天赋异禀或者相关经验丰富，一般都是要经过一段时间的摸爬滚打后才会深入到一定程度，期间还可能不断推翻之前的错误认知，更伴随瞬间顿悟的喜悦，因此要保持足够的耐心。</p><figure><img src="https://pic4.zhimg.com/80/v2-01caa34cfa02775aea2338356345965f_1440w.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>为了便于说明，这里引入一个简单任务场景：在一个遍布障碍物的平面区域内有若干辆小车在随机位置待命，现在要求它们以最短时间行驶到各自的终点位置停下来，期间避免与障碍物或者其他小车发生碰撞。我们可以把上述目标分解成三部分：1.达到终点，2.避免碰撞，3.用时短。到达终点要求小车知道自己在哪，还要知道终点在哪；避免碰撞要求小车知道附近障碍物的位置，自己和周围其他小车的位置及运动状态；用时短要求小车少绕路，行驶速度快，尽量避免减速和刹车。</p><h3 id="相关信息筛选">相关信息筛选</h3><p>带着以上分析，我们就可以进入下一个环节——相关信息筛选。顾名思义，就是在所有可用信息中找出与任务目标、子目标有关的那些。我们都知道RL任务逻辑最终是以回报函数（reward）为载体呈现的，而RL算法优化的则是该reward系统下的长期累计收益。神经网络的作用是将原始状态信息经过层层非线性提炼后转化为与长期收益高度关联的形式，并进一步指导生成action决策。理想情况下，状态空间应该完全由筛选出的相关信息组成。某个状态信息所代表的事件在越短时间内得到反馈，神经网络就越容易学会如何对其进行加工并建立起决策相关性。按照这个反馈时间的长短，我们还可以粗略地将这些相关信息分为直接相关信息和间接相关信息。</p><h4 id="直接相关信息">直接相关信息</h4><p>所谓直接相关信息，就是与某个reward奖励项或惩罚项即时联动的信息。比如为了更有效地避免小车之间发生碰撞，回报函数里设计了“最近小车距离反比”惩罚项 <span class="math inline">\(-\alpha\cdot max(D-d_{min})\)</span> ，其中 <span class="math inline">\(D\)</span> 是靠近惩罚阈值，当agent与周围最近小车距离 <span class="math inline">\(d_{min}\)</span> 小于 <span class="math inline">\(D\)</span> 时，即开始反比惩罚，靠得越近罚得越多。这里的 <span class="math inline">\(d_{min}\)</span> 相对于该惩罚项就属于直接相关信息，agent在每一步都能收到与 <span class="math inline">\(d_{min}\)</span> 线性相关的反馈，很容易建立起决策相关性。再举一个例子，我们希望小车在电量不足时主动停止工作转而去指定地点充电，除了在reward中设置电量不足的惩罚项，同时也应该在状态空间中增加当前剩余电量，小于设定阈值时即在每步做惩罚。这也属于直接相关信息，没有这个信息，小车是无法建立起电量不足与该惩罚的相关性的，也就无从学会主动去充电。</p><figure><img src="https://pic4.zhimg.com/80/v2-693ce767b89268e291f373e7f1baa443_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>直接相关信息不仅对DRL算法学习很友好，在有对口reward奖励/惩罚项的前提下，对算法工作者来说也更容易设计。事实上，DRL的状态空间设计往往和reward设计同时进行，为了达到某个目的需要增加一项奖励/惩罚，并相应增加一个或多个直接相关状态信息，帮助模型识别现象与反馈之间的因果关系，这一设计理念很直观也很有效。</p><h4 id="间接相关信息">间接相关信息</h4><p>间接相关信息指的是reward中没有即时联动项的状态信息，其所代表的事件需要一段时间后才得到反馈。相对于直接相关信息，DRL利用它们建立决策相关性的难度更高，学习效率更差。比如下图中的游戏画面，agent要通关必须先吃钥匙，假如reward没有专门设置“吃钥匙”的奖励项，那么吃钥匙的好处要等到通关的时候才能体现出来。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221220441.png" /></p><p>再比如小车要学会到达终点，当前位置坐标、朝向、速度、加速度、终点坐标、周围障碍物的分布似乎都与到达终点这一目标有关，假如我们暂时没有针对这个目标做更细化的credit assignment，而只设置了到达终点奖励，那么这些信息就都属于间接相关信息，agent只有经过充分探索后才能发现某时刻这些信息的变化与最终达到终点之间的联系。</p><p>间接相关信息通过某些手段可以转化为直接相关信息，从而提高DRL的学习效率。最简单的方法是对任务目标做更详细的credit assignment并增加相应的reward奖励/惩罚项，如果某状态信息恰好与之即时联动，相应状态信息就成为了直接相关信息。还以小车为例，如果在reward中增加靠近终点奖励或远离终点惩罚，那么小车的朝向（配合小车当前坐标和终点坐标）就成为了直接相关信息。更多关于reward函数设计的内容我在下一篇中再详细介绍。</p><h4 id="相关信息预处理">相关信息预处理</h4><p>无论是直接相关还是间接相关，原始信息都要经过神经网络的提炼才能转化为action输出，提炼难度与学习效率和最终性能呈反向相关。如果我们提前对原始信息做些二次加工，人为提炼出与学习目标更相关的因素，相当于替神经网络干了一部分活儿，虽然不那么elegant，但往往能收到奇效。举个极端例子，直接告诉agent钥匙的相对坐标在哪儿，一定比神经网络通过原始图像更容易学到吃钥匙的操作。由于强化学习的优化目标是折扣累加的长期收益，这使得reward起作用的方式较为间接，无法像有监督学习那样为神经网络的feature extraction提供很好的指导，这也是DRL训练效率低下的根本原因。因此，我们在状态空间上多下一点功夫，DRL学习的难度就降低一点。在资源有限的情况下这很有可能就是训不出来和训得出来的区别，也有可能是性能不达标与性能达标的区别。</p><h3 id="统一性考虑">统一性考虑</h3><p>当我们已经筛选出了所有相关信息，接下来该以何种形式使用它们呢？把他们拉成一组向量塞到神经网络里行不行？当然可以，但那样做只能得到适用于当前特定场景的policy。比如状态信息中包含了其他小车的信息，则训练出的policy只适合特定数量小车的任务，假如车数增加或减少，输入向量维度随之变化，policy就没法用了。因此，我们必须合理设计状态信息使其对环境主要因素的改变有最起码的兼容性，我把它称之为统一性考虑。具体地，这里的统一性又包含形式统一和逻辑统一。</p><h4 id="形式统一">形式统一</h4><p>为了保证输入向量长度恒定，我们需要找到一种统一形式把不同信息填到对应的位置。比如小车周围装了一圈测距雷达，按固定顺序输出一维距离向量，那么无论把小车放到什么地方，这些信息所代表的含义也不会变；或者采用imagelike的状态表示方式，把地图信息网格化，无论是作为二维channel或拉成一维向量，都能保持外在形式的统一。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221220745.png" /></p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210221220554.png" /></p><p>针对上述第二种方案，为了将信息离散化到网格点上，不可避免地会带来精度损失。但在实际应用中，只要网格尺寸合理，这样的精度损失是可以接受的。事实上，离散化操作本身会在一定程度上降低学习难度从而带来性能的提升，有paper报告在Montezuma's Revenge游戏里通过离散化agent和环境的信息，DRL模型性能不仅没有下降，反倒提升了30%多。</p><h4 id="逻辑统一">逻辑统一</h4><p>状态空间只做到外在形式统一是不够的。比如我们把小车当前位置 <img src="https://www.zhihu.com/equation?tex=%5Cleft%28x_%7B0%7D%2Cy_%7B0%7D%5Cright%29" alt="[公式]" /> 和终点位置坐标 <img src="https://www.zhihu.com/equation?tex=%5Cleft%28x_%7B1%7D%2Cy_%7B1%7D%5Cright%29" alt="[公式]" /> 作为状态信息同时输入网络，按照DRL的过拟合天性，神经网络最终会记住这张地图每个坐标处的特征以及在这里通行的最佳路线，policy在这幅地图里测试性能会很高，但换幅地图就完全不能用了。通常情况下，我们并不希望DRL用这种方式获得高性能，而是希望它能学会应对不同地形的通用知识，即使换张地图也至少能达到“勉强能用”的地步，再通过在新地图中finetune即可快速具备实用价值。因此，更合理的方式是将两个绝对坐标合并为一个相对坐标<img src="https://www.zhihu.com/equation?tex=%5Cleft%28x_%7B1%7D-x_%7B0%7D%2Cy_%7B1%7D-y_%7B0%7D%5Cright%29" alt="[公式]" /> ，即终点位置在小车坐标系中的坐标，这样就可以使policy与具体地图“脱钩”，从而学习到更加通用的导航知识。可见，<strong>要想让网络学到我们希望它学到的知识，前提是输入正确形式的状态信息</strong>。</p><p>再说回上一节的自动充电任务，如果输入的是绝对电量，而不包含低电量阈值（预警电量），DRL模型需要通过大量探索，根据当前电量与是否被惩罚的经验去摸索出预警电量是多少，并用于指导action的生成。这个隐性阈值会固化到网络参数中，如果客户后续希望提升预警电量，policy就又要用新阈值重新训练了。为了避免这种情况，我们可以把绝对电量改为相对电量（绝对电量/预警电量），能够直接反映当前电量与预警电量的关系，即使预警电量被改变也不影响模型的使用，因为此时固化到网络参数中的知识不再是某个电量阈值而是比例阈值。</p><h3 id="效果验证">效果验证</h3><p>当我们设计好状态空间或对原状态空间进行修改后，接下来需要通过实验验证其是否达到预期效果。验证方法可以分为三类：模仿学习验证，直接验证和缺省验证。</p><h4 id="模仿学习验证">模仿学习验证</h4><p>如果项目已经有一个较好的baseline，可以搭建一个policy网络，专门模仿该baseline在各种状态下的action，如果状态中包含了正确决策所需的相关信息，那么得到的policy性能就会越接近baseline。考虑到有监督学习的高效性，这是验证状态信息有效性的一种较快方式，尤其适用于项目初期一片懵懂的时候。</p><h4 id="直接验证">直接验证</h4><p>如果没有这样的baseline，那就只能用直接验证了，即用DRL训练一个policy并验证其效果。为了提升效率，可以只比较训练中途（固定步数、固定数据量）的性能，因为一般情况下好状态和差状态的won-lost关系在较早的时候就确定了。另外由于DQN收敛速度相对较快，可以优先考虑用来验证新状态。</p><h4 id="缺省验证">缺省验证</h4><p>当我们已经训练得到一个不错的policy时，可以用缺省的方式验证每个状态信息的作用大小，即正常输入其他信息，而将目标信息取合理区间内的定值（如区间中点），测试性能损失的百分比。损失越大说明该状态信息越关键，反之则说明作用越边缘化，有时候甚至会发现性能不降反升，说明该信息有干扰作用，还是去掉的好。缺省验证的意义在于，剔除那些无用或起反作用的状态，为进一步优化关键状态和弱作用状态提供指导。</p><h2 id="总结">总结</h2><p>与学术研究不同，在DRL落地工作中，状态空间设计是如此的重要，所以我用了很长的篇幅探讨了其中各种细节。此外，尽管我已经十分克制，但仍然不得不引入了大量关于回报函数（reward）的描述和设计理念，这是因为在实践中，状态空间和回报函数的设计几乎是水乳交融的，很难做到泾渭分明，往往修改了其中一个，另一个也需要相应做出改变。在下一篇中，我将集中介绍回报函数的设计，当然难免也会涉及到一些状态空间设计的内容，总之，一起服用效果更佳~</p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Tools-Tmux】Tmux技巧</title>
      <link href="post/cc4db011.html"/>
      <url>post/cc4db011.html</url>
      
        <content type="html"><![CDATA[<p>tmux 是一款终端复用命令行工具，一般用于 Terminal 的窗口管理。</p><a id="more"></a><h2 id="为什么选择tmux">为什么选择tmux</h2><p>在 macOS 下，使用 iTerm2 能应付绝大多数窗口管理的需求。如<img src="https://img-blog.csdnimg.cn/20201024212759972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" /> 图所示，iTerm2 能新建多个标签页（快捷键 ⌘T），也能在同一个窗口中分割出多个窗格（快捷键 ⌘D 或 ⌘⇧D）。</p><p><strong>tmux 相比 iTerm2 的优势在于：</strong> - iTerm2 的窗格切换快捷键（⌘⌥→）容易与其他软件全局快捷键冲突（例如 Spectacle 的窗口分割快捷键），tmux 由于存在前缀快捷键，所以不存在快捷键冲突问题； - tmux 可以在终端软件重启后通过命令行恢复上次的 session ，而终端软件则不行； - tmux 简洁优雅、订制性强，也能在 Linux 上使用。</p><h2 id="安装">安装</h2><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">brew</span> install tmux</span></code></pre></div><h2 id="快捷键">快捷键</h2><p>一般情况下 tmux 中所有的快捷键都需要和<strong>前缀快捷键 ⌃ B</strong> 来组合使用（⌃ 即 Mac 的 control 键），以下是常用的窗格（pane）快捷键列表，大家可以依次尝试下： ## 窗格操作 | ^ B之后组合键 | 作用 | | ------------- | ------------------------------------------------------------ | | % | 左右平分出两个窗格 | | " | 上下平分出两个窗格 | | x | 关闭当前窗格 | | { | 当前窗格前移 | | } | 当前窗格后移 | | ; | 选择上次使用的窗格 | | o | 选择下一个窗格，也可以使用上下左右方向键来选择 | | space | 切换窗格布局，tmux 内置了五种窗格布局，也可以通过 ⌥1 至 ⌥5来切换 | | z | 最大化当前窗格，再次执行可恢复原来大小 | | q | 显示所有窗格的序号，在序号出现期间按下对应的数字，即可跳转至对应的窗格 |</p><h2 id="窗口操作">窗口操作</h2><p>tmux 除了窗格以外，还有窗口（window） 的概念。tmux 的窗口操作： | ^ B之后组合键 | 作用 | | ------------- | ------------------------------------------------------------ | | c | 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态 | | p | 切换至上一窗口 | | n | 切换至下一窗口 | | w | 窗口列表选择，注意 macOS 下使用 ⌃p 和 ⌃n 进行上下选择 | | &amp; | 关闭当前窗口 | | , | 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id | | 0 | 切换至 0 号窗口，使用其他数字 id 切换至对应窗口 | | f | 根据窗口名搜索选择窗口，可模糊匹配# | ## 会话操作 在 shell 主进程下运行以下命令可以操作 tmux 会话：</p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">tmux</span> new -s foo             # 新建名称为 foo 的会话</span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ex">tmux</span> ls                     # 列出所有 tmux 会话</span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ex">tmux</span> a                      # 恢复至上一次的会话</span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ex">tmux</span> a -t foo               # 恢复名称为 foo 的会话，会话默认名称为数字</span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="ex">tmux</span> kill-session -t foo    # 删除名称为 foo 的会话</span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ex">tmux</span> kill-server            # 删除所有的会话</span></code></pre></div><p>在 tmux 会话中，使用<strong>前缀快捷键 ⌃b</strong> 配合以下快捷键可操作会话： - $ 重命名当前会话 - s 选择会话列表 - d detach当前会话，运行后将会退出 tmux 进程，返回至 shell 主进程</p><p>除以上提到的快捷键以外，tmux 还有许多其他的快捷键和命令，使用前缀快捷键 ⌃b 加 ? 可以查看所有的快捷键列表，该列表视图为 tmux copy 模式，该模式下可使用以下快捷键（无需加 ⌃b 前缀）： - ⌃v 下一页 - Meta v 上一页 （tmux 快捷键为 Emacs 风格，这里的 Meta 键可用 Esc 模拟） - ⌃s 向前搜索</p><h2 id="滚屏设置">滚屏设置</h2><p>要退出复制模式，请按ESC键 要在此模式（称为复制模式）下使用鼠标，请按 <strong>^b + :</strong> 并输入以下内容：</p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">setw</span> -g mouse on</span><span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co"># 注意：在tmux &lt;2.1中，该选项名为mode-mouse，而不是mouse</span></span><span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span><span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="st">&quot;每次运行tmux时都将其加载，以使用滚屏&quot;</span></span><span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;setw -g mouse on&quot;</span> <span class="op">&gt;&gt;</span> ~/.tmux.conf</span></code></pre></div><p>更新：从tmux 1.5开始，此选项使使用滚轮自动切换到复制模式并向后滚动tmux回滚缓冲区。没有必要先打Ctrl-B+ [。向下滚动到提示也会自动结束复制模式。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论3】动作空间</title>
      <link href="post/82d3f6a1.html"/>
      <url>post/82d3f6a1.html</url>
      
        <content type="html"><![CDATA[<p>在将DRL应用于实际项目时，可能最轻松愉快的部分就是动作空间定义了。倒不是因为这项工作简单，而是agent的控制方式往往早就定死了，留给我们发挥的空间很小，就好像我们无法决定DOTA里允许多少种操作，也无法改变一台机器人的关节数量和各自的角度范围，Gym用户甚至从来都不用为这个问题操心，action空间有多少维，连续还是离散，各种domain早就都定义好了，我们根据这些性质判断任务的难度，仅此而已。选择困难症患者表示松了一口气有木有~~~当然咯，如果运气足够好，agent提供了多种控制选项并允许我们自由选择时，一定要珍惜这种机会。</p><a id="more"></a><h2 id="对动作空间的两个要求">对动作空间的两个要求</h2><h3 id="完备性">完备性</h3><p>动作空间首先要提供实现预期目标的可能性，比如一辆车必须具备加减速、转弯和刹车功能才可以实现导航和防撞任务。动作空间应尽可能简单高效，为了降低训练难度提升算法性能，尽量选择<strong>离散动作空间，即互斥、可穷举，能够表示成one-hot形式</strong>，这样无论用DQN或A3C训练都很方便。即使agent本身是连续控制方式，也可以尝试将区间离散化，担心精度就分得细一些，这样做是有可能取得比连续控制更好的性能的。如果必须采用连续动作空间，须注意把各维度区间归一化，即映射到[-1,1]之间，在policy网络输出层加个tanh激活（DDPG就是这么做的），从而避免因实际数值不统一造成的学习困难。</p><h3 id="合法性">合法性</h3><p>还有一点值得注意，在DRL应用中并不是所有action在任何state下都有效，比如AlphaGo就不能在棋盘上已经被占据的位置落子，骑自行车时也最好别倒蹬车，自动驾驶车辆遇到行人时绝对不能撞上去。<strong>对于特定状态下规则不允许出现的action或者引发严重后果的action，我们应该直接屏蔽掉</strong>。DRL与其他AI算法一样，都属于统计学范畴，我们在理解policy输出时也应该使用概率思维，即使agent学会在99.99%的情况下输出合法action，但仍存在0.01%的可能性输出非法action，与其寄希望于DRL完全学会遵守规则，不如加一层“硬保险”来得靠谱。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225214617.jpeg" /></p><h2 id="结语">结语</h2><p>关于动作空间的内容不多，DRL算法工作者的主战场在其他方面，比如下一篇我们将要介绍的重头戏——状态空间设计。</p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论2】算法分析</title>
      <link href="post/3a9bccd9.html"/>
      <url>post/3a9bccd9.html</url>
      
        <content type="html"><![CDATA[<p>虽然每年RL方向的paper满天飞，但真正具有普遍实用价值的突破性工作实在不多，大多数还是在经典框架基础上的改进和扩展。DRL常规武器库里的存货主要还是老三样：DQN，DDPG和A3C，它们是深度学习时代最成熟、最能体现智慧结晶的三个DRL框架，我们可以在GitHub上找到无数相关代码，有OpenAI，DeepMind和Nvidia这些大公司的，也有个人爱好者的。对于DRL初学者，它们是最佳的敲门砖；对于算法研究者，它们是最厚实的“巨人肩膀”；对于算法工程师，它们是最顺手的试金石。当然，这三个算法框架都有各自的特点和适用domain，结合对项目的分析，是可以提前评估最合适的算法的。</p><a id="more"></a><h2 id="强化学习探索和利用的平衡游戏">强化学习——探索和利用的平衡游戏</h2><p>总体来说，<strong>强化学习是一个探索（Exploration）和利用（Exploitation）的平衡游戏</strong>，前者使agent充分遍历环境中的各种可能性，从而有机会找到最优解；后者利用学到的经验指导agent做出更合理的选择。两者之间可以说是相爱相杀的关系：</p><ol type="1"><li>充分的探索才能带来有效的利用，从而使RL走在正确的道路上。对于那些难度特别高的任务，改进探索策略是性价比最高的手段，比如AlphaGo使用蒙特卡洛决策树征服了围棋，Go-Explore利用状态回访打爆了Montezuma's Revenge；</li><li>充分的利用才能探索到更好的状态，agent往往需要掌握基本技能，才能解锁更高级的技能。就好像小孩先要学会站起来，才能学会走，然后才能学会跑。这种从易到难、循序渐进的思想在RL中也很受用，著名的Curriculum Learning就是由此而来；</li><li>过量的探索阻碍及时的利用。如果随机探索噪声强度过高，已经学到的知识会被噪声淹没，而无法指导agent解锁更好的状态，导致RL模型的性能停滞不前；</li><li>机械的利用误导探索的方向。如果刚刚学到一点知识就无条件利用，agent有可能被带偏，从而陷入局部最优，在错误道路上越走越远，在训练早期就扼杀了最好的可能性。</li></ol><p><strong>强化学习的训练过程其实就是从以探索为主到以利用为主的过渡过程</strong>，训练早期通过广泛试错找准一个方向，然后沿着该方向一路试探下去直到达到最优。请牢牢记住这“两点一线”，因为这是所有RL算法的主要内容，任何RL算法都能以此为切入点进行解构，有助于不断加深对算法的理解。接下来就谈谈对三个主流DRL框架的一些浅见。</p><h2 id="dqn">DQN</h2><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225135416.png" /></p><p>DQN是借助AlphaGo最早成名的深度强化学习算法，其核心思想是利用Bellman公式的bootstrap特性，不断迭代优化一个 <span class="math inline">\(Q(s,a)\)</span> 函数，并据此在各种状态下选择action。其中 <span class="math inline">\(Q(s,a)\)</span> 函数拟合的是一对状态-动作的长期收益评估，该算法没有显式的policy。DQN探索和利用的平衡靠的是一种称为<code>ε-greedy</code>的策略，针对最新的 <span class="math inline">\(Q(s,a)\)</span> 函数和当前的输入状态 <span class="math inline">\(s\)</span> ，agent做决策时以概率 <span class="math inline">\(p\)</span> 随机选择action，而以 <span class="math inline">\(1-p\)</span> 的概率选择使 <span class="math inline">\(Q(s,a)\)</span> 最大的action，随着 <span class="math inline">\(p\)</span> 从大到小变化，DQN也相应地从“强探索弱利用”过渡到“弱探索强利用”。DQN的原理使其天然地适合那些具备有限action集合的任务，说白了就是action可以穷举，比如走迷宫的agent只允许前后左右4个动作，下围棋的AlphaGo只允许 <span class="math inline">\(19*19=361\)</span> 个落子位置（实际还要排除已经落子的网格点）。这是一个重要的特征，如果是一个连续控制任务，action在某区间内有无数种可能，那就不适合用DQN了。当然，我们可以选择把区间离散化，这样就可以应用DQN了，也曾有paper报告这样做在某些任务中可以比连续控制取得更好的性能。</p><p>DQN属于off-policy方法，所谓off-policy是指用于计算梯度的数据不一定是当前policy/Q下采集的，DQN使用一个叫replay buffer的FIFO结构，用于存储transition，即 <span class="math inline">\((s,a,s&#39;,r,q)\)</span> ，每次随机从buffer中拿出一个batch用于梯度计算和参数更新。Replay buffer是稳定DQN训练的重要措施，历史数据的重复使用也提高了其数据利用率，对于那些数据比较“贵”的任务，比如Google的抓取应用，这一点非常重要，事实上Google除了replay buffer，还专门搞了个数据库，把之前存储的另一个抓取应用采集的数据拿出来做预训练，精打细算到了极致，真是比你有钱，还比你节约~。</p><p>DQN的缺点挺多，有些是RL的通病，比如对超参数敏感，笔者在训练篇会详细介绍；另一些是DQN所独有的，比如overestimation造成的训练不稳定问题，近些年学术界有不少工作是围绕这一点做出改进。此外，DQN还有off-policy方法的通病，对历史数据的重复利用虽然可以提高数据效率，但有个前提条件是环境model不能发生变化，single agent任务较易满足这个条件，但multi agent场景就未必了，对任意agent而言，其他agent也是环境的一部分，而他们的学习进化会改变这个环境，从而使历史数据失效，这就是MARL领域著名的环境不稳定问题，此时off-policy方法的性能往往不如on-policy方法。 <span class="math display">\[loss = (r + \gamma \max\limits_{a&#39;}Q(s&#39;,a&#39;)-Q(s,a))^2\]</span> 如果超参数设置合适，DQN收敛速度相对是比较快的，因为更新公式里有个<span class="math inline">\(max\)</span>操作，意思是计算目标值时s’状态下使用使<span class="math inline">\(Q(s’,a)\)</span>最大的a从而达到加速收敛的目的（上边说到的overestimation问题也源自于此……）。因此，DQN可以作为在新项目场景中快速测试效果的首选框架，比如测试一个新状态信息或一个新reward项是否有用。</p><h2 id="ddpg">DDPG</h2><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225141747.png" /></p><p>针对DQN无法处理连续控制任务的空白，DDPG在DQN的基础上做了改进，引入了一个输出连续action的显式policy，与 <span class="math inline">\(Q\)</span> 函数组成Actor-Critic结构，更新policy网络的梯度完全来自于 <span class="math inline">\(Q\)</span> 网络，目标是最大化当前的 <span class="math inline">\(Q\)</span> 函数。 <span class="math inline">\(Q\)</span> 函数的更新与DQN类似，只是计算 <span class="math inline">\(s’\)</span> 状态下目标值时放弃了 <span class="math inline">\(\max\)</span> 操作，而采用当前policy网络的输出<span class="math inline">\(π(a|s&#39;)\)</span>。DDPG名字里的第一个<span class="math inline">\(D\)</span>是Deterministic的缩写，意思是确定性的，这是有意与正宗Actor-Critic方法（如A2C，A3C等）区分开，后者policy输出的是action的概率分布，而DDPG输出的就是确定性的action。正因为如此，DDPG采用了独特的探索方式，即在action输出直接加上一个noise，该noise的强弱决定了探索力度，本质上相当于以当前action为中心形成了一个概率分布，每次更新都使policy向该分布中更好的方向演化，直到action达到了最优，此时对应分布内其他方向都是更差的方向，policy输出也就稳定在最优action附近了，从而实现了探索和利用的平衡。</p><figure><img src="https://pic3.zhimg.com/v2-8e4654480ae1bd802293347ad8cd4902_b.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>能用于连续控制任务自然是招人喜欢的，毕竟实际控制任务的变量往往都是连续取值的，比如角度、位移、速度、加速度、电流、电压等等。学者们把DDPG用在MuJoCo上，解决了很多连续domain的任务，后来也有人把它用到真实的软体章鱼机器人上，用两只触角实现了向前运动。然而，在连续区间上找到最优的确定性action输出本身是一件非常困难的事，导致<strong>DDPG在action维度较高的复杂任务中表现不佳</strong>，比如KUKA iiwa机器人有7个自由度，使得探索空间一下大了很多，训练难度陡升。同时policy网络的梯度完全来自于<span class="math inline">\(Q\)</span>网络，<span class="math inline">\(Q\)</span>函数的拟合误差都直接传导给了policy，致使DDPG的训练稳定性也不足。在Google的抓取paper中，干脆抛弃了独立policy网络，做决策时随机在区间里取16个点输入<span class="math inline">\(Q\)</span>网络，然后选择<span class="math inline">\(Q\)</span>值最大的那个作为action，实验结果表明如此粗糙的做法却大大提升了训练稳定性，且性能显著优于DDPG，有点尴尬……</p><p>总结一下，如果我们面对的问题是连续控制任务，action维度又不高，可以尝试用DDPG解决，但也不要忘了离散化动作空间并用DQN训练得到更高性能的可能性。如果action维度很高，那还是别用DDPG的好。如果数据很“贵”不得不用off-policy方法的话，那就向Google学习，拿掉policy网络，直接用Q网络+启发式搜索选择action。如果数据廉价又追求高性能，我推荐用A3C框架——个人比较偏爱的一种框架。</p><h2 id="a3c">A3C</h2><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225142104.png" /></p><p>喜爱A3C的原因很简单，它带给我的成功经验最多。A3C是Actor-Critic框架A2C的扩展。A2C脱胎于经典的REINFORCE梯度方法，其policy输出的不是action，而是关于action的概率分布，因此梯度无法直接从Critic（又称为V网络）流到policy网络，只能用在线样本统计出一个近似梯度。原始REINFORCE梯度形式如 <span class="math inline">\(V(s)\nabla logπ(a|s)\)</span> ，直观解释就是使状态 <span class="math inline">\(s\)</span> 下返回高 <span class="math inline">\(V\)</span> 值的action出现概率更大。缺点是 <span class="math inline">\(V\)</span> 值绝对值不可控（与reward等因素有关），variance很大，造成训练不稳定。A2C把梯度改成 <span class="math inline">\(A(s,a)\nabla logπ(a|s)\)</span> ，<span class="math inline">\(A(s,a)\)</span> 是在线episode计算出的一对<span class="math inline">\(s,a\)</span>的Value值与当前<span class="math inline">\(V\)</span>网络估计值之差，并经过normalization操作，简单理解就是把 <span class="math inline">\(log\)</span> 前的部分做了一个居中 <span class="math inline">\(+\)</span> 归一化，variance降低，训练稳定性显著提升，这里的 <span class="math inline">\(A(s,a)\)</span> 称为 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(s\)</span> 下的advantage，是A2C名字里的第一个‘A’。既然policy输出的是action概率分布，那么探索就很容易实现——按照这个分布采样即可，训练初期分布variance比较大，探索力度强，随着policy不断改善，分布variance越来越小，代表policy对所选action越来越自信，这就实现了对经验的利用。</p><p>A3C在A2C的基础上增加了对并行采样的支持，从而有效利用多核资源，在不同CPU上并行运行不同的环境种子，显著提升了训练稳定性、收敛速度以及最终性能，A3C比A2C名字里多了一个‘A’，代表asynchronous的缩写。A3C支持多种action概率分布，如果action空间是DQN那样的离散集合，可以用Categorical分布；如果是像DDPG那样的多维连续分布，可以用Multivariate Gaussian分布，此外A3C还支持伯努利分布，如果action的每一维都是非此即彼的二值选项，或者one-hot向量太长想改用二进制表示，那就是它了。可见，A3C在通用性上是显著优于DQN和DDPG的，几乎所有任务都能拿A3C跑一跑。此外，A3C作为on-policy方法，每次更新policy的梯度都由当前policy采集的样本计算，这使得A3C在Multi-agent任务里对环境不稳定性的抵抗能力比DQN和DDPG更强。</p><p>和很多paper的实验结果一致，笔者在实际应用中发现A3C+PPO的组合（PPO是一种稳定训练的算法，笔者会在训练篇详细介绍）在连续控制任务里性能显著优于DDPG，对超参数的敏感度也比DDPG低，因此训练起来更加得心应手。因此，笔者推荐在解决连续任务时首选A3C，资源不够就A2C，DDPG的优先级往后放就是了。很多离散action空间的任务也值得用A3C跑一下，跟DQN比一比。</p><h2 id="其他算法">其他算法</h2><p>以上三个DRL框架是基础，大多数情况下都至少能得到一个“能用”的policy。然而，也不应奢望它们能解决一切问题。DRL领域是个大坑，里边有太多需要解决的问题和值得挖掘的方向，比如：高难度探索，稀疏reward，数据效率，训练稳定性，快速适应新环境等等，类似MARL这样的子领域还有自己特有的问题，如环境不稳定性，scalability等等。算法工作者一定要保持开放的态度，及时跟踪学术界的新趋势新方法。每当算法性能遇到瓶颈，首先要沉下心来分析关键制约因素在哪里，如果是上述这些普遍意义上的问题造成，那就去相关方向最新paper中寻找灵感。比如探索不够充分时，可以用count-based exploration或者parameter noise来加强探索；DQN训练不稳定时，可以尝试Double-Q网络，每次选择较小Q值计算目标值，从而抑制overestimation；DQN或DDPG数据效率低时，可以用prioritized replay buffer；MARL里为了改善环境不稳定问题，可以尝试DIMAPG，……。问题无常势，算法无常形，群众智慧是无穷的，博采众长才能攻无不克。</p><p>关于算法选择就先写到这里，不同算法在训练时还有各种各样的trick和注意事项，笔者在训练篇里再详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RL落地方法论1】需求分析</title>
      <link href="post/b901f1b6.html"/>
      <url>post/b901f1b6.html</url>
      
        <content type="html"><![CDATA[<p>任何机器学习方法都不是包治百病的灵丹妙药，它们也有各自的“舒适圈”，有时候还相当挑剔。强化学习，无论前面带不带“深度”二字，也同样有其鲜明的优势和局限性，务必要具体问题具体分析。不是所有需求都适合用DRL做，适合用DRL做的需求也未必能超越传统方法。</p><a id="more"></a><p>在我看来，算法工程师的核心能力可以总结成以下三点：</p><ol type="1"><li>对各种算法本质及其能力边界的深刻理解</li><li>对问题内在逻辑的深入分析</li><li>对两者结合点的敏锐直觉</li></ol><p>一个优秀算法工程师的高光时刻从拒绝不合理的需求开始，其他的都是后话。不经慎重评估而盲目上马的项目不仅是对资源的巨大浪费，更让每个参与者陷在深坑中痛不欲生。知道一种算法不能干什么与知道它能干什么同样重要，对DRL而言，即使在最理想的外部条件下，也有其绕不过去的七寸——泛化无能。这是DRL的基本原理决定的，任何在这一点上提出过高要求的应用都不适合用DRL解决。</p><h2 id="drl的过拟合天性">DRL的过拟合天性</h2><p>DRL解决的是从过去经验中学习有用知识，并用于后续决策的问题。有别于纯视觉应用，DRL不仅仅满足于识别和定位，而是要根据这些信息采取针对性的行动以获取最大长期收益。从本质上说，DRL就是一种依赖过拟合的算法，说白了就是通过暴力搜索把其中的成功经验记下来，并用以指导后续决策。别嫌露骨，别怕尴尬，岂不闻学术界某大牛的辛辣讽刺仍余音绕梁——强化学习是唯一被允许在训练集上测试的算法。由于缺乏直接监督信号用于训练，DRL还特别“费数据”，以至于需要专门的模拟器源源不断地产生数据供其挥霍。好不容易训出来的policy在训练环境用得好好的，换个环境立马歇菜。</p><p>等等，不是说好了DNN有泛化能力吗？ResNet明明能在一张没见过的图片中识别出阿猫阿狗的呀。这是因为任务层次不同，泛化的定义和要求自然也不同。视觉识别层面的泛化可以理解为深度网络学习到了通用的高层语义信息，以至于只要看到类似的像素结构就能与高层语义对应起来。这个层次的泛化能力DRL也可以有，可惜远远不够。我们前边说过，DRL是要根据识别到的信息做出决策以最大化长期收益的，具体地，DRL拟合了一个特定环境、特定reward函数和当前policy下，从特定输入状态（state）到最终收益（episode结束时）的Value函数，再反过来根据这个函数去优化policy，使其输出的action最大化该Value函数。这是一个交替更新的过程，Value函数和policy你中有我我中有你，直到抵达某种纳什均衡。假设探索足够充分，我们可以认为最终的Value函数只由环境特性和reward函数决定。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225214923.png" /></p><p>OK，整理一下DRL的逻辑链条：Value函数过拟合环境特性和reward函数，Policy又过拟合Value函数。一朝天子一朝臣，一种环境一种policy，环境换了，policy废了。在训练环境中agent看到家猫，发现喂食可以得到高回报，于是用policy记了下来，在测试环境中，家猫换成野猫，虽然识别到的还是猫，agent继续喂食，然后就被猫抓了……相信看到这里，你就能明白为什么DRL被允许在训练集上测试了，也明白为什么DRL泛化无能了，因为这个level的泛化要求太TM高了！即使是人类在缺乏相关经验的情况下也会踩坑，但人类能做到吃一堑长一智，甚至从此主动避开所有可能有危险的动物，这得益于人类的两大核心优势：高效学习（只需极少样本）和终身学习（举一反三、融会贯通），而现阶段DRL却只会低效地死记硬背，训练也是一锤子买卖，这是真正的智能对人工智能的降维碾压。</p><h2 id="适用drl的五大特征">适用DRL的五大特征</h2><p>于是我们产生了两个问题：1.是不是DRL就真的一点泛化能力都没有？2.这样的DRL到底有没有实用价值？关于第一个问题我建议读者去了解一些Meta-RL（元强化学习）方向的工作，利用DNN的表征能力，agent能够利用有限的环境探索不断在线学习该环境的特性和reward函数，并据此调整policy的输出使其表现出对新环境的适应能力。但目前也仅能解决一类相似任务间的泛化问题，而代价是训练难度进一步提升，数据效率进一步下降，愿景很美好，实用有点早。第二个问题才是目前我们最关注的，换个问法，到底什么样的任务适合用DRL解决呢?答曰：<strong>场景固定，目标明确，数据廉价，过程复杂，自由度高</strong>。依次解读如下：</p><h3 id="场景固定">场景固定</h3><p>场景固定是指决定系统动态演化趋势的主要因素保持恒定。听起来可能有点抽象，举个例子，agent在环境中遇到一条峡谷，跳过去的过程中有30%的概率被落石击中，这里的30%就属于这类因素，无论在训练和工作的时候都不能改变。用符号表示：状态s=面对峡谷，动作a=跳过去，下一个状态s'的概率分布p(s'|s,a)是明确的，即安全着陆70%，壮烈牺牲30%，这个概率在RL中叫状态转移概率，很多paper又称其为环境的model，对于任何s,a和s'，p(s'|s,a)都明确而恒定的决策过程又称为Markov Decision Process或MDP，RL的理论基础即建立在MDP之上，Value函数和policy就是通过隐式（model-free）或显式(model-based)地对环境model建模得到的。model变了，policy就废了，上边举的家猫和野猫的例子就是这个道理。另一个不满足场景固定的典型例子是DOTA更换地图，基于训练地图得到的局势演化预期在新地图里不成立了。又比如临时要求围棋棋盘里某几个位置不准落子，AlphaGo大概率是要跪的。你要是还不理解，就记住：训练环境尽可能做到与工作（测试）环境相同。</p><h3 id="目标明确">目标明确</h3><p>目标明确很好理解，任务要达到何种效果清晰具体，最好可以量化。工业界的需求一般都是优化某个指标（效率、能耗、胜算等），基本满足这个条件。目标越明确，设计优质的reward函数就越容易，从而训练得到更接近预期的policy。</p><h3 id="数据廉价">数据廉价</h3><p>数据廉价对RL至关重要，毕竟挥霍数据是RL与生俱来的属性，没办法。我们知道视频游戏领域很容易满足这个条件，所以我们最常听说DRL在XX游戏里碾压、吊打、秒杀人类玩家。然而这个要求对牵涉到硬件的应用却相当不友好，Google可以用7台KUKA iiwa机器人（单价80万rmb体会一下）日夜不停跑上几个月训练抓取技能，其他公司怕是连8千的设备撞坏了都心疼，那就只剩下模拟器这一条路了。所谓模拟器，就是将真实场景中的各种物理模型（即上文提到的model）在软件环境中仿真，从而生成无限量的高仿数据。这里有一个reality gap的问题，即这些仿真model与真实世界的误差，如果太大则训练出的policy无法直接应用。一个逼真的模拟器也是要花功夫（钱）的，像MuJoCo这样的优秀仿真平台收费也是合情合理的。</p><p><img src="https://gitee.com/Su-Lemon/sources/raw/master/imgs/blog/20210225215143.png" /></p><p>有心的朋友已经发现，对模拟器精度的要求其实与上文的“场景固定”逻辑上是一致的，之所以分开介绍，是因为廉价还包含了另一层意思——采样速率。AlphaGo和OpenAI Five在宣传的时候动不动就说他们的agent学习了相当于人类XX万年的经验，显然没有高速模拟器是不可能做到的。总之，如果非要做硬件相关的应用，先尽最大努力做出逼真的高速模拟器吧！</p><h3 id="过程复杂">过程复杂</h3><p>如果说前三个特征决定了“能不能”，那么接下来两个特征决定了“值不值”。我们用DRL的目的无非是看中了其处理复杂场景的能力，人类看不透，DRL来凑。如果任务太简单，依靠规则和启发式就能解决问题了，相当于拿到了“解析解”，还用神经网络拟合个什么劲儿。这里介绍一个技巧，请熟悉业务流程的甲方人员结合Domain Knowledge，分析一下阻碍性能提升的主要瓶颈在哪里，如果对方回答是过程太复杂难以掌握规律或其他类似的答复，那就说明DRL值得一试。</p><h3 id="自由度高">自由度高</h3><p>自由度高指的是选择空间大、限制少，我们人类之所以有“选择困难症”，正是因为选择太多了，这时候DRL的优势就体现出来了，通过大量探索总能拟合出不错的value函数指导policy做选择。自由度越高，DRL优势越明显，自由度越低，越有利于规则。因此在决定用DRL之前，一定要认真评估任务场景是否有足够的优化空间，千万不要拎着锤子找钉子，否则即使训出了policy，性能也不如传统算法，白忙活一场。</p><h2 id="总结">总结</h2><p>关于需求分析就先写到这里，基本涵盖了需求评估的主要方面，如果经仔细了解后发现不满足以上五个特征，就要小心了。这时候要么直接向对方提出不可行，要么在大需求里找出符合以上要求的子任务用强化学习解决，一样可以改善总体性能，切不可盲目追求大而全。好了，万里长征走完了第一步也是最重要的一步，接下来我们就假设已经拿到了一个适合又值得用DRL解决的任务，讨论如何选择合适的算法。</p>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL </tag>
            
            <tag> 方法论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Mac】超详细的个性化终端颜色及vim颜色配置</title>
      <link href="post/835dea57.html"/>
      <url>post/835dea57.html</url>
      
        <content type="html"><![CDATA[<p>Mac终端默认风格为Basic，白底黑字（黑暗模式下黑底白字）。导致输入很多命令后，想要寻找之前的命令提示行瞅瞎眼。</p><p>这里记录了终端个性化配色的设置过程，打造你的个性终端。</p><a id="more"></a><h2 id="更新"><strong>更新</strong></h2><p><strong>macOS Catalina</strong>终端默认为zsh，<strong>以下第三节</strong> 开始的配置会遇到无法应用的问题，解决方案有两种：</p><ul><li>切换为bash：系统偏好设置 -&gt; 用户与群组 -&gt; 点击左下角小黄锁图标，以解锁允许设置 -&gt; 在左侧列表单击你的用户名，出现"高级选项" -&gt; 打开高级选项，在login shell一栏选择/bin/Bash -&gt; 应用修改。</li><li>使用zsh应用下列配置（由于zsh与bash差异较大，该方法配置过程可能遇到其它问题）：在终端依次执行下列指令</li></ul><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="bu">cd</span> ~</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">touch</span> .zshrc</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ex">open</span> .zshrc</span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="co"># 在打开的.zshrc中添加source .bash_profile</span></span></code></pre></div><h2 id="默认设置的缺陷">默认设置的缺陷</h2><p>Mac终端默认风格为Basic，白底黑字（黑暗模式下黑底白字）。导致输入很多命令后，想要寻找之前的命令提示行瞅瞎眼。</p><p>这里记录了终端个性化配色的设置过程，从 <strong>偏好设置</strong> 开始，到<strong>自定义命令提示行颜色</strong>，<strong>自定义不同文件按类别显示颜色</strong>和<strong>自定义vim编辑器配色</strong>。 ## 终端偏好设置 打开终端，快捷键command + , 打开，或者菜单 “终端” – &gt;“偏好设置” -&gt; “描述文件”，打开如下设置窗口： <img src="https://img-blog.csdnimg.cn/20200313104129580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p><p>选择了Pro主题，并修改了一些默认配置： 1. 字体为SF Mono，大小调整为14号。 2. 文本不使用粗体，而使用粗体高亮。 3. ANSI颜色，单击任一颜色可以打开调色板，修改了蓝色（明亮）的RGB等（不然之后文件夹显示颜色为默认蓝色，在黑色背景下难以看清）。 <img src="https://img-blog.csdnimg.cn/20200313105124914.png#pic_center" alt="在这里插入图片描述" /></p><ol start="4" type="1"><li>光标勾选了闪动，方便看清光标位置。</li></ol><h2 id="命令提示行设置">命令提示行设置</h2><h3 id="实现个性化配置">实现个性化配置</h3><p>先展示效果，清爽的命令提示行&gt;_&lt;，当前文件夹用红色突出显示： <img src="https://img-blog.csdnimg.cn/20200313105458643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p><p><a href="https://download.csdn.net/download/BreakingDawn0/12246627">打包资源传送门</a>，但建议一步步自己配置。</p><p>配置过程如下：</p><ol type="1"><li><p>按顺序输入上图命令，返回用户目录，显示所有文件（包括隐藏文件）。</p><div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="bu">cd</span> ~</span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">ls</span> -ah</span></code></pre></div></li><li><p>可以看到，博主已经有了一个 <strong>.bash_profile</strong>文件，它的作用是设置一些环境变量，当用户登录时，该文件仅仅执行一次！<strong>如果系统默认有该文件，那我们之后的操作都追加在原有内容之后，如果没有，就要自己创建了</strong>。</p></li><li><p>输入如下指令，进入vim编辑器后按“i”进入插入模式。（还没习惯在vim编辑的话，可以接着按ESC :wq！保存退出，然后输入指令open .bash_profile在Mac自带的文本编辑里操作）。</p><div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">vim</span> .bash_profile</span><span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span><span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="co"># 退出vim后</span></span><span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ex">open</span> .bash_profile</span></code></pre></div></li><li><p>把下面ANSI转码控制的颜色配置粘贴到.bash_profile文件中，先实现效果，具体原理下一节说明。</p><div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="bu">export</span> <span class="va">PS1=</span><span class="st">&#39;\[\033[01;32;01m\]\h:\[\033[01;31;01m\]\W \[\033[01;32;01m\]\u$\[\033[01;00;00m\] &#39;</span>  # 终端命令提示行格式及颜色</span></code></pre></div></li><li><p>退出（command + q）重启Terminal就可以看到和博主一样的命令提示行配色了，（<strong>这里配置了背景透明，万一终端背景色发生了变化，也不会在命令提示行出现一个尴尬的底色</strong>）。</p></li></ol><h3 id="配置的原理">配置的原理</h3><ul><li>Mac中的一个重要的配置文件：<ul><li><code>/etc/profile</code>：每个用户登录时都会运行的环境变量设置。</li><li><code>~/.bash_profile</code>：专用于某个用户自己使用的shell信息，当用户登录时，该文件仅仅执行一次，默认情况下，它设置一些环境变量。</li></ul></li><li>要修改命令行提示符，我们通过环境变量PS1来达到目的（正如我们在3.1中所做的那样，PS1=……）。<ul><li>命令列表的参数，这些参数可以在我们上面配置的环境变量中找到。</li></ul></li></ul><table><thead><tr class="header"><th>参数</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>\u</td><td>显示当前用户的用户名（user name）</td></tr><tr class="even"><td>\h</td><td>显示主机名（host name）</td></tr><tr class="odd"><td>\W</td><td>显示当前工作目录的名字（work directory）</td></tr><tr class="even"><td>$</td><td>显示$符作为提示符，如果用户是root的话，则显示#号</td></tr></tbody></table><ul><li>我们来查看一下当前的PS1，就能理解上面的参数了，输入如下指令<code>$echo echo $PS1</code>，<strong>注意，这里要在我们还没有按照3.1修改.bash_profile时的情况下操作（注释掉个性化修改），不然输出的结果就是我们修改的内容</strong>：</li></ul><div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ex">localhost</span>:~ lemon$ <span class="va">$echo</span> echo <span class="va">$PS1</span></span><span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span><span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="co"># Mac默认配置输出的结果是：</span></span><span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co"># \h:\W \u\$</span></span><span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="co"># 带代表Mac默认的终端命令提示行格式是：</span></span><span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="co"># 主机名:目录 用户名$ </span></span></code></pre></div><ul><li>从默认的PS1输出看到，是没有文本颜色配置的。而文本终端的颜色可以使用“ANSI非常规字符序列”来生成，（正如3.1中 <code>\[\033[01;32;40m\]\h</code>等）。<ul><li><code>[</code> 和 <code>]</code> 序列被用来封装这些非打印字符。</li><li>一个 ANSI 转义编码以一个八进制<code>033</code>（这个编码是由 退出按键产生的）开头。</li><li>其后跟着一个可选的字符属性<code>（00</code>：正常、<code>01</code>：黑体、<code>04</code>：下划线、<code>05</code>：闪烁、<code>07</code>：反转前景背景色）</li><li>最后是一个指令。前景色；背景色。</li></ul><div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="st">&#39;\[\033[01;32;01m\]\h&#39;</span></span><span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>意思就是： </span><span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="st">&#39;\[这是一个ANSI编码[正常；前景色绿色；背景色透明 结束ANSI序列\]用户名&#39;</span></span></code></pre></div></li></ul><table><thead><tr class="header"><th>字符序列</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>[、]</td><td>封装这些非打印字符</td></tr><tr class="even"><td>\033</td><td>引导非常规字符序列</td></tr><tr class="odd"><td>字符属性：00,01,04,05,07</td><td>正常，黑提，下划线，闪烁，反转前景背景色</td></tr><tr class="even"><td>m</td><td>设置属性，然后结束非常规字符序列</td></tr></tbody></table><p>这里，给出大家一些颜色序列，<strong>可以修改3.1中的配色方案</strong>，设置自己喜欢的颜色。替换字符属性、前景色、背景色对应位置的字符即可。</p><table><thead><tr class="header"><th>前景色</th><th>字符属性为<strong>00</strong></th><th>字符属性为<strong>01</strong></th></tr></thead><tbody><tr class="odd"><td>30</td><td>黑色</td><td>深灰</td></tr><tr class="even"><td>31</td><td>红色</td><td>浅红</td></tr><tr class="odd"><td>32</td><td>绿色</td><td>浅绿</td></tr><tr class="even"><td>33</td><td>棕色</td><td>黄色</td></tr><tr class="odd"><td>34</td><td>蓝色</td><td>浅蓝</td></tr><tr class="even"><td>35</td><td>粉色</td><td>浅粉</td></tr><tr class="odd"><td>36</td><td>青色</td><td>浅青</td></tr><tr class="even"><td>37</td><td>浅灰</td><td>白色</td></tr></tbody></table><table><thead><tr class="header"><th>背景色</th><th>字符属性为<strong>00</strong></th><th>背景色</th><th>字符属性为<strong>01</strong></th></tr></thead><tbody><tr class="odd"><td>40</td><td>黑色</td><td>44</td><td>蓝色</td></tr><tr class="even"><td>41</td><td>红色</td><td>45</td><td>粉色</td></tr><tr class="odd"><td>42</td><td>绿色</td><td>46</td><td>青色</td></tr><tr class="even"><td>43</td><td>棕色</td><td>47</td><td>浅灰</td></tr></tbody></table><h2 id="不同文件类型显示颜色配置">不同文件类型显示颜色配置</h2><p><a href="https://download.csdn.net/download/BreakingDawn0/12246627">打包资源传送门</a>，但建议一步步自己配置。</p><p>同样是在打开的.bash_profile文件中，粘贴下面的配置：</p><div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="bu">export</span> <span class="va">CLICOLOR=</span><span class="st">&#39;Yes&#39;</span>   # 是否输出颜色</span><span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="co"># export LS_OPTIONS=&#39;--color=auto&#39;  # 不同文件类型颜色配置，自动选择颜色</span></span><span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="bu">export</span> <span class="va">LSCOLORS=</span><span class="st">&#39;ExGxFxdaCxDaDahbadacec&#39;</span>    # 指定颜色，<span class="va">Linux</span>配色方案</span></code></pre></div><figure><img src="https://img-blog.csdnimg.cn/20200313132950333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>这里完全沿用了Linux的配色方案。</p><table><thead><tr class="header"><th>颜色</th><th>文件类型</th></tr></thead><tbody><tr class="odd"><td>蓝色</td><td>文件夹</td></tr><tr class="even"><td>绿色</td><td>可执行文件</td></tr><tr class="odd"><td>白色</td><td>普通文件</td></tr><tr class="even"><td>青色</td><td>链接文件</td></tr><tr class="odd"><td>...</td><td>...</td></tr></tbody></table><p>想要修改配色方案的话需要修改上述文件中的 <strong>LSCOLORS</strong> 变量。该变量由22个字符组成，每2个一组，分别代表一种文件类型的前景色和背景色。 这11种文件类型按顺序分别为：</p><div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="st">&#39;</span></span><span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="st">Directory</span></span><span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="st">Symbolic Link</span></span><span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="st">Socket</span></span><span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="st">Pipe</span></span><span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="st">Executable</span></span><span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="st">Block Special</span></span><span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="st">Character Special</span></span><span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="st">Executable with Setuid Bit Set</span></span><span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="st">Executable with Setgid Bit Set</span></span><span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a><span class="st">Directory Writable to Others, with Sticky Bit</span></span><span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a><span class="st">Directory Writable to Others, without Sticky Bit</span></span><span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span class="st">&#39;</span></span></code></pre></div><p>颜色字符为：</p><table><thead><tr class="header"><th>字符</th><th>颜色</th><th>字符</th><th>颜色</th></tr></thead><tbody><tr class="odd"><td>a</td><td>黑色</td><td>A</td><td>粗体黑色</td></tr><tr class="even"><td>b</td><td>红色</td><td>B</td><td>粗体红色</td></tr><tr class="odd"><td>c</td><td>绿色</td><td>C</td><td>粗体绿色</td></tr><tr class="even"><td>d</td><td>棕色</td><td>D</td><td>粗体棕色</td></tr><tr class="odd"><td>e</td><td>蓝色</td><td>E</td><td>粗体蓝色</td></tr><tr class="even"><td>f</td><td>洋红</td><td>F</td><td>粗体洋红</td></tr><tr class="odd"><td>g</td><td>青色</td><td>G</td><td>粗体青色</td></tr><tr class="even"><td>h</td><td>浅灰</td><td>H</td><td>粗体浅灰</td></tr><tr class="odd"><td>x</td><td>默认颜色</td><td></td><td></td></tr></tbody></table><h2 id="vim配色">vim配色</h2><p><a href="https://download.csdn.net/download/BreakingDawn0/12246627">打包资源传送门</a>，但建议一步步自己配置。</p><p>Mac默认的vim配色也是黑底白字，没有任何高亮，需要我们自行配置，这里配置vim人气超高的molokai配色方案。先上效果： <img src="https://img-blog.csdnimg.cn/2020031314585185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p><ol type="1"><li><p>进入主目录下的.vim文件夹</p><div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="bu">cd</span> ~/.vim</span></code></pre></div></li><li><p>如果没有.vim文件夹，则在主目录下创建.vim</p><div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="bu">cd</span> ~</span><span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">mkdir</span> .vim</span><span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="bu">cd</span> .vim</span></code></pre></div></li><li><p>下载molokai配色方案（<strong>没有git命令的话，手动去下面链接下载，把colors文件夹放到.vim文件夹下</strong>）</p><div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="fu">git</span> clone https://github.com/tomasr/molokai.git</span><span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="fu">cp</span> -r molokai/colors ./</span></code></pre></div></li><li><p><strong>检查一下，colors文件夹（里面有molokai）是否在.vim文件夹下，一般都是这个问题。</strong></p></li><li><p>回到主目录，创建.vimrc文件。</p><div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="bu">cd</span> ~</span><span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ex">vim</span> .vimrc</span></code></pre></div></li><li><p>将下面内容粘贴到.vimrc中，第三行colorscheme molokai即选择配色方案。保存并退出（ESC :wq!）</p></li></ol><div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">nocompatible</span> <span class="st">&quot; 关闭 vi 兼容模式</span></span><span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="st">syntax on &quot;</span> 自动语法高亮</span><span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a></span><span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="ex">colorscheme</span> molokai <span class="st">&quot; 设定配色方案</span></span><span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="st">set number &quot;</span> 显示行号</span><span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">cursorline</span> <span class="st">&quot; 突出显示当前行</span></span><span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="st">set ruler &quot;</span> 打开状态栏标尺</span><span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="kw">set</span> <span class="va">shiftwidth=</span>4 <span class="st">&quot; 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</span></span><span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="st">set softtabstop=4 &quot;</span> 使得按退格键时可以一次删掉 <span class="ex">4</span> 个空格</span><span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="kw">set</span> <span class="va">tabstop=</span>4 <span class="st">&quot; 设定 tab 长度为 4</span></span><span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="st">set nobackup &quot;</span> 覆盖文件时不备份</span><span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">autochdir</span> <span class="st">&quot; 自动切换当前目录为当前文件所在的目录</span></span><span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a><span class="st">filetype plugin indent on &quot;</span> 开启插件</span><span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a><span class="kw">set</span> <span class="va">backupcopy=</span>yes <span class="st">&quot; 设置备份时的行为为覆盖</span></span><span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span class="st">set ignorecase smartcase &quot;</span> 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感</span><span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">nowrapscan</span> <span class="st">&quot; 禁止在搜索到文件两端时重新搜索</span></span><span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="st">set incsearch &quot;</span> 输入搜索内容时就显示搜索结果</span><span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">hlsearch</span> <span class="st">&quot; 搜索时高亮显示被找到的文本</span></span><span id="cb13-19"><a href="#cb13-19" aria-hidden="true"></a><span class="st">set noerrorbells &quot;</span> 关闭错误信息响铃</span><span id="cb13-20"><a href="#cb13-20" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">novisualbell</span> <span class="st">&quot; 关闭使用可视响铃代替呼叫</span></span><span id="cb13-21"><a href="#cb13-21" aria-hidden="true"></a><span class="st">set t_vb= &quot;</span> 置空错误铃声的终端代码</span><span id="cb13-22"><a href="#cb13-22" aria-hidden="true"></a><span class="st">&quot; set showmatch &quot;</span> 插入括号时，短暂地跳转到匹配的对应括号</span><span id="cb13-23"><a href="#cb13-23" aria-hidden="true"></a><span class="st">&quot; set matchtime=2 &quot;</span> 短暂跳转到匹配括号的时间</span><span id="cb13-24"><a href="#cb13-24" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">magic</span> <span class="st">&quot; 设置魔术</span></span><span id="cb13-25"><a href="#cb13-25" aria-hidden="true"></a><span class="st">set hidden &quot;</span> 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存</span><span id="cb13-26"><a href="#cb13-26" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">guioptions-</span>=T <span class="st">&quot; 隐藏工具栏</span></span><span id="cb13-27"><a href="#cb13-27" aria-hidden="true"></a><span class="st">set guioptions-=m &quot;</span> 隐藏菜单栏</span><span id="cb13-28"><a href="#cb13-28" aria-hidden="true"></a><span class="kw">set</span> <span class="ex">smartindent</span> <span class="st">&quot; 开启新行时使用智能自动缩进</span></span><span id="cb13-29"><a href="#cb13-29" aria-hidden="true"></a><span class="st">set backspace=indent,eol,start</span></span><span id="cb13-30"><a href="#cb13-30" aria-hidden="true"></a><span class="st">&quot;</span> 不设定在插入状态无法用退格键和 Delete 键删除回车符</span><span id="cb13-31"><a href="#cb13-31" aria-hidden="true"></a><span class="kw">set</span> <span class="va">cmdheight=</span>1 <span class="st">&quot; 设定命令行的行数为 1</span></span><span id="cb13-32"><a href="#cb13-32" aria-hidden="true"></a><span class="st">set laststatus=2 &quot;</span> 显示状态栏 <span class="kw">(</span>默认值为 <span class="ex">1</span>, 无法显示状态栏<span class="kw">)</span></span><span id="cb13-33"><a href="#cb13-33" aria-hidden="true"></a><span class="kw">set</span> <span class="va">statusline=</span><span class="dt">\ </span><span class="ex">%</span><span class="op">&lt;</span>%F[%1*%M%*%n%R%H]%=<span class="dt">\ </span>%y<span class="dt">\ </span>%0(%<span class="dt">&#123;&amp;fileformat&#125;\ </span>%<span class="dt">&#123;&amp;encoding&#125;\ </span>%c:%l/%L%)<span class="ex">\ </span></span><span id="cb13-34"><a href="#cb13-34" aria-hidden="true"></a><span class="st">&quot; 设置在状态行显示的信息</span></span><span id="cb13-35"><a href="#cb13-35" aria-hidden="true"></a><span class="st">set foldenable &quot;</span> 开始折叠</span><span id="cb13-36"><a href="#cb13-36" aria-hidden="true"></a><span class="kw">set</span> <span class="va">foldmethod=</span>syntax <span class="st">&quot; 设置语法折叠</span></span><span id="cb13-37"><a href="#cb13-37" aria-hidden="true"></a><span class="st">set foldcolumn=0 &quot;</span> 设置折叠区域的宽度</span><span id="cb13-38"><a href="#cb13-38" aria-hidden="true"></a><span class="ex">setlocal</span> foldlevel=1 <span class="st">&quot; 设置折叠层数为</span></span><span id="cb13-39"><a href="#cb13-39" aria-hidden="true"></a><span class="st">&quot;</span> set foldclose=all <span class="st">&quot; 设置为自动关闭折叠 </span></span><span id="cb13-40"><a href="#cb13-40" aria-hidden="true"></a><span class="st">&quot;</span> nnoremap <span class="op">&lt;</span>space<span class="op">&gt;</span> @=((foldclosed(line(<span class="st">&#39;.&#39;</span>)) <span class="op">&lt;</span> <span class="ex">0</span>) <span class="ex">?</span> <span class="st">&#39;zc&#39;</span> : <span class="st">&#39;zo&#39;</span>)<span class="op">&lt;</span><span class="ex">CR</span><span class="op">&gt;</span></span><span id="cb13-41"><a href="#cb13-41" aria-hidden="true"></a><span class="st">&quot; 用空格键来开关折叠</span></span><span id="cb13-42"><a href="#cb13-42" aria-hidden="true"></a></span><span id="cb13-43"><a href="#cb13-43" aria-hidden="true"></a></span><span id="cb13-44"><a href="#cb13-44" aria-hidden="true"></a><span class="st">&quot;</span> <span class="bu">return</span> OS type, eg: windows, or linux, mac, et.st..</span><span id="cb13-45"><a href="#cb13-45" aria-hidden="true"></a><span class="kw">function</span>! <span class="fu">MySys()</span></span><span id="cb13-46"><a href="#cb13-46" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">has</span>(<span class="st">&quot;win16&quot;</span>) <span class="kw">||</span> <span class="ex">has</span>(<span class="st">&quot;win32&quot;</span>) <span class="kw">||</span> <span class="ex">has</span>(<span class="st">&quot;win64&quot;</span>) <span class="kw">||</span> <span class="ex">has</span>(<span class="st">&quot;win95&quot;</span>)</span><span id="cb13-47"><a href="#cb13-47" aria-hidden="true"></a><span class="bu">return</span> <span class="st">&quot;windows&quot;</span></span><span id="cb13-48"><a href="#cb13-48" aria-hidden="true"></a><span class="ex">elseif</span> has(<span class="st">&quot;unix&quot;</span>)</span><span id="cb13-49"><a href="#cb13-49" aria-hidden="true"></a><span class="bu">return</span> <span class="st">&quot;linux&quot;</span></span><span id="cb13-50"><a href="#cb13-50" aria-hidden="true"></a><span class="ex">endif</span></span><span id="cb13-51"><a href="#cb13-51" aria-hidden="true"></a><span class="ex">endfunction</span></span><span id="cb13-52"><a href="#cb13-52" aria-hidden="true"></a></span><span id="cb13-53"><a href="#cb13-53" aria-hidden="true"></a><span class="st">&quot; 用户目录变量</span><span class="va">$VIMFILES</span></span><span id="cb13-54"><a href="#cb13-54" aria-hidden="true"></a><span class="st">if MySys() ** &quot;</span><span class="ex">windows</span><span class="st">&quot;</span></span><span id="cb13-55"><a href="#cb13-55" aria-hidden="true"></a><span class="st">let </span><span class="va">$VIMFILES</span><span class="st"> = </span><span class="va">$VIM</span><span class="st">.&#39;/vimfiles&#39;</span></span><span id="cb13-56"><a href="#cb13-56" aria-hidden="true"></a><span class="st">elseif MySys() ** &quot;</span>linux<span class="st">&quot;</span></span><span id="cb13-57"><a href="#cb13-57" aria-hidden="true"></a><span class="st">let </span><span class="va">$VIMFILES</span><span class="st"> = </span><span class="va">$HOME</span><span class="st">.&#39;/.vim&#39;</span></span><span id="cb13-58"><a href="#cb13-58" aria-hidden="true"></a><span class="st">endif</span></span><span id="cb13-59"><a href="#cb13-59" aria-hidden="true"></a></span><span id="cb13-60"><a href="#cb13-60" aria-hidden="true"></a><span class="st">&quot;</span> 设定doc文档目录</span><span id="cb13-61"><a href="#cb13-61" aria-hidden="true"></a><span class="bu">let</span> helptags=<span class="va">$VIMFILES</span>.<span class="st">&#39;/doc&#39;</span></span><span id="cb13-62"><a href="#cb13-62" aria-hidden="true"></a></span><span id="cb13-63"><a href="#cb13-63" aria-hidden="true"></a><span class="st">&quot; 设置字体 以及中文支持</span></span><span id="cb13-64"><a href="#cb13-64" aria-hidden="true"></a><span class="st">if has(&quot;</span><span class="ex">win32</span><span class="st">&quot;)</span></span><span id="cb13-65"><a href="#cb13-65" aria-hidden="true"></a><span class="st">set guifont=Inconsolata:h12:cANSI</span></span><span id="cb13-66"><a href="#cb13-66" aria-hidden="true"></a><span class="st">endif</span></span><span id="cb13-67"><a href="#cb13-67" aria-hidden="true"></a></span><span id="cb13-68"><a href="#cb13-68" aria-hidden="true"></a><span class="st">&quot;</span> 配置多语言环境</span><span id="cb13-69"><a href="#cb13-69" aria-hidden="true"></a><span class="kw">if</span> <span class="ex">has</span>(<span class="st">&quot;multi_byte&quot;</span>)</span><span id="cb13-70"><a href="#cb13-70" aria-hidden="true"></a><span class="st">&quot; UTF-8 编码</span></span><span id="cb13-71"><a href="#cb13-71" aria-hidden="true"></a><span class="st">set encoding=utf-8</span></span><span id="cb13-72"><a href="#cb13-72" aria-hidden="true"></a><span class="st">set termencoding=utf-8</span></span><span id="cb13-73"><a href="#cb13-73" aria-hidden="true"></a><span class="st">set formatoptions+=mM</span></span><span id="cb13-74"><a href="#cb13-74" aria-hidden="true"></a><span class="st">set fencs=utf-8,gbk</span></span><span id="cb13-75"><a href="#cb13-75" aria-hidden="true"></a></span><span id="cb13-76"><a href="#cb13-76" aria-hidden="true"></a><span class="st">if v:lang =~? &#39;^\(zh\)\|\(ja\)\|\(ko\)&#39;</span></span><span id="cb13-77"><a href="#cb13-77" aria-hidden="true"></a><span class="st">set ambiwidth=double</span></span><span id="cb13-78"><a href="#cb13-78" aria-hidden="true"></a><span class="st">endif</span></span><span id="cb13-79"><a href="#cb13-79" aria-hidden="true"></a></span><span id="cb13-80"><a href="#cb13-80" aria-hidden="true"></a><span class="st">if has(&quot;</span><span class="ex">win32</span><span class="st">&quot;)</span></span><span id="cb13-81"><a href="#cb13-81" aria-hidden="true"></a><span class="st">source </span><span class="va">$VIMRUNTIME</span><span class="st">/delmenu.vim</span></span><span id="cb13-82"><a href="#cb13-82" aria-hidden="true"></a><span class="st">source </span><span class="va">$VIMRUNTIME</span><span class="st">/menu.vim</span></span><span id="cb13-83"><a href="#cb13-83" aria-hidden="true"></a><span class="st">language messages zh_CN.utf-8</span></span><span id="cb13-84"><a href="#cb13-84" aria-hidden="true"></a><span class="st">endif</span></span><span id="cb13-85"><a href="#cb13-85" aria-hidden="true"></a><span class="st">else</span></span><span id="cb13-86"><a href="#cb13-86" aria-hidden="true"></a><span class="st">echoerr &quot;</span>Sorry, this version of (g)<span class="ex">vim</span> was not compiled with +multi_byte<span class="st">&quot;</span></span><span id="cb13-87"><a href="#cb13-87" aria-hidden="true"></a><span class="st">endif</span></span><span id="cb13-88"><a href="#cb13-88" aria-hidden="true"></a></span><span id="cb13-89"><a href="#cb13-89" aria-hidden="true"></a><span class="st">&quot;</span> Buffers操作快捷方式!</span><span id="cb13-90"><a href="#cb13-90" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-RETURN<span class="op">&gt;</span> :bnext<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-91"><a href="#cb13-91" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-S-RETURN<span class="op">&gt;</span> :bprevious<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-92"><a href="#cb13-92" aria-hidden="true"></a></span><span id="cb13-93"><a href="#cb13-93" aria-hidden="true"></a><span class="st">&quot; Tab操作快捷方式!</span></span><span id="cb13-94"><a href="#cb13-94" aria-hidden="true"></a><span class="st">nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;</span></span><span id="cb13-95"><a href="#cb13-95" aria-hidden="true"></a><span class="st">nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;</span></span><span id="cb13-96"><a href="#cb13-96" aria-hidden="true"></a></span><span id="cb13-97"><a href="#cb13-97" aria-hidden="true"></a><span class="st">&quot;</span>关于<span class="ex">tab</span>的快捷键</span><span id="cb13-98"><a href="#cb13-98" aria-hidden="true"></a><span class="st">&quot; map tn :tabnext&lt;cr&gt;</span></span><span id="cb13-99"><a href="#cb13-99" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">map</span> tp :tabprevious<span class="op">&lt;</span>cr<span class="op">&gt;</span></span><span id="cb13-100"><a href="#cb13-100" aria-hidden="true"></a><span class="st">&quot; map td :tabnew .&lt;cr&gt;</span></span><span id="cb13-101"><a href="#cb13-101" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">map</span> te :tabedit</span><span id="cb13-102"><a href="#cb13-102" aria-hidden="true"></a><span class="st">&quot; map tc :tabclose&lt;cr&gt;</span></span><span id="cb13-103"><a href="#cb13-103" aria-hidden="true"></a></span><span id="cb13-104"><a href="#cb13-104" aria-hidden="true"></a><span class="st">&quot;</span>窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动</span><span id="cb13-105"><a href="#cb13-105" aria-hidden="true"></a><span class="st">&quot;光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的</span></span><span id="cb13-106"><a href="#cb13-106" aria-hidden="true"></a><span class="st">&quot;</span>时候会变得非常方便<span class="ex">.</span></span><span id="cb13-107"><a href="#cb13-107" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-h<span class="op">&gt;</span> <span class="op">&lt;</span>C-w<span class="op">&gt;</span>h</span><span id="cb13-108"><a href="#cb13-108" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-j<span class="op">&gt;</span> <span class="op">&lt;</span>C-w<span class="op">&gt;</span>j</span><span id="cb13-109"><a href="#cb13-109" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-k<span class="op">&gt;</span> <span class="op">&lt;</span>C-w<span class="op">&gt;</span>k</span><span id="cb13-110"><a href="#cb13-110" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>C-l<span class="op">&gt;</span> <span class="op">&lt;</span>C-w<span class="op">&gt;</span>l</span><span id="cb13-111"><a href="#cb13-111" aria-hidden="true"></a></span><span id="cb13-112"><a href="#cb13-112" aria-hidden="true"></a><span class="st">&quot;一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）</span></span><span id="cb13-113"><a href="#cb13-113" aria-hidden="true"></a><span class="st">nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;</span></span><span id="cb13-114"><a href="#cb13-114" aria-hidden="true"></a><span class="st">nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;</span></span><span id="cb13-115"><a href="#cb13-115" aria-hidden="true"></a><span class="st">nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;</span></span><span id="cb13-116"><a href="#cb13-116" aria-hidden="true"></a><span class="st">nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;</span></span><span id="cb13-117"><a href="#cb13-117" aria-hidden="true"></a></span><span id="cb13-118"><a href="#cb13-118" aria-hidden="true"></a><span class="st">&quot;</span> <span class="kw">set</span> <span class="va">fileformats=</span>unix,dos,mac</span><span id="cb13-119"><a href="#cb13-119" aria-hidden="true"></a><span class="st">&quot; nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;</span></span><span id="cb13-120"><a href="#cb13-120" aria-hidden="true"></a><span class="st">&quot;</span> <span class="fu">nmap</span> <span class="op">&lt;</span>leader<span class="op">&gt;</span>fu :se fileformat=unix<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-121"><a href="#cb13-121" aria-hidden="true"></a></span><span id="cb13-122"><a href="#cb13-122" aria-hidden="true"></a><span class="st">&quot; use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result</span></span><span id="cb13-123"><a href="#cb13-123" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">map</span> <span class="op">&lt;</span>C-x<span class="op">&gt;</span>l <span class="op">&lt;</span>ESC<span class="op">&gt;</span>:cl<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-124"><a href="#cb13-124" aria-hidden="true"></a><span class="st">&quot; map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;</span></span><span id="cb13-125"><a href="#cb13-125" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">map</span> <span class="op">&lt;</span>C-x<span class="op">&gt;</span>p <span class="op">&lt;</span>ESC<span class="op">&gt;</span>:cp<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-126"><a href="#cb13-126" aria-hidden="true"></a><span class="st">&quot; map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;</span></span><span id="cb13-127"><a href="#cb13-127" aria-hidden="true"></a></span><span id="cb13-128"><a href="#cb13-128" aria-hidden="true"></a></span><span id="cb13-129"><a href="#cb13-129" aria-hidden="true"></a><span class="st">&quot;</span> 让 <span class="ex">Tohtml</span> 产生有 CSS 语法的 html</span><span id="cb13-130"><a href="#cb13-130" aria-hidden="true"></a><span class="st">&quot; syntax/2html.vim，可以用:runtime! syntax/2html.vim</span></span><span id="cb13-131"><a href="#cb13-131" aria-hidden="true"></a><span class="st">let html_use_css=1</span></span><span id="cb13-132"><a href="#cb13-132" aria-hidden="true"></a></span><span id="cb13-133"><a href="#cb13-133" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">Python</span> 文件的一般设置，比如不要 tab 等</span><span id="cb13-134"><a href="#cb13-134" aria-hidden="true"></a><span class="ex">autocmd</span> FileType python set tabstop=4 shiftwidth=4 expandtab</span><span id="cb13-135"><a href="#cb13-135" aria-hidden="true"></a><span class="ex">autocmd</span> FileType python map <span class="op">&lt;</span>F12<span class="op">&gt;</span> :!python %<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-136"><a href="#cb13-136" aria-hidden="true"></a></span><span id="cb13-137"><a href="#cb13-137" aria-hidden="true"></a><span class="st">&quot; 选中状态下 Ctrl+c 复制</span></span><span id="cb13-138"><a href="#cb13-138" aria-hidden="true"></a><span class="st">vmap &lt;C-c&gt; &quot;</span><span class="ex">+y</span></span><span id="cb13-139"><a href="#cb13-139" aria-hidden="true"></a></span><span id="cb13-140"><a href="#cb13-140" aria-hidden="true"></a><span class="st">&quot; 打开javascript折叠</span></span><span id="cb13-141"><a href="#cb13-141" aria-hidden="true"></a><span class="st">let b:javascript_fold=1</span></span><span id="cb13-142"><a href="#cb13-142" aria-hidden="true"></a><span class="st">&quot;</span> 打开<span class="ex">javascript</span>对dom、html和css的支持</span><span id="cb13-143"><a href="#cb13-143" aria-hidden="true"></a><span class="bu">let</span> javascript_enable_domhtmlcss=1</span><span id="cb13-144"><a href="#cb13-144" aria-hidden="true"></a><span class="st">&quot; 设置字典 ~/.vim/dict/文件的路径</span></span><span id="cb13-145"><a href="#cb13-145" aria-hidden="true"></a><span class="st">autocmd filetype javascript set dictionary=</span><span class="va">$VIMFILES</span><span class="st">/dict/javascript.dict</span></span><span id="cb13-146"><a href="#cb13-146" aria-hidden="true"></a><span class="st">autocmd filetype css set dictionary=</span><span class="va">$VIMFILES</span><span class="st">/dict/css.dict</span></span><span id="cb13-147"><a href="#cb13-147" aria-hidden="true"></a><span class="st">autocmd filetype php set dictionary=</span><span class="va">$VIMFILES</span><span class="st">/dict/php.dict</span></span><span id="cb13-148"><a href="#cb13-148" aria-hidden="true"></a></span><span id="cb13-149"><a href="#cb13-149" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-150"><a href="#cb13-150" aria-hidden="true"></a><span class="st">&quot; plugin - bufexplorer.vim Buffers切换</span></span><span id="cb13-151"><a href="#cb13-151" aria-hidden="true"></a><span class="st">&quot;</span> \<span class="ex">be</span> 全屏方式查看全部打开的文件列表</span><span id="cb13-152"><a href="#cb13-152" aria-hidden="true"></a><span class="st">&quot; \bv 左右方式查看 \bs 上下方式查看</span></span><span id="cb13-153"><a href="#cb13-153" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-154"><a href="#cb13-154" aria-hidden="true"></a></span><span id="cb13-155"><a href="#cb13-155" aria-hidden="true"></a></span><span id="cb13-156"><a href="#cb13-156" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-157"><a href="#cb13-157" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> - taglist.vim 查看函数列表，需要ctags程序</span><span id="cb13-158"><a href="#cb13-158" aria-hidden="true"></a><span class="st">&quot; F4 打开隐藏taglist窗口</span></span><span id="cb13-159"><a href="#cb13-159" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-160"><a href="#cb13-160" aria-hidden="true"></a><span class="kw">if</span> <span class="fu">MySys()</span> <span class="ex">**</span> <span class="st">&quot;windows&quot;</span> <span class="st">&quot; 设定windows系统中ctags程序的位置</span></span><span id="cb13-161"><a href="#cb13-161" aria-hidden="true"></a><span class="st">let Tlist_Ctags_Cmd = &#39;&quot;&#39;.$VIMRUNTIME.&#39;</span>/ctags.exe<span class="st">&quot;&#39;</span></span><span id="cb13-162"><a href="#cb13-162" aria-hidden="true"></a><span class="st">elseif MySys() ** &quot;</span>linux<span class="st">&quot; &quot;</span> 设定windows系统中ctags程序的位置</span><span id="cb13-163"><a href="#cb13-163" aria-hidden="true"></a><span class="bu">let</span> Tlist_Ctags_Cmd = <span class="st">&#39;/usr/bin/ctags&#39;</span></span><span id="cb13-164"><a href="#cb13-164" aria-hidden="true"></a><span class="ex">endif</span></span><span id="cb13-165"><a href="#cb13-165" aria-hidden="true"></a><span class="ex">nnoremap</span> <span class="op">&lt;</span>silent<span class="op">&gt;&lt;</span>F4<span class="op">&gt;</span> :TlistToggle<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-166"><a href="#cb13-166" aria-hidden="true"></a><span class="bu">let</span> Tlist_Show_One_File = 1 <span class="st">&quot; 不同时显示多个文件的tag，只显示当前文件的</span></span><span id="cb13-167"><a href="#cb13-167" aria-hidden="true"></a><span class="st">let Tlist_Exit_OnlyWindow = 1 &quot;</span> 如果taglist窗口是最后一个窗口，则退出vim</span><span id="cb13-168"><a href="#cb13-168" aria-hidden="true"></a><span class="bu">let</span> Tlist_Use_Right_Window = 1 <span class="st">&quot; 在右侧窗口中显示taglist窗口</span></span><span id="cb13-169"><a href="#cb13-169" aria-hidden="true"></a><span class="st">let Tlist_File_Fold_Auto_Close=1 &quot;</span> 自动折叠当前非编辑文件的方法列表</span><span id="cb13-170"><a href="#cb13-170" aria-hidden="true"></a><span class="bu">let</span> Tlist_Auto_Open = 0</span><span id="cb13-171"><a href="#cb13-171" aria-hidden="true"></a><span class="bu">let</span> Tlist_Auto_Update = 1</span><span id="cb13-172"><a href="#cb13-172" aria-hidden="true"></a><span class="bu">let</span> Tlist_Hightlight_Tag_On_BufEnter = 1</span><span id="cb13-173"><a href="#cb13-173" aria-hidden="true"></a><span class="bu">let</span> Tlist_Enable_Fold_Column = 0</span><span id="cb13-174"><a href="#cb13-174" aria-hidden="true"></a><span class="bu">let</span> Tlist_Process_File_Always = 1</span><span id="cb13-175"><a href="#cb13-175" aria-hidden="true"></a><span class="bu">let</span> Tlist_Display_Prototype = 0</span><span id="cb13-176"><a href="#cb13-176" aria-hidden="true"></a><span class="bu">let</span> Tlist_Compact_Format = 1</span><span id="cb13-177"><a href="#cb13-177" aria-hidden="true"></a></span><span id="cb13-178"><a href="#cb13-178" aria-hidden="true"></a></span><span id="cb13-179"><a href="#cb13-179" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-180"><a href="#cb13-180" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。</span><span id="cb13-181"><a href="#cb13-181" aria-hidden="true"></a><span class="st">&quot; \m mark or unmark the word under (or before) the cursor</span></span><span id="cb13-182"><a href="#cb13-182" aria-hidden="true"></a><span class="st">&quot;</span> \<span class="ex">r</span> manually input a regular expression. 用于搜索.</span><span id="cb13-183"><a href="#cb13-183" aria-hidden="true"></a><span class="st">&quot; \n clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .</span></span><span id="cb13-184"><a href="#cb13-184" aria-hidden="true"></a><span class="st">&quot;</span> <span class="dt">\*</span> 当前<span class="ex">MarkWord</span>的下一个 \# 当前MarkWord的上一个</span><span id="cb13-185"><a href="#cb13-185" aria-hidden="true"></a><span class="st">&quot; \/ 所有MarkWords的下一个 \? 所有MarkWords的上一个</span></span><span id="cb13-186"><a href="#cb13-186" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-187"><a href="#cb13-187" aria-hidden="true"></a></span><span id="cb13-188"><a href="#cb13-188" aria-hidden="true"></a></span><span id="cb13-189"><a href="#cb13-189" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-190"><a href="#cb13-190" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> - NERD_tree.vim 以树状方式浏览系统中的文件和目录</span><span id="cb13-191"><a href="#cb13-191" aria-hidden="true"></a><span class="st">&quot; :ERDtree 打开NERD_tree :NERDtreeClose 关闭NERD_tree</span></span><span id="cb13-192"><a href="#cb13-192" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">o</span> 打开关闭文件或者目录 t 在标签页中打开</span><span id="cb13-193"><a href="#cb13-193" aria-hidden="true"></a><span class="st">&quot; T 在后台标签页中打开 ! 执行此文件</span></span><span id="cb13-194"><a href="#cb13-194" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">p</span> 到上层目录 P 到根目录</span><span id="cb13-195"><a href="#cb13-195" aria-hidden="true"></a><span class="st">&quot; K 到第一个节点 J 到最后一个节点</span></span><span id="cb13-196"><a href="#cb13-196" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">u</span> 打开上层目录 m 显示文件系统菜单（添加、删除、移动操作）</span><span id="cb13-197"><a href="#cb13-197" aria-hidden="true"></a><span class="st">&quot; r 递归刷新当前目录 R 递归刷新当前根目录</span></span><span id="cb13-198"><a href="#cb13-198" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-199"><a href="#cb13-199" aria-hidden="true"></a><span class="st">&quot; F3 NERDTree 切换</span></span><span id="cb13-200"><a href="#cb13-200" aria-hidden="true"></a><span class="st">map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;</span></span><span id="cb13-201"><a href="#cb13-201" aria-hidden="true"></a><span class="st">imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;</span></span><span id="cb13-202"><a href="#cb13-202" aria-hidden="true"></a></span><span id="cb13-203"><a href="#cb13-203" aria-hidden="true"></a></span><span id="cb13-204"><a href="#cb13-204" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-205"><a href="#cb13-205" aria-hidden="true"></a><span class="st">&quot; plugin - NERD_commenter.vim 注释代码用的，</span></span><span id="cb13-206"><a href="#cb13-206" aria-hidden="true"></a><span class="st">&quot;</span> [<span class="ex">count</span>],cc 光标以下count行逐行添加注释(7,cc)</span><span id="cb13-207"><a href="#cb13-207" aria-hidden="true"></a><span class="st">&quot; [count],cu 光标以下count行逐行取消注释(7,cu)</span></span><span id="cb13-208"><a href="#cb13-208" aria-hidden="true"></a><span class="st">&quot;</span> [<span class="ex">count</span>],cm 光标以下count行尝试添加块注释(7,cm)</span><span id="cb13-209"><a href="#cb13-209" aria-hidden="true"></a><span class="st">&quot; ,cA 在行尾插入 ,并且进入插入模式。 这个命令方便写注释。</span></span><span id="cb13-210"><a href="#cb13-210" aria-hidden="true"></a><span class="st">&quot;</span> 注：<span class="ex">count</span>参数可选，无则默认为选中行或当前行</span><span id="cb13-211"><a href="#cb13-211" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-212"><a href="#cb13-212" aria-hidden="true"></a><span class="st">let NERDSpaceDelims=1 &quot;</span> 让注释符与语句之间留一个空格</span><span id="cb13-213"><a href="#cb13-213" aria-hidden="true"></a><span class="bu">let</span> NERDCompactSexyComs=1 <span class="st">&quot; 多行注释时样子更好看</span></span><span id="cb13-214"><a href="#cb13-214" aria-hidden="true"></a></span><span id="cb13-215"><a href="#cb13-215" aria-hidden="true"></a></span><span id="cb13-216"><a href="#cb13-216" aria-hidden="true"></a><span class="st">&quot;</span>-----------------------------------------------------------------</span><span id="cb13-217"><a href="#cb13-217" aria-hidden="true"></a><span class="st">&quot; plugin - DoxygenToolkit.vim 由注释生成文档，并且能够快速生成函数标准注释</span></span><span id="cb13-218"><a href="#cb13-218" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-219"><a href="#cb13-219" aria-hidden="true"></a><span class="bu">let</span> g:DoxygenToolkit_authorName=<span class="st">&quot;Asins - asinsimple AT gmail DOT com&quot;</span></span><span id="cb13-220"><a href="#cb13-220" aria-hidden="true"></a><span class="bu">let</span> g:DoxygenToolkit_briefTag_funcName=<span class="st">&quot;yes&quot;</span></span><span id="cb13-221"><a href="#cb13-221" aria-hidden="true"></a><span class="ex">map</span> <span class="op">&lt;</span>leader<span class="op">&gt;</span>da :DoxAuthor<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-222"><a href="#cb13-222" aria-hidden="true"></a><span class="ex">map</span> <span class="op">&lt;</span>leader<span class="op">&gt;</span>df :Dox<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-223"><a href="#cb13-223" aria-hidden="true"></a><span class="ex">map</span> <span class="op">&lt;</span>leader<span class="op">&gt;</span>db :DoxBlock<span class="op">&lt;</span>CR<span class="op">&gt;</span></span><span id="cb13-224"><a href="#cb13-224" aria-hidden="true"></a><span class="ex">map</span> <span class="op">&lt;</span>leader<span class="op">&gt;</span>dc a <span class="op">&lt;</span>LEFT<span class="op">&gt;&lt;</span>LEFT<span class="op">&gt;&lt;</span>LEFT<span class="op">&gt;</span></span><span id="cb13-225"><a href="#cb13-225" aria-hidden="true"></a></span><span id="cb13-226"><a href="#cb13-226" aria-hidden="true"></a></span><span id="cb13-227"><a href="#cb13-227" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-228"><a href="#cb13-228" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> – ZenCoding.vim 很酷的插件，HTML代码生成</span><span id="cb13-229"><a href="#cb13-229" aria-hidden="true"></a><span class="st">&quot; 插件最新版：http://github.com/mattn/zencoding-vim</span></span><span id="cb13-230"><a href="#cb13-230" aria-hidden="true"></a><span class="st">&quot;</span> 常用命令可看：<span class="ex">http</span>://nootn.com/blog/Tool/23/</span><span id="cb13-231"><a href="#cb13-231" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-232"><a href="#cb13-232" aria-hidden="true"></a></span><span id="cb13-233"><a href="#cb13-233" aria-hidden="true"></a></span><span id="cb13-234"><a href="#cb13-234" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-235"><a href="#cb13-235" aria-hidden="true"></a><span class="st">&quot; plugin – checksyntax.vim JavaScript常见语法错误检查</span></span><span id="cb13-236"><a href="#cb13-236" aria-hidden="true"></a><span class="st">&quot;</span> 默认快捷方式为 <span class="ex">F5</span></span><span id="cb13-237"><a href="#cb13-237" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-238"><a href="#cb13-238" aria-hidden="true"></a><span class="st">let g:checksyntax_auto = 0 &quot;</span> 不自动检查</span><span id="cb13-239"><a href="#cb13-239" aria-hidden="true"></a></span><span id="cb13-240"><a href="#cb13-240" aria-hidden="true"></a></span><span id="cb13-241"><a href="#cb13-241" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-242"><a href="#cb13-242" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> - NeoComplCache.vim 自动补全插件</span><span id="cb13-243"><a href="#cb13-243" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-244"><a href="#cb13-244" aria-hidden="true"></a><span class="st">let g:AutoComplPop_NotEnableAtStartup = 1</span></span><span id="cb13-245"><a href="#cb13-245" aria-hidden="true"></a><span class="st">let g:NeoComplCache_EnableAtStartup = 1</span></span><span id="cb13-246"><a href="#cb13-246" aria-hidden="true"></a><span class="st">let g:NeoComplCache_SmartCase = 1</span></span><span id="cb13-247"><a href="#cb13-247" aria-hidden="true"></a><span class="st">let g:NeoComplCache_TagsAutoUpdate = 1</span></span><span id="cb13-248"><a href="#cb13-248" aria-hidden="true"></a><span class="st">let g:NeoComplCache_EnableInfo = 1</span></span><span id="cb13-249"><a href="#cb13-249" aria-hidden="true"></a><span class="st">let g:NeoComplCache_EnableCamelCaseCompletion = 1</span></span><span id="cb13-250"><a href="#cb13-250" aria-hidden="true"></a><span class="st">let g:NeoComplCache_MinSyntaxLength = 3</span></span><span id="cb13-251"><a href="#cb13-251" aria-hidden="true"></a><span class="st">let g:NeoComplCache_EnableSkipCompletion = 1</span></span><span id="cb13-252"><a href="#cb13-252" aria-hidden="true"></a><span class="st">let g:NeoComplCache_SkipInputTime = &#39;0.5&#39;</span></span><span id="cb13-253"><a href="#cb13-253" aria-hidden="true"></a><span class="st">let g:NeoComplCache_SnippetsDir = </span><span class="va">$VIMFILES</span><span class="st">.&#39;/snippets&#39;</span></span><span id="cb13-254"><a href="#cb13-254" aria-hidden="true"></a><span class="st">&quot;</span> <span class="op">&lt;</span><span class="ex">TAB</span><span class="op">&gt;</span> completion.</span><span id="cb13-255"><a href="#cb13-255" aria-hidden="true"></a><span class="ex">inoremap</span> <span class="op">&lt;</span>expr<span class="op">&gt;&lt;</span>TAB<span class="op">&gt;</span> pumvisible() <span class="ex">?</span> <span class="st">&quot;\&lt;C-n&gt;&quot;</span> : <span class="st">&quot;\&lt;TAB&gt;&quot;</span></span><span id="cb13-256"><a href="#cb13-256" aria-hidden="true"></a><span class="st">&quot; snippets expand key</span></span><span id="cb13-257"><a href="#cb13-257" aria-hidden="true"></a><span class="st">imap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span></span><span id="cb13-258"><a href="#cb13-258" aria-hidden="true"></a><span class="st">smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)</span></span><span id="cb13-259"><a href="#cb13-259" aria-hidden="true"></a></span><span id="cb13-260"><a href="#cb13-260" aria-hidden="true"></a></span><span id="cb13-261"><a href="#cb13-261" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-262"><a href="#cb13-262" aria-hidden="true"></a><span class="st">&quot; plugin - matchit.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span></span><span id="cb13-263"><a href="#cb13-263" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">%</span> 正向匹配 g% 反向匹配</span><span id="cb13-264"><a href="#cb13-264" aria-hidden="true"></a><span class="st">&quot; [% 定位块首 ]% 定位块尾</span></span><span id="cb13-265"><a href="#cb13-265" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-266"><a href="#cb13-266" aria-hidden="true"></a></span><span id="cb13-267"><a href="#cb13-267" aria-hidden="true"></a></span><span id="cb13-268"><a href="#cb13-268" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-269"><a href="#cb13-269" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> - vcscommand.vim 对%命令进行扩展使得能在嵌套标签和语句之间跳转</span><span id="cb13-270"><a href="#cb13-270" aria-hidden="true"></a><span class="st">&quot; SVN/git管理工具</span></span><span id="cb13-271"><a href="#cb13-271" aria-hidden="true"></a><span class="st">&quot;</span><span class="ex">-----------------------------------------------------------------</span></span><span id="cb13-272"><a href="#cb13-272" aria-hidden="true"></a></span><span id="cb13-273"><a href="#cb13-273" aria-hidden="true"></a></span><span id="cb13-274"><a href="#cb13-274" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span><span id="cb13-275"><a href="#cb13-275" aria-hidden="true"></a><span class="st">&quot;</span> <span class="ex">plugin</span> – a.vim</span><span id="cb13-276"><a href="#cb13-276" aria-hidden="true"></a><span class="st">&quot;-----------------------------------------------------------------</span></span></code></pre></div><h2 id="参考文献">参考文献</h2><p>https://www.cnblogs.com/RyanJin/p/10066389.html</p><p>https://www.cnblogs.com/puyangsky/p/5442153.html</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【MAC】抹盘重装教程</title>
      <link href="post/62abf324.html"/>
      <url>post/62abf324.html</url>
      
        <content type="html"><![CDATA[<p>一年不抹盘就手痒痒系列&gt;_&lt; 在这里记录自己抹盘重装macOS Mojave的历程，引导器（USB启动磁盘）制作是一个大坑，目前的官方教程丢了一个小细节。</p><a id="more"></a><h2 id="制作可引导的macos安装器">制作可引导的macOS安装器</h2><h3 id="下载macos">下载macOS</h3><p>各个 macOS 版本的下载链接移步官网，这里以我安装的Mojave为例，<a href="https://support.apple.com/zh-cn/HT210190">Mojave</a>：</p><ul><li><p>macOS High Sierra 以上的系统会以 App 的形式直接下载到“应用程序”文件夹，例如“安装 macOS Mojave”或“安装 macOS High Sierra”。</p></li><li><p>其他版本可能会下载为.pkg文件，打开以后按指示操作，最终也会是xxx.app。</p></li></ul><h2 id="在终端中使用createinstallmedia命令">在“终端”中使用“createinstallmedia”命令</h2><ol type="1"><li><p>连接要用于可引导安装器的U盘或其他可用磁盘。确保至少有 12GB 可用储存空间，并已格式化为“Mac OS 扩展”。</p></li><li><p>这里大坑出现了，如果跳过这里操作完发现系统 <strong>无法将制作的引导器识别为启动磁盘</strong>，</p><ul><li>所以，在制作引导器之前，先在mac的磁盘工具里<strong>检查一下自己磁盘</strong>。</li><li>选择左上角的 显示所有设备。（Mojave之后的APFS有了容器的概念，和图中不一样可以不管）</li><li>接着选中要制作引导器的磁盘所在的的<strong>最上层名称</strong>，点击分区，<strong>需要GUID分区图</strong>，macOS扩展（日志式），然后确定。接着就可以愉快的制作引导器了。 <img src="https://img-blog.csdnimg.cn/2020030522060854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li></ul></li><li><p>打开“应用程序”文件夹内“实用工具”文件夹中的“终端”。在“终端”中键入或粘贴以下命令之一。这些命令假设安装器仍位于“应用程序”文件夹中，并且 MyVolume 是 制作引导器的磁盘（或其他）名。如果不是这个名称，替换 MyVolume 为自己的磁盘名称。</p><p>Catalina：</p><p><code>sudo /Applications/Install\ macOS\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</code></p><p>Mojave：</p><p><code>sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</code></p></li><li><p>键入相应的命令后，按下 Return 键。出现提示时，键入管理员密码，然后再次按下 Return 键。在键入密码时，“终端”不会显示任何字符。</p></li><li><p>出现提示时，键入 Y 以确认要抹掉磁盘，然后按下 Return 键。创建可引导安装器过程中，“终端”将显示进度。</p></li><li><p>当“终端”显示这个操作已完成时，该磁盘的名称将与下载的安装器名称相同，例如“安装 macOS Mojave”。现在可以退出“终端”并弹出宗卷。</p></li></ol><h2 id="使用引导器重装">使用引导器重装</h2><ol type="1"><li>将可引导安装器插入兼容的 Mac，兼容性查看<a href="https://support.apple.com/zh-cn/HT201686">官网</a>。</li><li>使用“启动管理器”或“启动磁盘”偏好设置将可引导安装器选择为启动磁盘，然后从中启动。也可以重启时按住option进入选择启动磁盘界面，选择制作的引导器启动。</li><li>如果要抹盘重装，则先选择列表里的磁盘工具，否则直接选择重装macOS进入自动安装。</li><li>选择磁盘工具后，界面和正常mac磁盘工具相同，<strong>选择原来的系统磁盘，抹除，手残点到存放数据的磁盘喜闻乐见（本人老老老版mac，光驱拆了再装一块固态还挺舒服）</strong> <img src="https://img-blog.csdnimg.cn/2020030521355455.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></li><li>抹除系统盘后，退出磁盘工具，返回刚才的界面，选择重装macOS。</li><li>接着进入自动安装，都是傻瓜式安装，到了这一步几乎不会出问题了。</li><li>本人安装最后还遇到一点小问题，在选择语言，选择输入法等等过去，到最后连接Wi-Fi时，<strong>卡卡卡住了</strong>，问题不大，重启就好，自动安装到选择语言系统已经完成了安装，重启重新跟着引导配置一次就可以了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GitHub】解决无法访问、加载缓慢等问题</title>
      <link href="post/d361f453.html"/>
      <url>post/d361f453.html</url>
      
        <content type="html"><![CDATA[<p>本文的方法可以大概率解决：GitHub中的用户头像和文章中的图片随缘显示，经常不能加载；使用GitHub仓库作为图床，本地访问图片时加载失败等问题。</p><a id="more"></a><h2 id="问题原因">问题原因</h2><p>以拉取代码时的报错为例：curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</p><p>从报错信息可以发现，脚本需要到 raw.githubusercontent.com 上拉取代码。</p><p>问题的原因是github一些域名的 <a href="https://zhuanlan.zhihu.com/p/101908711">DNS 解析被污染</a>，导致DNS 解析过程无法通过域名取得正确的IP地址。</p><h2 id="解决方案">解决方案</h2><ol type="1"><li><p>打开 <a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 输入访问不了的域名（其它类似问题输入对应域名）raw.githubusercontent.com</p><p><img src="https://img-blog.csdnimg.cn/20200910235026353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" /></p></li><li><p>查询后会得到正确的IP地址：</p><div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">199.232.68.133</span> raw.githubusercontent.com</span><span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">199.232.68.133</span> user-images.githubusercontent.com</span><span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ex">199.232.68.133</span> avatars2.githubusercontent.com</span><span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ex">199.232.68.133</span> avatars1.githubusercontent.com</span></code></pre></div><p>截图里由于博主已经配置好了，返回的结果里没有包括正确的IP地址。</p></li><li><p>在本机的 host 文件中添加以上几条host配置。可以使用switchhosts方便 host 管理。</p></li><li><p>下载安装 <a href="https://github.com/oldj/SwitchHosts/releases">switchhosts</a> ，使用非常便捷，在my hosts里添加并启用上述host配置就可以了。 <img src="https://img-blog.csdnimg.cn/20200911000623389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JyZWFraW5nRGF3bjA=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" /></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
